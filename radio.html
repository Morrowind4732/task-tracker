<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Web PTT (Walkie-Talkie)</title>
<style>
  :root{
    --bg:#0b1220; --card:#121a2a; --ink:#dbe2ff; --muted:#8ca0ff; --accent:#5b8cff; --ok:#39d98a; --warn:#ffb020;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b1220 0%, #0f1830 100%);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:780px;margin:0 auto;padding:24px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
  h1{font-size:20px;margin:0;color:#e9edff}
  .card{background:var(--card);border:1px solid #1e2a44;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type=text]{flex:1;min-width:180px;background:#0c1424;border:1px solid #243153;color:#e9edff;padding:10px 12px;border-radius:10px}
  button{background:#1a2a4d;border:1px solid #2c3d6b;color:#edf2ff;padding:10px 14px;border-radius:10px;cursor:pointer}
  button.primary{background:linear-gradient(180deg,#345eea 0%,#2747b8 100%);border-color:#2747b8}
  button.chip{font-size:12px;padding:6px 10px;border-radius:999px;background:#0e1830;border:1px solid #21315a;color:#a9bbff}
  button:disabled{opacity:.5;cursor:not-allowed}
  .status{font-size:13px;color:#a9bbff;margin-top:8px;min-height:18px}
  .grid{display:grid;grid-template-columns:1fr;gap:14px;margin-top:16px}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;background:#0e1830;border:1px solid #21315a;color:#a9bbff;font-size:12px}
  .ptt{display:flex;flex-direction:column;align-items:center;gap:10px;margin-top:10px}
  .ptt button#talk{
    width:100%;height:72px;font-size:20px;font-weight:700;border-radius:18px;
    background:radial-gradient(60% 100% at 50% 0%, #5b8cff 0%, #345eea 100%);
    border:1px solid #2747b8;box-shadow:0 12px 28px rgba(39,71,184,.45), inset 0 0 0 2px rgba(255,255,255,.06)
  }
  .ptt button#talk.talking{
    background:radial-gradient(60% 100% at 50% 0%, #39d98a 0%, #1d9c64 100%);
    border-color:#1d9c64;box-shadow:0 12px 28px rgba(29,156,100,.45), inset 0 0 0 2px rgba(255,255,255,.1)
  }
  .badgelist{display:flex;flex-wrap:wrap;gap:8px}
  audio{width:100%;margin-top:6px;background:#0e1830;border-radius:10px}
  .small{font-size:12px;color:#a9bbff}
  .hint{font-size:12px;color:#7a8bcb;margin-top:8px}
  .hr{height:1px;background:#1e2a44;margin:16px 0}
  .recents{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Web Push-To-Talk</h1>
    <span class="pill">Secure origin required (HTTPS)</span>
  </header>

  <div class="card">
    <div class="row">
      <input id="roomId" placeholder="Room ID (share this)" />
      <button id="makeId">Random</button>
      <button id="join" class="primary">Join</button>
      <button id="beep">Test Beep</button>
    </div>
    <div class="recents" style="margin-top:8px">
      <button class="chip" id="recent1" disabled>-</button>
      <button class="chip" id="recent2" disabled>-</button>
      <button class="chip" id="recent3" disabled>-</button>
    </div>

    <div class="status" id="status">Not connected.</div>

    <div class="grid">
      <div>
        <div class="badgelist">
          <span class="pill" id="micState">Mic: off</span>
          <span class="pill" id="connState">Peer: idle</span>
          <span class="pill" id="iceState">ICE: -</span>
        </div>
        <div class="ptt">
          <button id="talk" disabled>Hold to Talk</button>
          <div class="hint">True PTT: mic hardware is only active while pressed. Release to stop sending.</div>
          <audio id="remoteAudio" autoplay playsinline></audio>
          <div class="small">If you don’t hear anything, ensure both sides pressed <b>Join</b> and granted mic permission.</div>
        </div>
      </div>
    </div>

    <div class="hr"></div>
    <div class="small">
      Tips:
      <ul>
        <li>Both sides must use the same <b>Room ID</b>.</li>
        <li>First person to Join becomes host; second person joins as callee.</li>
        <li>Reusing an old ID? This page auto-resets stale rooms for you.</li>
        <li>Android can play in background; iOS Safari can’t keep WebRTC alive reliably in background.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<script>
/*** 1) FIREBASE CONFIG ***/
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.appspot.com",
  appId: "1:795274673000:web:0ea07130e45c72384134dd"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/*** 2) DOM ***/
const roomIdEl    = document.getElementById('roomId');
const makeIdBtn   = document.getElementById('makeId');
const joinBtn     = document.getElementById('join');
const talkBtn     = document.getElementById('talk');
const beepBtn     = document.getElementById('beep');
const statusEl    = document.getElementById('status');
const micStateEl  = document.getElementById('micState');
const connStateEl = document.getElementById('connState');
const iceStateEl  = document.getElementById('iceState');
const remoteAudio = document.getElementById('remoteAudio');
const recentBtns  = [document.getElementById('recent1'), document.getElementById('recent2'), document.getElementById('recent3')];

/*** 3) STATE ***/
let pc, roomDoc, callerCandidates, calleeCandidates;
let isJoined = false;
let isHost = false;

// Perfect Negotiation flags + ids
let makingOffer = false;
let ignoreOffer = false;
let isPolite = false; // callee will be polite
let myId = Math.random().toString(36).slice(2,10);
let myOfferSeq = 0;
let lastSeenOfferSeq = -1;
let lastSeenAnswerSeq = -1;

// True PTT sender + current track
let sender = null;
let currentMicTrack = null;

// Buffer ICE until subcollections exist
let pendingIce = [];

/*** 4) UTILITIES ***/
const genId = () => Math.random().toString(36).slice(2,8).toUpperCase();
makeIdBtn.addEventListener('click', () => { roomIdEl.value = genId(); });

function setStatus(msg){ statusEl.textContent = msg; }
function setMicBadge(on){ micStateEl.textContent = `Mic: ${on ? 'on (PTT)' : 'off'}`; }
function setConnBadge(){ connStateEl.textContent = `Peer: ${pc ? pc.connectionState : 'idle'}`; }
function setIceBadge(){ iceStateEl.textContent = `ICE: ${pc ? pc.iceConnectionState : '-'}`; }

function saveRecent(id){
  if (!id) return;
  const key = 'ptt_recent_rooms';
  const list = JSON.parse(localStorage.getItem(key) || '[]');
  const next = [id, ...list.filter(x => x !== id)].slice(0,3);
  localStorage.setItem(key, JSON.stringify(next));
  renderRecents();
}
function renderRecents(){
  const list = JSON.parse(localStorage.getItem('ptt_recent_rooms') || '[]');
  for (let i=0;i<3;i++){
    const b = recentBtns[i];
    const label = list[i];
    if (label){
      b.textContent = label;
      b.disabled = false;
      b.onclick = () => { roomIdEl.value = label; joinBtn.click(); };
    } else {
      b.textContent = '-';
      b.disabled = true;
      b.onclick = null;
    }
  }
}
renderRecents();

// test beep (verify playback route/volume)
beepBtn.addEventListener('click', async () => {
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'sine'; o.frequency.value = 880; g.gain.value = 0.06;
    o.connect(g).connect(ctx.destination); o.start(); setTimeout(()=>{o.stop(); ctx.close();}, 350);
  }catch{}
});

/*** 5) CLEANUP HELPERS ***/
async function deleteCollection(collRef){
  const snap = await collRef.get();
  const batch = db.batch();
  snap.forEach(doc => batch.delete(doc.ref));
  return batch.commit();
}
async function clearRoomDoc(ref){
  await deleteCollection(ref.collection('callerCandidates'));
  await deleteCollection(ref.collection('calleeCandidates'));
  await ref.delete();
}

/*** 6) TRUE PTT (request mic only while pressed) ***/
async function startTalking(){
  if (!isJoined || !sender) return;
  if (currentMicTrack) return; // already talking

  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });
    const track = stream.getAudioTracks()[0];
    if (!track) return;

    currentMicTrack = track;
    await sender.replaceTrack(track); // attach
    talkBtn.classList.add('talking');
    setMicBadge(true);

    // attaching may need renegotiation
    maybeOffer();
  }catch(e){
    console.error('Mic error:', e);
    setStatus('Mic error: ' + (e.message || e));
  }
}
async function stopTalking(){
  if (!sender) return;
  try { await sender.replaceTrack(null); } catch {}
  if (currentMicTrack){
    try { currentMicTrack.stop(); } catch {}
    currentMicTrack = null;
  }
  talkBtn.classList.remove('talking');
  setMicBadge(false);
  // detaching may need renegotiation
  maybeOffer();
}
function attachPTTHandlers(){
  const downEvts = ['pointerdown','touchstart','mousedown'];
  const upEvts   = ['pointerup','pointercancel','touchend','mouseup','mouseleave'];
  downEvts.forEach(e => talkBtn.addEventListener(e, startTalking));
  upEvts.forEach(e => talkBtn.addEventListener(e, stopTalking));
  document.addEventListener('visibilitychange', () => { if (document.hidden) stopTalking(); });
  window.addEventListener('beforeunload', () => { stopTalking(); });
  talkBtn.addEventListener('contextmenu', e => e.preventDefault());
}

/*** 7) SDP RENEGOTIATION (Perfect Negotiation + Firestore) ***/
let offerBusy = false;

async function maybeOffer(){
  if (offerBusy) return;
  if (pc.signalingState !== 'stable') return;
  offerBusy = true;
  try {
    makingOffer = true;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    myOfferSeq += 1;

    await roomDoc.set({
      offer: { sdp: offer.sdp, type: offer.type, ts: Date.now(), seq: myOfferSeq, sid: myId }
    }, { merge: true });

    console.log('[OFFER] seq', myOfferSeq, 'by', myId);
  } catch (e) {
    console.warn('maybeOffer error:', e);
  } finally {
    makingOffer = false;
    offerBusy = false;
  }
}


/*** 8) JOIN / ROOM FLOW ***/
joinBtn.addEventListener('click', async () => {
  if (isJoined) return;
  const roomId = (roomIdEl.value || '').trim();
  if (!roomId){ roomIdEl.value = genId(); return; }
  joinBtn.disabled = true;

  try{
    pc = new RTCPeerConnection({ iceServers: [{urls:'stun:stun.l.google.com:19302'}] });
    setConnBadge(); setIceBadge();

    // Prepare an audio m-line up front (no track yet).
    const transceiver = pc.addTransceiver('audio', { direction: 'sendrecv' });
    sender = transceiver.sender;

    pc.onconnectionstatechange = () => { setConnBadge(); setStatus(`Peer: ${pc.connectionState}`); };
    pc.oniceconnectionstatechange = () => setIceBadge();

    pc.onicecandidate = async (event) => {
      if (!event.candidate) return;
      const cand = event.candidate.toJSON();
      if (!callerCandidates && !calleeCandidates) { // not ready yet
        pendingIce.push(cand);
        return;
      }
      try {
        if (isHost) await callerCandidates.add(cand);
        else        await calleeCandidates.add(cand);
      } catch {
        pendingIce.push(cand);
      }
    };

    // Hardened receiver + Media Session (Android background)
    pc.ontrack = (event) => {
      const attach = () => {
        const stream = (event.streams && event.streams[0]) ? event.streams[0] : new MediaStream([event.track]);
        if (remoteAudio.srcObject !== stream) remoteAudio.srcObject = stream;
        remoteAudio.muted = false;
        remoteAudio.volume = 1.0;
        remoteAudio.play?.().catch(()=>{});
      };
      if (event.track && event.track.muted) {
        event.track.onunmute = () => { attach(); event.track.onunmute = null; };
      } else {
        attach();
      }
      if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
          title: 'Walkie-Talkie',
          artist: 'PTT Room ' + (roomIdEl.value || ''),
          album: 'WebRTC'
        });
        navigator.mediaSession.setActionHandler('play',  () => remoteAudio.play());
        navigator.mediaSession.setActionHandler('pause', () => remoteAudio.pause());
      }
      console.log('Remote track: audio muted=', event.track.muted, 'readyState=', event.track.readyState);
    };



    // Firestore room doc
    roomDoc = db.collection('ptt_rooms').doc(roomId);
    const snap = await roomDoc.get();

    if (!snap.exists) {
      // HOST (impolite)
      isHost = true;
      isPolite = false;
      callerCandidates = roomDoc.collection('callerCandidates');
      calleeCandidates = roomDoc.collection('calleeCandidates');

      await roomDoc.set({ created: Date.now() }, { merge: true });

      // first offer
      await maybeOffer();

      // flush any buffered ICE now that collections exist
      if (pendingIce.length) {
        const batch = db.batch();
        pendingIce.forEach(c => batch.set(callerCandidates.doc(), c));
        await batch.commit();
        pendingIce = [];
      }

      roomDoc.onSnapshot(async (s) => {
        const data = s.data() || {};

        // Remote offer (callee renegotiation)
        if (data.offer && data.offer.sid !== myId && (data.offer.seq ?? -1) > lastSeenOfferSeq) {
          lastSeenOfferSeq = data.offer.seq;
          const offerDesc = { type: 'offer', sdp: data.offer.sdp };
          const offerCollision = makingOffer || pc.signalingState !== 'stable';
          ignoreOffer = !isPolite && offerCollision; // host is impolite
          if (ignoreOffer) {
            console.log('Ignoring remote offer (impolite & in collision)');
            return;
          }
          if (offerCollision) {
            try { await pc.setLocalDescription({ type: 'rollback' }); } catch {}
          }
          await pc.setRemoteDescription(offerDesc);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await roomDoc.set({
            answer: { sdp: answer.sdp, type: answer.type, ts: Date.now(), seq: lastSeenOfferSeq, sid: myId }
          }, { merge: true });
          console.log('[ANSWERED] seq', lastSeenOfferSeq);
        }

        // Remote answer to our latest offer
        if (data.answer && data.answer.sid !== myId && (data.answer.seq ?? -1) > lastSeenAnswerSeq) {
          lastSeenAnswerSeq = data.answer.seq;
          if (pc.signalingState !== 'stable') {
            try { await pc.setRemoteDescription({ type: 'answer', sdp: data.answer.sdp }); } catch {}
          }
        }
      });

      // ICE from callee
      calleeCandidates.onSnapshot(s => {
        s.docChanges().forEach(ch => {
          if (ch.type === 'added') pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
        });
      });

      setStatus(`Created room ${roomId}. Share this ID with your partner.`);
    } else {
      // Room exists
      const data = snap.data();
      const hasOffer = !!(data && data.offer && data.offer.sdp);
      const hasAnswer = !!(data && data.answer && data.answer.sdp);

      if (hasOffer && !hasAnswer) {
        // CALLEE (polite)
        isHost = false;
        isPolite = true;
        callerCandidates = roomDoc.collection('callerCandidates');
        calleeCandidates = roomDoc.collection('calleeCandidates');

        // apply existing remote offer w/ glare handling
        const remote = { type: 'offer', sdp: data.offer.sdp };
        const collision = makingOffer || pc.signalingState !== 'stable';
        ignoreOffer = !isPolite && collision;
        if (collision) {
          try { await pc.setLocalDescription({ type: 'rollback' }); } catch {}
        }
        await pc.setRemoteDescription(remote);

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await roomDoc.set({
          answer: { sdp: answer.sdp, type: answer.type, ts: Date.now(), seq: (data.offer.seq ?? 0), sid: myId }
        }, { merge: true });
        lastSeenOfferSeq = data.offer.seq ?? 0;
        console.log('[ANSWERED initial] seq', lastSeenOfferSeq);

        // flush buffered ICE
        if (pendingIce.length) {
          const batch = db.batch();
          pendingIce.forEach(c => batch.set(calleeCandidates.doc(), c));
          await batch.commit();
          pendingIce = [];
        }

        // listen for future host offers (and any renegotiations)
        roomDoc.onSnapshot(async (s) => {
          const d = s.data() || {};
          if (d.offer && d.offer.sid !== myId && (d.offer.seq ?? -1) > lastSeenOfferSeq) {
            lastSeenOfferSeq = d.offer.seq;
            const offerDesc = { type: 'offer', sdp: d.offer.sdp };
            const coll = makingOffer || pc.signalingState !== 'stable';
            ignoreOffer = !isPolite && coll; // callee is polite, so usually false
            if (ignoreOffer) {
              console.log('Ignoring remote offer (impolite & in collision)');
              return;
            }
            if (coll) {
              try { await pc.setLocalDescription({ type: 'rollback' }); } catch {}
            }
            await pc.setRemoteDescription(offerDesc);
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            await roomDoc.set({
              answer: { sdp: ans.sdp, type: ans.type, ts: Date.now(), seq: lastSeenOfferSeq, sid: myId }
            }, { merge: true });
            console.log('[ANSWERED] seq', lastSeenOfferSeq);
          }

          if (d.answer && d.answer.sid !== myId && (d.answer.seq ?? -1) > lastSeenAnswerSeq) {
            lastSeenAnswerSeq = d.answer.seq;
            if (pc.signalingState !== 'stable') {
              try { await pc.setRemoteDescription({ type: 'answer', sdp: d.answer.sdp }); } catch {}
            }
          }
        });

        // ICE from caller (host)
        callerCandidates.onSnapshot(s => {
          s.docChanges().forEach(ch => {
            if (ch.type === 'added') pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
          });
        });

        setStatus(`Joined room ${roomId}.`);
      } else {
        // STALE → reset and host
        await clearRoomDoc(roomDoc);

        isHost = true;
        isPolite = false;
        callerCandidates = roomDoc.collection('callerCandidates');
        calleeCandidates = roomDoc.collection('calleeCandidates');

        await roomDoc.set({ created: Date.now() }, { merge: true });
        await maybeOffer();

        roomDoc.onSnapshot(async (s) => {
          const d = s.data() || {};
          if (d.offer && d.offer.sid !== myId && (d.offer.seq ?? -1) > lastSeenOfferSeq) {
            lastSeenOfferSeq = d.offer.seq;
            const offerDesc = { type: 'offer', sdp: d.offer.sdp };
            const coll = makingOffer || pc.signalingState !== 'stable';
            ignoreOffer = !isPolite && coll;
            if (ignoreOffer) {
              console.log('Ignoring remote offer (impolite & in collision)');
              return;
            }
            if (coll) {
              try { await pc.setLocalDescription({ type: 'rollback' }); } catch {}
            }
            await pc.setRemoteDescription(offerDesc);
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            await roomDoc.set({
              answer: { sdp: ans.sdp, type: ans.type, ts: Date.now(), seq: lastSeenOfferSeq, sid: myId }
            }, { merge: true });
            console.log('[ANSWERED] seq', lastSeenOfferSeq);
          }
          if (d.answer && d.answer.sid !== myId && (d.answer.seq ?? -1) > lastSeenAnswerSeq) {
            lastSeenAnswerSeq = d.answer.seq;
            if (pc.signalingState !== 'stable') {
              try { await pc.setRemoteDescription({ type: 'answer', sdp: d.answer.sdp }); } catch {}
            }
          }
        });

        calleeCandidates.onSnapshot(s => {
          s.docChanges().forEach(ch => {
            if (ch.type === 'added') pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
          });
        });

        setStatus(`Recreated room ${roomId}. Share this ID with your partner.`);
      }
    }

    // Enable UI
    isJoined = true;
    talkBtn.disabled = false;
    attachPTTHandlers();
    saveRecent(roomId);
    joinBtn.disabled = false;

  } catch(err){
    console.error(err);
    setStatus('Error: ' + (err.message || err.toString()));
    joinBtn.disabled = false;
  }
});

/*** 9) OPTIONAL LEAVE ***/
async function leave(){
  await stopTalking();
  if (pc) pc.close();
  isJoined = false;
}
</script>
</body>
</html>
