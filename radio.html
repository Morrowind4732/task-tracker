<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Web PTT (Walkie-Talkie)</title>
<style>
  :root{
    --bg:#0b1220; --card:#121a2a; --ink:#dbe2ff; --muted:#8ca0ff; --accent:#5b8cff; --ok:#39d98a; --warn:#ffb020;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b1220 0%, #0f1830 100%);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:780px;margin:0 auto;padding:24px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
  h1{font-size:20px;margin:0;color:#e9edff}
  .card{background:var(--card);border:1px solid #1e2a44;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type=text]{flex:1;min-width:180px;background:#0c1424;border:1px solid #243153;color:var(--ink);padding:10px 12px;border-radius:10px}
  button{background:#1a2a4d;border:1px solid #2c3d6b;color:#edf2ff;padding:10px 14px;border-radius:10px;cursor:pointer}
  button.primary{background:linear-gradient(180deg,#345eea 0%,#2747b8 100%);border-color:#2747b8}
  button.chip{font-size:12px;padding:6px 10px;border-radius:999px;background:#0e1830;border:1px solid #21315a;color:#a9bbff}
  button:disabled{opacity:.5;cursor:not-allowed}
  .status{font-size:13px;color:var(--muted);margin-top:8px;min-height:18px}
  .grid{display:grid;grid-template-columns:1fr;gap:14px;margin-top:16px}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;background:#0e1830;border:1px solid #21315a;color:#a9bbff;font-size:12px}
  .ptt{display:flex;flex-direction:column;align-items:center;gap:10px;margin-top:10px}
  .ptt button#talk{
    width:100%;height:72px;font-size:20px;font-weight:700;border-radius:18px;
    background:radial-gradient(60% 100% at 50% 0%, #5b8cff 0%, #345eea 100%);
    border:1px solid #2747b8;box-shadow:0 12px 28px rgba(39,71,184,.45), inset 0 0 0 2px rgba(255,255,255,.06)
  }
  .ptt button#talk.talking{
    background:radial-gradient(60% 100% at 50% 0%, #39d98a 0%, #1d9c64 100%);
    border-color:#1d9c64;box-shadow:0 12px 28px rgba(29,156,100,.45), inset 0 0 0 2px rgba(255,255,255,.1)
  }
  .badgelist{display:flex;flex-wrap:wrap;gap:8px}
  audio{width:100%;margin-top:6px;background:#0e1830;border-radius:10px}
  .small{font-size:12px;color:#a9bbff}
  .hint{font-size:12px;color:#7a8bcb;margin-top:8px}
  .hr{height:1px;background:#1e2a44;margin:16px 0}
  .recents{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Web Push-To-Talk</h1>
    <span class="pill">Secure origin required (HTTPS)</span>
  </header>

  <div class="card">
    <div class="row">
      <input id="roomId" placeholder="Room ID (share this)" />
      <button id="makeId">Random</button>
      <button id="join" class="primary">Join</button>
      <!-- tiny utility to confirm playback device works -->
      <button id="beep">Test Beep</button>
    </div>
    <div class="recents" style="margin-top:8px">
      <button class="chip" id="recent1" disabled>-</button>
      <button class="chip" id="recent2" disabled>-</button>
      <button class="chip" id="recent3" disabled>-</button>
    </div>

    <div class="status" id="status">Not connected.</div>

    <div class="grid">
      <div>
        <div class="badgelist">
          <span class="pill" id="micState">Mic: off</span>
          <span class="pill" id="connState">Peer: idle</span>
          <span class="pill" id="iceState">ICE: -</span>
        </div>
        <div class="ptt">
          <button id="talk" disabled>Hold to Talk</button>
          <div class="hint">True PTT: mic hardware is only active while pressed. Release to stop sending.</div>
          <audio id="remoteAudio" autoplay playsinline></audio>
          <div class="small">If you don’t hear anything, ensure both sides pressed <b>Join</b> and granted mic permission.</div>
        </div>
      </div>
    </div>

    <div class="hr"></div>
    <div class="small">
      Tips:
      <ul>
        <li>Both sides must use the same <b>Room ID</b>.</li>
        <li>First person to Join becomes host; second person joins as callee.</li>
        <li>Reusing an old ID? This page auto-resets stale rooms for you.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<script>
/*** 1) FIREBASE CONFIG ***/
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.appspot.com",
  appId: "1:795274673000:web:0ea07130e45c72384134dd"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/*** 2) DOM ***/
const roomIdEl    = document.getElementById('roomId');
const makeIdBtn   = document.getElementById('makeId');
const joinBtn     = document.getElementById('join');
const talkBtn     = document.getElementById('talk');
const statusEl    = document.getElementById('status');
const micStateEl  = document.getElementById('micState');
const connStateEl = document.getElementById('connState');
const iceStateEl  = document.getElementById('iceState');
const remoteAudio = document.getElementById('remoteAudio');
const beepBtn     = document.getElementById('beep');
const recentBtns  = [document.getElementById('recent1'), document.getElementById('recent2'), document.getElementById('recent3')];

/*** 3) STATE ***/
let pc, roomDoc, callerCandidates, calleeCandidates;
let isJoined = false;
let isHost = false;

// Transceiver-based PTT
let audioTransceiver = null;
let micSender = null;
let currentMicTrack = null;

/*** 4) UTILITIES ***/
const genId = () => Math.random().toString(36).slice(2,8).toUpperCase();
makeIdBtn.addEventListener('click', () => { roomIdEl.value = genId(); });

function setStatus(msg){ statusEl.textContent = msg; }
function setMicBadge(on){ micStateEl.textContent = `Mic: ${on ? 'on (PTT)' : 'off'}`; }
function setConnBadge(){ connStateEl.textContent = `Peer: ${pc ? pc.connectionState : 'idle'}`; }
function setIceBadge(){ iceStateEl.textContent = `ICE: ${pc ? pc.iceConnectionState : '-'}`; }

function saveRecent(id){
  if (!id) return;
  const key = 'ptt_recent_rooms';
  const list = JSON.parse(localStorage.getItem(key) || '[]');
  const next = [id, ...list.filter(x => x !== id)].slice(0,3);
  localStorage.setItem(key, JSON.stringify(next));
  renderRecents();
}
function renderRecents(){
  const list = JSON.parse(localStorage.getItem('ptt_recent_rooms') || '[]');
  for (let i=0;i<3;i++){
    const b = recentBtns[i];
    const label = list[i];
    if (label){
      b.textContent = label;
      b.disabled = false;
      b.onclick = () => { roomIdEl.value = label; joinBtn.click(); };
    } else {
      b.textContent = '-';
      b.disabled = true;
      b.onclick = null;
    }
  }
}
renderRecents();

// test beep (helps verify playback route/volume)
beepBtn.addEventListener('click', async () => {
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'sine'; o.frequency.value = 880; g.gain.value = 0.05;
    o.connect(g).connect(ctx.destination); o.start(); setTimeout(()=>{o.stop(); ctx.close();}, 400);
  }catch{}
});

/*** 5) ROOM CLEANUP HELPERS ***/
async function deleteCollection(collRef){
  const snap = await collRef.get();
  const batch = db.batch();
  snap.forEach(doc => batch.delete(doc.ref));
  return batch.commit();
}
async function clearRoomDoc(ref){
  await deleteCollection(ref.collection('callerCandidates'));
  await deleteCollection(ref.collection('calleeCandidates'));
  await ref.delete();
}

/*** 6) PTT (true push-to-talk mic lifecycle) ***/
async function startTalking(){
  if (!isJoined || !micSender) return;
  if (currentMicTrack) return; // already talking

  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });
    const track = stream.getAudioTracks()[0];
    if (!track) return;

    // safety guards before we attach
    if (!micSender) { track.stop(); return; }
    if (track.readyState === 'ended') { track.stop(); return; }

    await micSender.replaceTrack(track);
    currentMicTrack = track;

    talkBtn.classList.add('talking');
    setMicBadge(true);
  }catch(e){
    console.error('Mic error:', e);
    setStatus('Mic error: ' + (e.message || e));
  }
}
async function stopTalking(){
  if (micSender) {
    try { await micSender.replaceTrack(null); } catch {}
  }
  if (currentMicTrack){
    try { currentMicTrack.stop(); } catch {}
    currentMicTrack = null;
  }
  talkBtn.classList.remove('talking');
  setMicBadge(false);
}
function attachPTTHandlers(){
  const downEvts = ['pointerdown','touchstart','mousedown'];
  const upEvts   = ['pointerup','pointercancel','touchend','mouseup','mouseleave'];
  downEvts.forEach(e => talkBtn.addEventListener(e, startTalking));
  upEvts.forEach(e => talkBtn.addEventListener(e, stopTalking));
  document.addEventListener('visibilitychange', () => { if (document.hidden) stopTalking(); });
  window.addEventListener('beforeunload', () => { stopTalking(); });
  talkBtn.addEventListener('contextmenu', e => e.preventDefault());
}

/*** 7) JOIN (Option B with auto-reset) ***/
joinBtn.addEventListener('click', async () => {
  if (isJoined) return;
  const roomId = (roomIdEl.value || '').trim();
  if (!roomId){ roomIdEl.value = genId(); return; }
  joinBtn.disabled = true;

  try{
    pc = new RTCPeerConnection({ iceServers: [{urls:'stun:stun.l.google.com:19302'}] });
    setConnBadge(); setIceBadge();

    // create recv/send m-line up front; we attach mic on press later
    audioTransceiver = pc.addTransceiver('audio', { direction: 'sendrecv' });
    micSender = audioTransceiver.sender;

    pc.onconnectionstatechange = () => { setConnBadge(); setStatus(`Peer: ${pc.connectionState}`); };
    pc.oniceconnectionstatechange = () => setIceBadge();
    pc.onicecandidate = async (event) => {
      if (!event.candidate) return;
      const cand = event.candidate.toJSON();
      if (isHost) await callerCandidates.add(cand);
      else        await calleeCandidates.add(cand);
    };

    // HARDENED receiver
    pc.ontrack = (event) => {
      const attach = () => {
        const stream = (event.streams && event.streams[0])
          ? event.streams[0]
          : new MediaStream([event.track]);

        if (remoteAudio.srcObject !== stream) remoteAudio.srcObject = stream;
        remoteAudio.muted = false;
        remoteAudio.volume = 1.0;
        remoteAudio.play?.().catch(()=>{});
      };

      if (event.track && event.track.muted) {
        event.track.onunmute = () => { attach(); event.track.onunmute = null; };
      } else {
        attach();
      }

      if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
          title: 'Walkie-Talkie',
          artist: 'PTT Room ' + (roomIdEl.value || ''),
          album: 'WebRTC'
        });
        navigator.mediaSession.setActionHandler('play',  () => remoteAudio.play());
        navigator.mediaSession.setActionHandler('pause', () => remoteAudio.pause());
      }

      console.log('Remote track:', event.track.kind,
                  'muted=', event.track.muted,
                  'readyState=', event.track.readyState);
    };

    // Firestore room doc
    roomDoc = db.collection('ptt_rooms').doc(roomId);
    const snap = await roomDoc.get();

    if (!snap.exists) {
      // HOST
      isHost = true;
      callerCandidates = roomDoc.collection('callerCandidates');
      calleeCandidates = roomDoc.collection('calleeCandidates');

      const offer = await pc.createOffer({ offerToReceiveAudio:true });
      await pc.setLocalDescription(offer);
      await roomDoc.set({ offer: { type: offer.type, sdp: offer.sdp }, created: Date.now() });

      roomDoc.onSnapshot(async (s) => {
        const data = s.data();
        if (!pc.currentRemoteDescription && data && data.answer){
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
      });

      calleeCandidates.onSnapshot(s => {
        s.docChanges().forEach(ch => {
          if (ch.type === 'added') pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
        });
      });

      setStatus(`Created room ${roomId}. Share this ID with your partner.`);
    } else {
      // Existing: callee if offer-only; otherwise reset + host
      const data = snap.data();
      const hasOffer = !!(data && data.offer && data.offer.sdp);
      const hasAnswer = !!(data && data.answer && data.answer.sdp);

      if (hasOffer && !hasAnswer){
        // CALLEE
        isHost = false;
        callerCandidates = roomDoc.collection('callerCandidates');
        calleeCandidates = roomDoc.collection('calleeCandidates');

        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await roomDoc.update({ answer: { type: answer.type, sdp: answer.sdp }, answered: Date.now() });

        callerCandidates.onSnapshot(s => {
          s.docChanges().forEach(ch => {
            if (ch.type === 'added') pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
          });
        });

        setStatus(`Joined room ${roomId}.`);
      } else {
        // STALE → reset and host
        await clearRoomDoc(roomDoc);

        isHost = true;
        callerCandidates = roomDoc.collection('callerCandidates');
        calleeCandidates = roomDoc.collection('calleeCandidates');

        const offer = await pc.createOffer({ offerToReceiveAudio:true });
        await pc.setLocalDescription(offer);
        await roomDoc.set({ offer: { type: offer.type, sdp: offer.sdp }, created: Date.now() });

        roomDoc.onSnapshot(async (s) => {
          const d = s.data();
          if (!pc.currentRemoteDescription && d && d.answer){
            await pc.setRemoteDescription(new RTCSessionDescription(d.answer));
          }
        });
        calleeCandidates.onSnapshot(s => {
          s.docChanges().forEach(ch => {
            if (ch.type === 'added') pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
          });
        });
        setStatus(`Recreated room ${roomId}. Share this ID with your partner.`);
      }
    }

    // Enable UI
    isJoined = true;
    talkBtn.disabled = false;
    attachPTTHandlers();
    saveRecent(roomId);
    joinBtn.disabled = false;

  } catch(err){
    console.error(err);
    setStatus('Error: ' + (err.message || err.toString()));
    joinBtn.disabled = false;
  }
});

/*** 8) OPTIONAL LEAVE ***/
async function leave(){
  await stopTalking();
  if (pc) pc.close();
  isJoined = false;
}
</script>
</body>
</html>
