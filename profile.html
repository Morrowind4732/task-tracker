<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scoring V2</title>

<style>
  :root { --gap:12px; --border:#ddd; --chip-bg:#f5f5f7; --accent:#0b74ff; }
  body { font-family: system-ui, sans-serif; margin: 16px; background:#f5f5f5; color:#111; }
  .title-row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .mini-link { font-size:12px; color:var(--accent); text-decoration:underline; }
  .mini-link:visited { color:var(--accent); }
  .muted { color:#666; font-size:12px; }

  .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .btn.primary { background:var(--accent); border-color:var(--accent); color:#fff; }
  .btn.ghost { background:#fff; border-color:#ccc; }

  .section { border:1px solid var(--border); border-radius:12px; padding:12px; margin-top:14px; background:#fff; }

  /* Tabs / day */
  .tabs-bar { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .tabs { display:flex; align-items:flex-end; gap:6px; flex-wrap:wrap; }
  .tab { padding:8px 12px; border:1px solid var(--border); border-radius:10px; background:#f6f6f6; cursor:pointer; font-weight:600; color:#444; }
  .tab.active { background:#fff; color:#111; box-shadow:0 -1px 0 #fff inset; }

  /* Hero / dog card */
  .hero { display:grid; grid-template-columns: 120px 1fr; gap: 12px; align-items:center; }
  .hero img { width:120px; height:120px; object-fit:cover; border-radius:10px; border:1px solid #ccc; background:#fafafa; }

  /* Scores list */
  .score-list { display:flex; flex-direction:column; gap:12px; }
  .score-card {
    border:1px solid #e2e2e2; border-radius:10px; padding:10px; background:#fafafa;
    display:grid; gap:8px; grid-template-columns: 1fr;
  }
  .score-header { display:flex; justify-content:space-between; align-items:center; gap:10px; }
  .score-title { font-weight:700; }
  .slider-row { display:flex; align-items:center; gap:10px; }
  .slider-row input[type="range"] { flex:1; }
  .slider-val { width:52px; text-align:right; font-variant-numeric: tabular-nums; }
  .flag-btn { padding:10px 14px; border-radius:999px; font-weight:600; }

  .actions { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:8px; }

  /* Pane tabs (Marks/Blinds) */
  .mini-tabs { display:flex; gap:6px; align-items:center; margin-top:8px; }
  .mini-tab { padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#f7f7f7; font-weight:600; cursor:pointer; }
  .mini-tab.active { background:#fff; border-color:#bbb; box-shadow:0 1px 0 rgba(0,0,0,.05); }

  /* ===== Radial flags overlay (CROSS layout) ===== */
  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.28); display:none; align-items:center; justify-content:center; z-index:9999; }
  .overlay.open { display:flex; }

  .wheel-wrap { position:relative; width:320px; height:320px; }
  .wheel {
    position:absolute; inset:0; margin:auto;
    width:320px; height:320px; border-radius:50%;
    background:radial-gradient(ellipse at center, #fff, #f4f4f4 60%);
    border:1px solid #e6e6e6;
    box-shadow:0 18px 60px rgba(0,0,0,.28);
    overflow:visible;
  }

  .wheel-title {
    position:absolute; top:-42px; left:50%; transform:translateX(-50%);
    font-weight:800; font-size:16px; color:#222; text-align:center;
    text-shadow:0 1px 0 #fff;
  }

  .center-btn {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:140px; height:140px; border-radius:50%;
    background:#fff; border:1px solid #e5e5e5;
    box-shadow:0 10px 28px rgba(0,0,0,.20);
    font-weight:800;
  }

  .rad-btn {
    position:absolute;
    padding:12px 16px;
    min-width:144px; height:48px;
    border-radius:12px; border:1px solid #dcdcdc; background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.16);
    font-weight:700; white-space:nowrap;
  }
  .rad-btn.active { background:#0b74ff; border-color:#0b74ff; color:#fff; box-shadow:0 10px 24px rgba(11,116,255,.32); }

  @media (max-width:380px){
    .wheel-wrap, .wheel { width:300px; height:300px; }
    .center-btn { width:132px; height:132px; }
    .rad-btn { min-width:132px; height:46px; }
  }
  
  /* === RADIAL KENNEL NAVIGATOR === */
  .k-fab {
    position: fixed; right:16px; bottom:16px;
    width:56px; height:56px; border-radius:50%;
    background: var(--accent); color:#fff; border:none;
    box-shadow:0 8px 20px rgba(0,0,0,.25); font-size:22px;
    cursor:pointer; z-index: 9998;
  }
  .k-overlay { position:fixed; inset:0; background:rgba(0,0,0,.25);
    display:none; align-items:center; justify-content:center; z-index:9999; }
  .k-overlay.open { display:flex; }
  .k-wheel {
    position: relative; width: 280px; height:280px; border-radius:50%;
    background:#fff; border:1px solid var(--border);
    box-shadow:0 12px 30px rgba(0,0,0,.25);
  }
  .k-center { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center; }
  .k-center h4 { margin:0 0 4px; font-size:14px; }
  .k-center .muted { font-size:12px; color:#666; }

  .k-item {
    position:absolute; width:130px; height:84px; border-radius:12px;
    background:#fff; border:1px solid #ddd;
    box-shadow:0 10px 18px rgba(0,0,0,.12);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    gap:4px; text-align:center; padding:8px; cursor:pointer;
  }
  .k-item b { font-size:13px; max-width:120px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .k-item small { color:#666; font-size:11px; }
  .k-item:hover { border-color:#bbb; }

  /* slider row bits */
  .slider-label { font-weight:700; color:#333; min-width:72px; }
  .nudge { width:36px; height:36px; border-radius:8px; border:1px solid #bbb; background:#fff; font-weight:800; line-height:1; cursor:pointer; }
  .nudge:active { transform: translateY(1px); }
</style>
</head>
<body>
  <div class="title-row">
    <h1>Scoring V2</h1>
    <a id="changeUserLink" class="mini-link" href="#">change user</a>
  </div>
  <div class="muted" id="ctx">Loadingâ€¦</div>


<!-- Context setup overlay (trainer â†’ trailer â†’ sex) -->
<div class="overlay" id="ctxOverlay" aria-hidden="true">
  <div class="overlay-card" style="background:#fff; padding:18px; border-radius:12px; min-width:300px; border:1px solid #e5e5e5; box-shadow:0 10px 30px rgba(0,0,0,.2);">
    <h3 id="ctxStepTitle" style="margin:0 0 12px;">Who are you?</h3>

    <!-- Step 1: Trainer -->
    <div id="ctxStepTrainer" class="ctx-step">
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn primary" data-ctx-trainer="Scott">Scott</button>
        <button class="btn primary" data-ctx-trainer="Cody">Cody</button>
        <button class="btn primary" data-ctx-trainer="Brian">Brian</button>
      </div>
    </div>

    <!-- Step 2: Trailer -->
    <div id="ctxStepTrailer" class="ctx-step" style="display:none;">
      <div class="muted" style="margin-bottom:8px;">Pick the trailer:</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" data-ctx-trailer="scott">Scott's Trailer</button>
        <button class="btn" data-ctx-trailer="cody">Cody's Trailer</button>
        <button class="btn" data-ctx-trailer="brian">Brian's Trailer</button>
      </div>
    </div>

    <!-- Step 3: Sex -->
    <div id="ctxStepSex" class="ctx-step" style="display:none;">
      <div class="muted" style="margin-bottom:8px;">Which side of trailer?</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" data-ctx-sex="male">Male</button>
        <button class="btn" data-ctx-sex="female">Female</button>
      </div>
    </div>
  </div>
</div>



  <!-- Trainer chooser overlay -->
  <div class="overlay" id="trainerOverlay">
    <div style="background:#fff; padding:18px; border-radius:12px; min-width:280px; border:1px solid #e5e5e5; box-shadow:0 10px 30px rgba(0,0,0,.2);">
      <h3 style="margin:0 0 10px">Who are you?</h3>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn primary" data-trainer="Scott">Scott</button>
        <button class="btn primary" data-trainer="Cody">Cody</button>
        <button class="btn primary" data-trainer="Brian">Brian</button>
      </div>
    </div>
  </div>
  
  <!-- Start-slot fallback -->
  <div class="overlay" id="startFallbackOverlay" aria-hidden="true">
    <div class="overlay-card">
      <h3>Pick a starting slot</h3>
      <div class="muted">No dog detected. Jump to <b>R2C1</b> for <b id="startTrainerName">â€”</b>:</div>
      <div class="overlay-actions">
        <button class="btn primary" id="startMaleBtn">â™‚ Male R2C1</button>
        <button class="btn primary" id="startFemaleBtn">â™€ Female R2C1</button>
      </div>
      <div class="overlay-actions">
        <button class="btn ghost" id="startCancelBtn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Date / Tabs -->
  <div class="section">
    <div class="tabs-bar">
      <div style="margin-right:auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <label>Day: <input type="date" id="dayPicker"></label>
        <button class="btn ghost" id="todayBtn">Today</button>
      </div>
      <div class="tabs" id="tabs"></div>
    </div>
  </div>
  
  <!-- FAB + radial overlay -->
  <button id="kennelFab" class="k-fab" title="Open kennel navigator">â‡„</button>
  <div id="kennelOverlay" class="k-overlay" aria-hidden="true">
    <div class="k-wheel">
      <div class="k-center">
        <h4 id="kCurName">â€”</h4>
        <div class="muted" id="kCurSlot">R?C?</div>
      </div>
      <!-- items injected by JS -->
    </div>
  </div>

  <!-- Dog hero -->
  <div class="section" id="dogCard">Loading dogâ€¦</div>

  <!-- Scores -->
  <div class="section" id="scoresSection">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
      <strong id="scoresTitle"></strong>
      <div class="mini-tabs" id="paneTabs">
        <button class="mini-tab active" data-pane="marks">Marks</button>
        <button class="mini-tab" data-pane="blinds">Blinds</button>
      </div>
    </div>
    <div class="score-list" id="scoreList"></div>
    <div class="actions">
      <button class="btn primary" id="saveCameraBtn">ðŸ’¾ Save & Camera</button>
      <a class="btn" id="cameraOnlyBtn" href="https://morrowind4732.github.io/task-tracker/Camera.html">ðŸ“· Camera (no save)</a>
      <button class="btn" id="saveOnlyBtn">ðŸ’¾ Save</button>
      <span class="muted" id="saveStatus"></span>
    </div>
  </div>

  <!-- Radial overlay -->
  <div class="overlay" id="radialOverlay" aria-hidden="true">
    <div class="wheel-wrap">
      <div class="wheel" id="wheel">
        <div class="wheel-title" id="wheelTitle">Flags</div>
        <button class="center-btn" id="centerCancel">Cancel</button>
        <!-- buttons injected by JS and positioned -->
      </div>
    </div>
  </div>

  <!-- Firebase (v10 modules) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, onSnapshot, serverTimestamp,
      collection, query, orderBy, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    /* ---------------- Firebase init ---------------- */
    const firebaseConfig = {
      apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
      authDomain: "task-tracker-73b77.firebaseapp.com",
      projectId: "task-tracker-73b77",
      storageBucket: "task-tracker-73b77.firebasestorage.app",
      messagingSenderId: "795274673000",
      appId: "1:795274673000:web:0ea07130e45c72384134dd",
      measurementId: "G-VLW5KLY4FF"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    /* ---------------- Utilities & constants ---------------- */
    const ctxEl = document.getElementById('ctx');
    function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
    function slug(s){
      return String(s||"").toLowerCase().trim()
        .replace(/[\s_]+/g,'-').replace(/[^a-z0-9-]/g,'')
        .replace(/-{2,}/g,'-').replace(/^-+|-+$/g,'');
    }
    const SAVE_DEBOUNCE_MS = 400;

    /* ===== Flags ===== */
    const FLAG_DEFS_MARKS = [
      { key:'bigHunt',         label:'Big Hunt' },
      { key:'marginalHunt',    label:'Marginal Hunt' },
      { key:'overran',         label:'Overran' },
      { key:'shortCheckDown',  label:'Short Checkdown' },
      { key:'backSideOfGun',   label:'Backside of Gun' },

      { key:'handled',         label:'Handled' },
      { key:'castRefusal',     label:'Cast Refusal' },
      { key:'sitOnWhistle',    label:'Sit on Whistle' },
      { key:'didntMark',       label:"Didn't Mark" },
      { key:'poorInitial',     label:'Poor Initial' },

      { key:'headswing',       label:'Headswing' },
      { key:'break',           label:'Broke' },
      { key:'switched',        label:'Switched' },
      { key:'noGo',            label:'No-Go' },

      { key:'pickedUpPoison',  label:'Poison Pick Up' },
      { key:'noPickUp',        label:'No Pick Up' },
      { key:'stoodOut',        label:'Stood Out' },
      { key:'popped',          label:'Popped' },
    ];

    const FLAG_DEFS_BLINDS = [
      { key:'bigHunt',         label:'Big Hunt' },
      { key:'marginalHunt',    label:'Marginal Hunt' },
      { key:'overran',         label:'Overran' },
      { key:'shortCheckDown',  label:'Short Checkdown' },
      { key:'backSideOfGun',   label:'Backside of Gun' },

      { key:'handled',         label:'Handled' },
      { key:'castRefusal',     label:'Cast Refusal' },
      { key:'sitOnWhistle',    label:'Sit on Whistle' },
      { key:'didntMark',       label:"Didn't Mark" },
      { key:'poorInitial',     label:'Poor Initial' },

      { key:'headswing',       label:'Headswing' },
      { key:'break',           label:'Broke' },
      { key:'switched',        label:'Switched' },
      { key:'noGo',            label:'No-Go' },

      { key:'pickedUpPoison',  label:'Poison Pick Up' },
      { key:'noPickUp',        label:'No Pick Up' },
      { key:'stoodOut',        label:'Stood Out' },
      { key:'popped',          label:'Popped' },
    ];

    /* Desired cross layout (always visible) */
    const FLAG_LAYOUT = {
      up:    ['bigHunt','marginalHunt','overran','shortCheckDown','backSideOfGun'],
      down:  ['handled','castRefusal','sitOnWhistle','didntMark','poorInitial'],
      left:  ['headswing','break','switched','noGo'],
      right: ['pickedUpPoison','noPickUp','stoodOut','popped'],
    };

    /* ---------------- URL params ---------------- */
    const params  = new URL(location.href).searchParams;
    const trailer = (params.get('trailer')||'').trim();
    const sex     = (params.get('sex')||'').trim();
    const slotNum = (params.get('slot')||'').trim();
    const trailerNorm = trailer.toLowerCase();
    const sexNorm     = sex.toLowerCase();
    const trailerPrefix = trailerNorm.charAt(0).toUpperCase();
    const sexPrefix     = sexNorm.charAt(0).toUpperCase();
    const slotId        = `${trailerPrefix}_${sexPrefix}_${slotNum}`;
    const QR_MISSING = (!trailer || !sex || !slotNum);

    /* ---------------- Trainer picker ---------------- */
    const overlayPick = document.getElementById('trainerOverlay');
    const changeUserLink = document.getElementById('changeUserLink');
    changeUserLink.addEventListener('click', (e) => {
  e.preventDefault();
  showCtxStep('trainer');   // start at trainer step
});

    function showTrainerPrompt(){
      overlayPick.classList.add('open');
      overlayPick.querySelectorAll('button[data-trainer]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          overlayPick.classList.remove('open');
          setTrainer(btn.dataset.trainer);
        }, {once:true});
      });
    }
    let trainerId = (new URL(location.href)).searchParams.get('trainer') || '';
    function setTrainer(name){
      trainerId = name;
      const url = new URL(location.href);
      url.searchParams.set('trainer', trainerId);
      history.replaceState(null, '', url.toString());
      ctxEl.textContent = `Trainer: ${trainerId}`;
      boot();
    }
    if (trainerId) ctxEl.textContent = `Trainer: ${trainerId}`;

    /* ---- Start-slot fallback ---- */
    const startOverlayEl   = document.getElementById('startFallbackOverlay');
    const startTrainerName = document.getElementById('startTrainerName');
    const startMaleBtn     = document.getElementById('startMaleBtn');
    const startFemaleBtn   = document.getElementById('startFemaleBtn');
    const startCancelBtn   = document.getElementById('startCancelBtn');
    let offeredStart = false;

    function openStartFallback(){
      if (!trainerId){ showTrainerPrompt(); return; }
      startTrainerName.textContent = trainerId;
      startOverlayEl.classList.add('open');
      startOverlayEl.setAttribute('aria-hidden','false');
    }
    function closeStartFallback(){
      startOverlayEl.classList.remove('open');
      startOverlayEl.setAttribute('aria-hidden','true');
    }
    function offerStartOnce(){
      if (offeredStart) return;
      offeredStart = true;
      openStartFallback();
    }

    startMaleBtn?.addEventListener('click', ()=>{
      const url = new URL(location.href);
      url.searchParams.set('trainer', trainerId);
      url.searchParams.set('trailer', slug(trainerId));
      url.searchParams.set('sex', 'male');
      url.searchParams.set('slot', 'R2C1');
      location.href = url.toString();
    });
    startFemaleBtn?.addEventListener('click', ()=>{
      const url = new URL(location.href);
      url.searchParams.set('trainer', trainerId);
      url.searchParams.set('trailer', slug(trainerId));
      url.searchParams.set('sex', 'female');
      url.searchParams.set('slot', 'R2C1');
      location.href = url.toString();
    });
    startCancelBtn?.addEventListener('click', closeStartFallback);
    startOverlayEl?.addEventListener('click', (e)=>{ if (e.target===startOverlayEl) closeStartFallback(); });
    /* ---- /Start-slot fallback ---- */

    /* ---------------- Day + setups tabs ---------------- */
    const dayPicker = document.getElementById('dayPicker');
    const todayBtn  = document.getElementById('todayBtn');
    dayPicker.value = ymd(new Date());
    todayBtn.addEventListener('click', ()=>{ dayPicker.value = ymd(new Date()); switchDay(dayPicker.value); });
    dayPicker.addEventListener('change', ()=>switchDay(dayPicker.value));
    const tabsEl = document.getElementById('tabs');
    let currentDateKey = dayPicker.value;
    let setupsMeta = [];
    let activeSetupId = null;

    /* ---------------- Dog / setup / scores state ---------------- */
    let dog = { id:null, name:null, profile:null, photo:null };
    let setupItemsMarks = [];
    let setupItemsBlinds = [];
    let scores = { marks:{}, blinds:{} };

    let unsubSetups = null;
    let unsubSetupDoc = null;
    let unsubScoreDoc = null;

    let saveTimer = null;
    function scheduleSave(){ clearTimeout(saveTimer); saveTimer = setTimeout(saveNow, SAVE_DEBOUNCE_MS); }

    /* ---------------- Firestore paths ---------------- */
    const dayDocPath   = () => doc(db, "setups", trainerId, "days", currentDateKey);
    const setupsColl   = () => collection(dayDocPath(), "setups");
    const setupDocRef  = () => (activeSetupId ? doc(setupsColl(), activeSetupId) : null);

    // Kennel slot â†’ dog lookup
    const slotRef = !QR_MISSING ? doc(db, "trailerLayouts", `${trailerNorm}-${sexNorm}`, "slots", slotId) : null;

    // Dog-centric runs
    const ratingsDayDoc = () => doc(db, "ratings", dog.id, "days", currentDateKey);
    const dogRunDoc     = () => doc(db, "ratings", dog.id, "days", currentDateKey, "setups", activeSetupId, "runs", "base");
    const mirrorRunDoc  = () => doc(db, "setups", trainerId, "days", currentDateKey, "setups", activeSetupId, "scores", dog.id, "runs", "base");

    /* ---------------- Dog hero rendering ---------------- */
    const dogCard = document.getElementById('dogCard');
    function renderDogCard(){
      dogCard.innerHTML = `
        <div class="hero">
          <img src="${dog.photo||''}" alt="">
          <div>
            <h2 style="margin:0 0 4px">${dog.name || 'Unassigned'}</h2>
            <div class="muted">Trailer: ${trailer||'â€”'} Â· Sex: ${sex||'â€”'} Â· Slot: ${slotNum||'â€”'}</div>
          </div>
        </div>
      `;
    }

    /* ---------------- Setup tabs ---------------- */
    function renderTabs(){
      tabsEl.innerHTML = '';
      setupsMeta.sort((a,b)=>(a.order??0)-(b.order??0)).forEach((m, idx)=>{
        const b = document.createElement('button');
        b.className = 'tab' + (m.id===activeSetupId ? ' active' : '');
        b.textContent = m.name || `Setup ${idx+1}`;
        b.addEventListener('click', ()=>setActiveSetup(m.id));
        tabsEl.appendChild(b);
      });
    }

    async function attachSetupsListener(){
      if (!trainerId) return;
      if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups = null; }
      const qy = query(setupsColl(), orderBy('order'));
      unsubSetups = onSnapshot(qy, async (snap)=>{
        const arr = [];
        snap.forEach(d=>{
          const data = d.data()||{};
          arr.push({ id:d.id, name:data.name||'Setup', order: typeof data.order==='number'?data.order:9999 });
        });
        setupsMeta = arr;
        if (!activeSetupId && setupsMeta.length) activeSetupId = setupsMeta[0].id;
        renderTabs();
        attachSetupDocListener();
        attachScoresListener();
      });
    }

    function attachSetupDocListener(){
      if (!activeSetupId) return;
      if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc = null; }
      const ref = setupDocRef();
      unsubSetupDoc = onSnapshot(ref, (snap)=>{
        const data = snap.data()||{};
        setupItemsMarks  = Array.isArray(data.items)  ? data.items.map(it=>({ id: it.id, dist: typeof it.dist==='number' ? it.dist : 0 })) : [];
        setupItemsBlinds = Array.isArray(data.blinds) ? data.blinds.map(it=>({ id: it.id, dist: typeof it.dist==='number' ? it.dist : 0 })) : [];
        renderScoresUIFromCurrentItems();
      });
    }

    function attachScoresListener(){
      if (!dog.id || !activeSetupId) return;
      if (unsubScoreDoc) { try{unsubScoreDoc();}catch{} unsubScoreDoc = null; }
      unsubScoreDoc = onSnapshot(dogRunDoc(), (snap)=>{
        const data = snap.data() || {};
        const s = data.scores || {};
        if ('marks' in s || 'blinds' in s) scores = { marks: s.marks || {}, blinds: s.blinds || {} };
        else scores = { marks: s || {}, blinds:{} }; // legacy
        renderScoresUIFromCurrentItems();
      });
    }

    async function setActiveSetup(id){
      activeSetupId = id;
      renderTabs();
      attachSetupDocListener();
      attachScoresListener();
      const snap = await getDoc(dogRunDoc());
      const data = snap.exists() ? snap.data() : null;
      if (data && data.scores) {
        const s = data.scores;
        scores = ('marks' in s || 'blinds' in s) ? { marks: s.marks||{}, blinds:s.blinds||{} } : { marks:s||{}, blinds:{} };
      } else {
        scores = { marks:{}, blinds:{} };
      }
      renderScoresUIFromCurrentItems();
    }

    async function switchDay(key){
      currentDateKey = key;
      if (unsubSetups)    { try{unsubSetups();}catch{}    unsubSetups=null; }
      if (unsubSetupDoc)  { try{unsubSetupDoc();}catch{}  unsubSetupDoc=null; }
      if (unsubScoreDoc)  { try{unsubScoreDoc();}catch{}  unsubScoreDoc=null; }
      setupsMeta = [];
      activeSetupId = null;
      setupItemsMarks = [];
      setupItemsBlinds = [];
      scores = { marks:{}, blinds:{} };
      renderTabs();
      renderScoresUI([]);
      if (trainerId) attachSetupsListener();
    }

    /* ---------------- Dog & boot ---------------- */
    async function attachDogListener(){
      if (QR_MISSING) {
        document.getElementById('dogCard').textContent = "No QR context detected â€” choose a starting slot.";
      }

      onSnapshot(slotRef, async (snap)=>{
        let profileData = null;
        dog = { id:null, name:null, profile:null, photo:null };
        if (snap.exists()) {
          const data = snap.data();
          dog.name = data.dogName || null;
          if (dog.name) {
            dog.id = slug(dog.name);
            const pSnap = await getDoc( doc(db, "profiles", dog.id) );
            if (pSnap.exists()) {
              profileData = pSnap.data();
              dog.profile = profileData;
              dog.photo = profileData.photo || null;
            }
          }
        }
        renderDogCard();
        attachScoresListener();
      });
    }

    /* ---------------- Scores UI ---------------- */
    const scoresTitle = document.getElementById('scoresTitle');
    const paneTabs = document.getElementById('paneTabs');
    let activePane = 'marks';
    paneTabs.addEventListener('click', (e)=>{
      const btn = e.target.closest('.mini-tab'); if (!btn) return;
      const pane = btn.dataset.pane;
      if (pane && pane !== activePane) {
        activePane = pane;
        paneTabs.querySelectorAll('.mini-tab').forEach(b => b.classList.toggle('active', b.dataset.pane===activePane));
        renderScoresUIFromCurrentItems();
      }
    });

    const scoreList = document.getElementById('scoreList');

    function markLabel(item, idx){ return `#${idx+1} - ${Number(item.dist||0)} yards`; }
    function blindLabel(item, idx){ return `#${idx+1} - ${Number(item.dist||0)} yards`; }

    function renderScoresUI(items){
      scoreList.innerHTML = '';
      const paneName = activePane==='marks' ? 'Marks' : 'Blinds';
      const setupName = (setupsMeta.find(s=>s.id===activeSetupId)?.name)||'Setup';
      scoresTitle.textContent = `${paneName} (${setupName})`;

      const defs = activePane==='marks' ? FLAG_DEFS_MARKS : FLAG_DEFS_BLINDS;
      const bucket = activePane==='marks' ? (scores.marks ||= {}) : (scores.blinds ||= {});

      items.forEach((item, idx)=>{
        const card = document.createElement('div');
        card.className = 'score-card';

        const head = document.createElement('div');
        head.className = 'score-header';

        const title = document.createElement('div');
        title.className = 'score-title';
        title.textContent = activePane==='marks' ? markLabel(item, idx) : blindLabel(item, idx);

        const flagBtn = document.createElement('button');
        flagBtn.className = 'btn flag-btn';
        flagBtn.textContent = 'ðŸš©';
        flagBtn.setAttribute('aria-label','Flags');
        flagBtn.title = 'Flags';
        flagBtn.addEventListener('click', ()=> openRadialFor(item.id, defs));
        head.append(title, flagBtn);

        const sliderRow = document.createElement('div');
        sliderRow.className = 'slider-row';

        const sliderId = `score-${activePane}-${item.id}`;

        const labelEl = document.createElement('label');
        labelEl.className = 'slider-label';
        labelEl.htmlFor = sliderId;
        labelEl.textContent = activePane==='marks' ? 'Mark Rating:' : 'Blind Rating:';

        const minusBtn = document.createElement('button');
        minusBtn.type = 'button'; minusBtn.className = 'nudge'; minusBtn.setAttribute('aria-label','Decrease by 0.5'); minusBtn.textContent = 'âˆ’';

        const slider = document.createElement('input');
        slider.id = sliderId; slider.type = 'range'; slider.min = '0'; slider.max = '10'; slider.step = '0.5';
        const cur = bucket[item.id]?.score ?? 0;
        slider.value = String(cur);

        const plusBtn = document.createElement('button');
        plusBtn.type = 'button'; plusBtn.className = 'nudge'; plusBtn.setAttribute('aria-label','Increase by 0.5'); plusBtn.textContent = '+';

        const out = document.createElement('div');
        out.className = 'slider-val'; out.textContent = Number(cur).toFixed(1);

        function apply(val){
          const snapped = Math.max(0, Math.min(10, Math.round(val*2)/2));
          slider.value = String(snapped);
          out.textContent = snapped.toFixed(1);
          (bucket[item.id] ||= { score:0, flags:{} }).score = snapped;
          scheduleSave();
        }

        slider.addEventListener('input', ()=> apply(parseFloat(slider.value)));
        minusBtn.addEventListener('click', ()=> apply(parseFloat(slider.value) - 0.5));
        plusBtn.addEventListener('click',  ()=> apply(parseFloat(slider.value) + 0.5));

        sliderRow.append(labelEl, minusBtn, slider, plusBtn, out);
        card.append(head, sliderRow);
        scoreList.appendChild(card);
      });
    }
    function renderScoresUIFromCurrentItems(){
      const items = activePane==='marks' ? setupItemsMarks : setupItemsBlinds;
      renderScoresUI(items);
    }

    /* ---------------- Save ---------------- */
    const saveStatus = document.getElementById('saveStatus');
    document.getElementById('saveOnlyBtn').addEventListener('click', async ()=>{
      const b = document.getElementById('saveOnlyBtn'); b.disabled = true;
      try { await saveNow(); } finally { b.disabled = false; }
    });
    document.getElementById('saveCameraBtn').addEventListener('click', async ()=>{
      await saveNow();
      location.href = "https://morrowind4732.github.io/task-tracker/Camera.html";
    });

    async function saveNow(){
      if (!dog.id || !activeSetupId) return;
      saveStatus.textContent = 'Savingâ€¦';
      const setupName = (setupsMeta.find(s=>s.id===activeSetupId)?.name) || null;
      const payload = {
        scores,
        trainer: trainerId, setupId: activeSetupId, setupName,
        dogId: dog.id, dogName: dog.name || null,
        runId: 'base',
        dateKey: currentDateKey,
        trailer: trailer, sex: sex, slotId,
        updatedAt: serverTimestamp()
      };
      try {
        await Promise.all([
          setDoc(dogRunDoc(), payload, { merge:true }),
          setDoc(mirrorRunDoc(), payload, { merge:true }),
          setDoc(ratingsDayDoc(), { date: currentDateKey, trailer, sex, slotId, lastScoredAt: serverTimestamp(), trainer: trainerId }, { merge:true })
        ]);
        saveStatus.textContent = 'Saved.';
        setTimeout(()=>saveStatus.textContent='', 900);
      } catch (e) {
        console.error(e);
        saveStatus.textContent = 'Save failed.';
      }
    }

    /* ---------------- Radial menu (CROSS layout, ALWAYS VISIBLE) ---------------- */
    const radial = document.getElementById('radialOverlay');
    const wheelEl = document.getElementById('wheel');
    const wheelTitle = document.getElementById('wheelTitle');
    const centerCancel = document.getElementById('centerCancel');

    let currentRadial = { id:null, paneKey:null };

    function openRadialFor(itemId, defs){
      currentRadial = { id:itemId, paneKey: activePane };
      wheelTitle.textContent = `${activePane==='marks'?'Marks':'Blinds'} â€” Flags`;

      // clear old buttons
      [...wheelEl.querySelectorAll('.rad-btn')].forEach(n => n.remove());

      // Only render keys that exist in this pane's defs
      const allowed = new Set(defs.map(d=>d.key));
      const labelFor = (k) => (defs.find(d=>d.key===k)?.label) || k;
      const fromKeys = (keys) => keys.filter(k=>allowed.has(k)).map(k => ({ key:k, label: labelFor(k) }));

      const top    = fromKeys(FLAG_LAYOUT.up).map(makeBtn);
      const bottom = fromKeys(FLAG_LAYOUT.down).map(makeBtn);
      const left   = fromKeys(FLAG_LAYOUT.left).map(makeBtn);
      const right  = fromKeys(FLAG_LAYOUT.right).map(makeBtn);

      requestAnimationFrame(()=>{
        top.forEach((b,i)=> placeButton(b, 'top', i));
        bottom.forEach((b,i)=> placeButton(b, 'bottom', i));
        left.forEach((b,i)=> placeButton(b, 'left', i));
        right.forEach((b,i)=> placeButton(b, 'right', i));
      });

      radial.classList.add('open');
      radial.setAttribute('aria-hidden','false');

      function makeBtn(fd){
        const b = document.createElement('button');
        b.className = 'rad-btn';
        b.textContent = fd.label;

        const paneKey = currentRadial.paneKey;
        const liveBucket = (scores[paneKey] ||= {});
        const entry = (liveBucket[itemId] ||= { score:0, flags:{} });
        if (entry.flags?.[fd.key]) b.classList.add('active');

        b.addEventListener('click', ()=>{
          const lb = (scores[paneKey] ||= {});
          const e  = (lb[itemId] ||= { score: entry.score || 0, flags: entry.flags || {} });
          e.flags[fd.key] = !e.flags[fd.key];
          b.classList.toggle('active', !!e.flags[fd.key]);
          scheduleSave();
        });
        wheelEl.appendChild(b);
        return b;
      }
    }

    // Cross layout placement with multi-stacks on left/right (always visible)
    function placeButton(el, spot, index = 0) {
      const W = wheelEl.clientWidth, H = wheelEl.clientHeight;
      const cx = W / 2, cy = H / 2;

      const VSPACE = 8;
      const R_TOP = 86;
      const R_BOTTOM = 86;
      const R_SIDE = 100;

      const w = el.offsetWidth, h = el.offsetHeight;

      const offForIndex = (i) => { if (i===0) return 0; const k = Math.ceil(i/2); return (i%2===1 ? -k : k); };

      if (spot === 'left') {
        const dy = offForIndex(index) * (h + VSPACE);
        el.style.left = (cx - R_SIDE - w) + 'px';
        el.style.top  = (cy - h/2 + dy) + 'px';
      } else if (spot === 'right') {
        const dy = offForIndex(index) * (h + VSPACE);
        el.style.left = (cx + R_SIDE) + 'px';
        el.style.top  = (cy - h/2 + dy) + 'px';
      } else if (spot === 'top') {
        const baseY = cy - R_TOP - h/2;
        el.style.left = (cx - w/2) + 'px';
        el.style.top  = (baseY - index * (h + VSPACE)) + 'px';
      } else if (spot === 'bottom') {
        const baseY = cy + R_BOTTOM - h/2;
        el.style.left = (cx - w/2) + 'px';
        el.style.top  = (baseY + index * (h + VSPACE)) + 'px';
      }
    }

    centerCancel.addEventListener('click', closeRadial);
    radial.addEventListener('click', (e)=>{ if (e.target === radial) closeRadial(); });
    function closeRadial(){
      radial.classList.remove('open');
      radial.setAttribute('aria-hidden','true');
    }
	
	/* ========= Context Wizard (trainer/trailer/sex) ========= */
const ctxOverlay     = document.getElementById('ctxOverlay');
const ctxStepTitle   = document.getElementById('ctxStepTitle');
const ctxSteps = {
  trainer: document.getElementById('ctxStepTrainer'),
  trailer: document.getElementById('ctxStepTrailer'),
  sex:     document.getElementById('ctxStepSex'),
};

// Helper to build a URL with one param changed
function urlWith(k, v){
  const url = new URL(location.href);
  if (v == null || v === '') url.searchParams.delete(k);
  else url.searchParams.set(k, v);
  return url;
}

function showCtxStep(name){
  Object.values(ctxSteps).forEach(el => el.style.display = 'none');
  ctxSteps[name].style.display = 'block';
  ctxStepTitle.textContent =
    name === 'trainer' ? 'Who are you?' :
    name === 'trailer' ? 'Pick the trailer' :
    'Which side of trailer?';
  ctxOverlay.classList.add('open');
  ctxOverlay.setAttribute('aria-hidden','false');
}

function closeCtxOverlay(){
  ctxOverlay.classList.remove('open');
  ctxOverlay.setAttribute('aria-hidden','true');
}

/** Open starting at the first missing piece (ignoring slot) */
function openCtxOverlay(){
  const missing = !trainerId ? 'trainer' : (!trailer ? 'trailer' : (!sex ? 'sex' : null));
  if (!missing) return;
  showCtxStep(missing);
}

ctxOverlay.addEventListener('click', (e)=>{ if (e.target === ctxOverlay) closeCtxOverlay(); });

// Step handlers
document.querySelectorAll('[data-ctx-trainer]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const v = btn.dataset.ctxTrainer;              // Scott/Cody/Brian
    trainerId = v;
    history.replaceState(null, '', urlWith('trainer', v).toString());
    ctxEl.textContent = `Trainer: ${trainerId}`;
    if (!trailer) showCtxStep('trailer');
    else if (!sex) showCtxStep('sex');
    else closeCtxOverlay();
  });
});

document.querySelectorAll('[data-ctx-trailer]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const v = btn.dataset.ctxTrailer;              // scott/cody/brian (slug)
    history.replaceState(null, '', urlWith('trailer', v).toString());
    if (!sex) showCtxStep('sex'); else closeCtxOverlay();
  });
});

document.querySelectorAll('[data-ctx-sex]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const v = btn.dataset.ctxSex;                  // male/female
    const url = urlWith('sex', v);
    // Finalize: reload so all consts (like slotId, QR_MISSING) recompute cleanly.
    location.href = url.toString();
  });
});
/* ========= /Context Wizard ========= */


    /* ========= RADIAL KENNEL NAVIGATOR (unchanged) ========= */
    /** Parse "R2C3" or "R2C3H" -> { r:2, c:3, half:true? } */
    function parseRC(rc) { const m=/^R(\d+)C(\d+)(H)?$/i.exec(rc||''); return m?{r:+m[1],c:+m[2],half:!!m[3]}:{r:NaN,c:NaN,half:false}; }
    function fmtRC(r,c,half=false){ return `R${r}C${c}${half?'H':''}`; }
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

    async function fetchSlotsMap(sexN) {
      const key = `${trailerNorm}-${sexN}`;
      const snaps = await getDocs(collection(db, "trailerLayouts", key, "slots"));
      const map = {};
      snaps.forEach(d => { const rc = d.id.split("_").slice(2).join("_"); map[rc] = (d.data() || {}).dogName || ""; });
      return map;
    }

    function boundsFromMap(map){
      let maxR = 1, maxC = 1;
      Object.keys(map||{}).forEach(k=>{
        const m = /^R(\d+)C(\d+)/i.exec(k);
        if (m){ maxR = Math.max(maxR, +m[1]); maxC = Math.max(maxC, +m[2]); }
      });
      return { maxR, maxC };
    }

    const overlayEl = document.getElementById('kennelOverlay');
    const kWheelEl = document.querySelector('#kennelOverlay .k-wheel');
    const fabEl     = document.getElementById('kennelFab');
    const kCurNameEl= document.getElementById('kCurName');
    const kCurSlotEl= document.getElementById('kCurSlot');

    let slotsMale=null, slotsFemale=null;
    let maleBounds={maxR:2,maxC:8}, femaleBounds={maxR:2,maxC:8};
    let longPressTimer=null;

    async function ensureLayouts() {
      if (!slotsMale)   { slotsMale   = await fetchSlotsMap('male');   maleBounds   = boundsFromMap(slotsMale); }
      if (!slotsFemale) { slotsFemale = await fetchSlotsMap('female'); femaleBounds = boundsFromMap(slotsFemale); }
    }

    function lookupName(rc, sexN){
      if (!rc) return { name: 'â€” Empty â€”', rcUsed: '' };
      const map = (sexN==='male') ? slotsMale : slotsFemale;
      const first = map?.[rc] || "";
      if (first) return { name:first, rcUsed:rc };
      const rcH = rc.endsWith('H') ? rc : (rc + 'H');
      const second = map?.[rcH] || "";
      return { name: (second || 'â€” Empty â€”'), rcUsed: (second ? rcH : rc) };
    }

    function mirrorRC(rc, toSex){
      const { r, c } = parseRC(rc);
      const b = (toSex==='female') ? femaleBounds : maleBounds;
      const mc = b.maxC || 1;
      const mirroredC = clamp(mc - c + 1, 1, mc);
      return fmtRC(clamp(r,1,b.maxR||1), mirroredC);
    }

    const LOOKAHEAD_STEPS = 3;

    function isOccupiedInfo(rc, sexN){
      const info = lookupName(rc, sexN);
      return (info.name && info.name !== 'â€” Empty â€”') ? info : null;
    }

    function findNextOccupied(rc, sexN, dir, maxSteps){
      const { r, c } = parseRC(rc);
      const b = (sexN==='male') ? maleBounds : femaleBounds;
      let stepR = 0, stepC = 0;
      if (dir==='left')  stepC = -1;
      if (dir==='right') stepC =  1;
      if (dir==='up')    stepR = -1;
      if (dir==='down')  stepR =  1;

      for (let k = 1; k <= maxSteps; k++){
        const r2 = r + stepR*k, c2 = c + stepC*k;
        if (r2 < 1 || r2 > b.maxR || c2 < 1 || c2 > b.maxC) break;
        const info = isOccupiedInfo(fmtRC(r2, c2), sexN);
        if (info) return { rcUsed: info.rcUsed, dogName: info.name, sex: sexN, label: dir[0].toUpperCase()+dir.slice(1) };
      }
      return null;
    }

    function neighbors(rc, sexN) {
      const { r } = parseRC(rc);
      const sameBounds = (sexN==='male') ? maleBounds : femaleBounds;
      const opp = (sexN==='male') ? 'female' : 'male';

      const leftOpt  = findNextOccupied(rc, sexN, 'left',  LOOKAHEAD_STEPS);
      const rightOpt = findNextOccupied(rc, sexN, 'right', LOOKAHEAD_STEPS);
      const upOpt = (r > 1) ? findNextOccupied(rc, sexN, 'up', 1) : null;

      let bottom;
      if (r < sameBounds.maxR) {
        const downOpt = findNextOccupied(rc, sexN, 'down', 1);
        if (downOpt) bottom = { key:'down', ...downOpt };
        else         bottom = { key:'swap', label:(opp==='female'?'Female':'Male'), rc: mirrorRC(rc, opp), sex: opp };
      } else {
        bottom = { key:'swap', label:(opp==='female'?'Female':'Male'), rc: mirrorRC(rc, opp), sex: opp };
      }

      const out = [];
      if (leftOpt)  out.push({ key:'left',  ...leftOpt  });
      if (rightOpt) out.push({ key:'right', ...rightOpt });
      if (upOpt)    out.push({ key:'up',    ...upOpt    });
      out.push(bottom);
      return out;
    }

    async function openWheel() {
      await ensureLayouts();

      const rc = slotNum;
      const sexN = sexNorm;
      const curr = lookupName(rc, sexN);
      const curName = (dog && dog.name) ? dog.name : curr.name;

      kCurNameEl.textContent = curName || 'Unassigned';
      kCurSlotEl.textContent = curr.rcUsed;

      kWheelEl.querySelectorAll('.k-item').forEach(n => n.remove());

      const options = {};
      neighbors(rc, sexN).forEach(n => {
        const baseRc = n.rcUsed ?? n.rc;
        const info = (n.dogName && baseRc)
          ? { name: n.dogName, rcUsed: baseRc }
          : lookupName(baseRc, n.sex);

        if (info.rcUsed === curr.rcUsed && n.sex === sexN) return;
        options[n.key] = { ...n, rcUsed: info.rcUsed, dogName: info.name, label: n.label };
      });

      function placeButton(dx, dy, opt, fallbackLabel) {
        if (!opt) return;
        const title = opt.label || fallbackLabel;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'k-item';
        btn.style.left = '50%';
        btn.style.top  = '50%';
        btn.style.transform = `translate(-50%,-50%) translate(${dx}px, ${dy}px)`;
        btn.innerHTML = `<b>${opt.dogName || 'â€”'}</b><small>${title} Â· ${opt.sex==='female'?'â™€':'â™‚'} Â· ${opt.rcUsed}</small>`;
        btn.addEventListener('click', () => {
          const url = new URL(location.href);
          url.searchParams.set('sex', opt.sex);
          url.searchParams.set('slot', opt.rcUsed);
          location.href = url.toString();
        });
        kWheelEl.appendChild(btn);
      }

      const R = 100;
      placeButton(-R, 0, options.left,  'Left');
      placeButton( R, 0, options.right, 'Right');
      placeButton( 0,-R, options.up,    'Up');
      placeButton( 0, R, options.down || options.swap, (options.down?.label) || (options.swap?.label) || 'Down');

      overlayEl.classList.add('open');
      overlayEl.setAttribute('aria-hidden', 'false');
    }

    function closeWheel(){
      overlayEl.classList.remove('open');
      overlayEl.setAttribute('aria-hidden', 'true');
    }

    document.getElementById('kennelFab').addEventListener('click', openWheel);
    overlayEl.addEventListener('click', (e)=> { if (e.target === overlayEl) closeWheel(); });
    dogCard.addEventListener('pointerdown', () => { longPressTimer = setTimeout(openWheel, 450); });
    ['pointerup','pointerleave','pointercancel','dragstart'].forEach(ev=>{
      dogCard.addEventListener(ev, ()=>{ clearTimeout(longPressTimer); });
    });
    /* ========= /RADIAL ========= */

    /* ---------------- Boot ---------------- */
    async function boot(){
      if (!trainerId) return showTrainerPrompt();
      ctxEl.textContent = `Trainer: ${trainerId}`;
      if (QR_MISSING) { offerStartOnce(); return; }
      await switchDay(ymd(new Date()));
      attachDogListener();
    }

    if (trainerId && trailer && sex) {
  boot();
} else {
  openCtxOverlay();
}

  </script>
</body>
</html>
