<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voice Flag Tester</title>
<style>
  :root{
    --accent:#0b74ff; --bg:#f6f7fb; --card:#fff; --muted:#667085; --bo<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voice Flag Tester</title>
<style>
  :root{
    --accent:#0b74ff; --bg:#f6f7fb; --card:#fff; --muted:#667085; --border:#e4e7ec;
    --danger:#ef4444; --ok:#16a34a;
  }
  * { box-sizing: border-box; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:#101828;}
  header{padding:20px 24px 8px;}
  h1{margin:0 0 6px;font-size:28px;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:14px}
  .wrap{padding:0 24px 24px;max-width:1100px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 1px 2px rgba(16,24,40,.04)}
  .items{display:flex;flex-direction:column;gap:14px}
  .row{display:grid;grid-template-columns:minmax(160px,260px) 1fr auto;gap:14px;align-items:center;padding:12px;border:1px solid var(--border);border-radius:14px;background:#fafafa}
  .kind{font-size:12px;font-weight:800;color:#344054}
  .title{font-size:16px;font-weight:800}
  /* FLAGS AREA → responsive columns */
  .chips{
    display:grid; gap:8px;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    align-items:start;
  }
  .chip{border:1px solid #d0d5dd;background:#fff;border-radius:999px;padding:6px 10px;font-size:13px;user-select:none;display:block}
  .chip.on{background:#eef4ff;border-color:#c7d7fe}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  
  .row.listening .mic{border-color:#ffb4b4;box-shadow:0 0 0 4px rgba(255,59,48,.12)}
  .row.listening .mic .dot{background:#ff3b30;animation:pulse 1s infinite alternate}
  @keyframes pulse{from{transform:scale(.9)}to{transform:scale(1.2)}}
  input[type=range]{width:220px}
  .score{font-weight:800;min-width:44px;text-align:right;font-variant-numeric:tabular-nums}
  .bar{display:flex;gap:10px;align-items:center;padding:0 24px 12px;flex-wrap:wrap}
  .status{color:var(--muted);font-weight:700}
  .btn{appearance:none;border:1px solid var(--border);background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  .btn.ghost{background:#fff}
  .btn.small{padding:6px 8px;border-radius:8px;font-size:12px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:12px}
  .pill.ok{border-color:#c7f1d9;background:#ecfdf5;color:#065f46}
  .pill.bad{border-color:#ffd5d5;background:#fff1f1;color:#7f1d1d}
/* Hide the old grid; voice still toggles in the background */
.chips{ display:none; }

/* Red circle “flag” button — bigger default + explicit BIG variant */
.flagBtn{
  width:64px; height:64px; border-radius:999px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#FFFFFF; border:none; cursor:pointer;
  box-shadow:0 14px 28px rgba(239,68,68,.35);
  touch-action:none; /* enables swipe tracking on mobile */
  font-size:26px; font-weight:900;
}
.flagBtn.big{
  width:76px; height:76px;
  font-size:32px;
  box-shadow:0 18px 38px rgba(239,68,68,.35);
}
.flagBtn:active{ transform:translateY(1px); }


/* Peek overlay: big, easy-to-read list */

.peek-head{font-weight:800; font-size:14px; color:#475467; margin-bottom:8px}
.peek-list{display:flex; flex-direction:column; gap:12px; margin:10px 0 6px}
.peek-flag{font-size:22px; font-weight:800; padding:8px 12px; border-radius:12px;
  background:#f8fafc; border:1px solid #e5e7eb}

/* Pull-to-clear zone at bottom of the card */
.pull-zone{position:relative; height:64px; border-radius:12px; overflow:hidden;
  background:#fafafa; border:1px dashed #e5e7eb; margin-top:8px}
.pull-bar{position:absolute; left:0; top:0; width:100%; height:0;
  background:rgba(239,68,68,.25); transition:height .1s linear}
.pull-zone.ready .pull-bar{ background:rgba(239,68,68,.45); }
.pull-zone.cleared{ background:#fee2e2; border-color:#fecaca; }
.pull-label{position:relative; z-index:1; line-height:64px; font-weight:800; color:#7f1d1d}


  /* Overlay (missed phrases) */
  
  .overlay.open{display:flex;}
  
  .sheet-head{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--border)}
  .sheet-body{padding:12px 16px;display:flex;flex-direction:column;gap:10px}
  .missed-item{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:12px}
  .missed-meta{display:flex;flex-direction:column;gap:4px}
  .missed-phrase{font-weight:800}
  .missed-row{color:#475467;font-size:12px}
  .missed-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sheet-foot{padding:12px 16px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end}
  .hint{color:#475467;font-size:12px}

  /* Overlay (master log) */
  .log-list{display:flex;flex-direction:column;gap:8px}
  .log-item{display:flex;justify-content:space-between;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:10px}
  .count{font-variant-numeric:tabular-nums;font-weight:800}
  
  /* Kill native long-press callout + text selection where we hold */
.flagBtn,
#peekOverlay,
#peekOverlay *,
.mic,
.row {
  -webkit-touch-callout: none; /* iOS copy/paste bubble */
  -webkit-user-select: none;
  user-select: none;
}

.flagBtn,
.peek { touch-action: none; } /* prevent native gestures during hold */

/* --- Large, swipeable stage showing 1 Mark + 1 Blind --- */
.items { display:none; }            /* hide old list view on this test page */
.stage {
  display: grid;
  gap: 14px;
}
.pane {
  background:#fff;
  border:1px solid var(--border);
  border-radius:16px;
  box-shadow:0 1px 2px rgba(16,24,40,.04);
  padding:16px;
  min-height: 36vh;                 /* nice big touch target area */
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  touch-action: pan-y;              /* allow vertical scrolling; we handle horizontal */
}
/* Bigger Mark/Blind label */
.pane-head .kind { font-size:22px; font-weight:900; color:#475467; }
/* tiny spacing tweak so the bigger label breathes */
.pane-head .title{ font-size:24px; font-weight:900; margin-top:4px; }


.pane-controls{ display:flex; align-items:center; gap:12px; flex-wrap:wrap }

.score.big { font-size:24px; font-weight:900; min-width:56px; text-align:right; }

.navBtn{
  appearance:none; border:1px solid var(--border); background:#fff;
  width:46px; height:46px; border-radius:12px; cursor:pointer; font-size:20px; font-weight:800;
}
.navBtn:active{ transform:translateY(1px); }

.pager{ margin-left:auto; display:flex; gap:6px; align-items:center }
.dot{ width:8px; height:8px; border-radius:50%; background:#d0d5dd }
.dot.on{ background:#0b74ff }

/* Stretch the range to breathe on mobile */
.pane input[type=range]{
  flex:1 1 240px; min-width:180px;
}
/* --- Swipe slide animation --- */
.stage { position: relative; }                /* anchor absolute panes */
.pane-slot{
  position: relative;                         /* local stacking for each slot */
  min-height: 36vh;                           /* match pane's min-height */
}
.pane{
  position: absolute; inset: 0;
  transition: transform .28s ease, opacity .28s ease;
  transform: translateX(0); opacity: 1;
  will-change: transform, opacity;
}

.pane.enter-from-right { transform: translateX(100%); opacity: 0; }
.pane.enter-from-left  { transform: translateX(-100%); opacity: 0; }
.pane.exit-to-left     { transform: translateX(-100%); opacity: 0; }
.pane.exit-to-right    { transform: translateX(100%);  opacity: 0; }


/* allow vertical scroll; we'll handle horizontal swipes */
.mic { touch-action: pan-y; }


.mic{
  display:inline-flex;align-items:center;gap:10px;
  padding:12px 14px;border-radius:999px;background:#fff;border:1px solid #d0d5dd;
  cursor:pointer;font-weight:800;font-size:16px;min-height:44px
  
}
.mic .dot{width:12px;height:12px;border-radius:50%;background:#94a3b8}
.mic.big{ font-size:22px; padding:16px 18px; min-height:56px }
.mic.big .dot{ width:16px; height:16px }

#peekOverlay { touch-action: none; }

/* Overlay container */
.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center;
  z-index:9999;

  /* keep content inside the viewport even with outer padding */
  padding:16px;
  /* notch-safe padding on iOS */
  padding-left: max(16px, env(safe-area-inset-left));
  padding-right:max(16px, env(safe-area-inset-right));
  padding-top:  max(16px, env(safe-area-inset-top));
  padding-bottom:max(16px, env(safe-area-inset-bottom));
}

/* Flags peek card */
.peek{
  /* width that *always* fits inside overlay padding */
  width: min(420px, calc(100dvw - 32px));
  /* prevent vertical overflow off-screen */
  max-height: calc(100dvh - 32px);
  overflow:auto;

  background:#fff; border:1px solid var(--border);
  border-radius:16px; padding:16px; text-align:center;
  box-shadow:0 20px 50px rgba(0,0,0,.25);
}

/* Missed/log sheet */
.sheet{
  width: min(720px, calc(100dvw - 32px));
  max-height: calc(100dvh - 32px);
  overflow:auto;

  background:#fff; border:1px solid var(--border);
  border-radius:16px; box-shadow:0 20px 50px rgba(0,0,0,.25);
}

/* Keep peek draggable; keep sheets scrollable */
#peekOverlay { touch-action: none; }
#missedOverlay, #logOverlay { touch-action: pan-y; }


html.overlay-open, body.overlay-open { overflow: hidden; }

/* Keep slide animations from ever expanding layout width */
.stage,
.pane-slot { overflow: hidden; }

/* Belt-and-suspenders: never allow horizontal page growth */
html, body { max-width: 100%; overflow-x: hidden; overscroll-behavior-x: none; }

/* Controls can wrap, but children must be allowed to shrink */
.pane-controls > * { min-width: 0; }

/* Pager shouldn't force the row wider than the screen */
.pager { min-width: 0; flex: 0 1 auto; overflow: hidden; }

/* ——— Home screen refresh (mobile-first, high-contrast) ——— */

/* Tweak base card padding and shadow for depth */
.wrap { padding: 12px 16px 24px; }
.card { border-radius: 18px; box-shadow: 0 10px 30px rgba(16,24,40,.08); }

/* Dog card: subtle gradient with large name */
#dogCard {
  background: linear-gradient(180deg, #ffffff 0%, #f6f8ff 100%);
  border: 1px solid #e7ecff;
  box-shadow: 0 8px 26px rgba(11,116,255,.10);
}
#dogCard .pane-head .kind { font-size: 18px; letter-spacing:.3px; color:#0b74ff; }
#dogCard .pane-head .title { font-size: 28px; font-weight:900; margin-top:6px; }

/* Stage panes — cleaner surface */
.pane {
  border: 1px solid #e7ecff;
  border-radius: 18px;
  background: #ffffff;
  box-shadow: 0 10px 30px rgba(16,24,40,.06);
  padding: 16px 14px 18px;
}

/* Pane header: bigger label + title */
.pane-head .kind   { font-size: 18px; font-weight:900; color:#0b74ff; }
.pane-head .title  { font-size: 22px; font-weight:900; color:#0f172a; margin-top:4px; }

/* Control row: space things nicely on small screens */
.pane-controls { gap: 12px; flex-wrap: wrap; align-items: center; }

/* Giant mic button (pill) */
.mic.big{
  border: 0;
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%);
  box-shadow: 0 10px 24px rgba(11,116,255,.20);
  padding: 14px 18px;
  border-radius: 999px;
  font-size: 20px;
}
.mic.big .dot{ width:14px; height:14px; background:#0b74ff; }

/* Giant red flag button */
.flagBtn.big{
  width: 84px; height: 84px; font-size: 34px;
  border: 0;
  box-shadow: 0 20px 44px rgba(239,68,68,.40);
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 65%, #ffecec 100%);
}

/* Score cluster (new): big ± buttons + badge */
.scoreWrap{
  display:flex; align-items:center; gap:10px;
  margin-left:auto; /* push toward the right by default */
}
.scoreBtn{
  width:58px; height:58px; border-radius:14px;
  border:1px solid #dbe3ff; background:#fff; font-size:28px; font-weight:900;
  box-shadow: 0 10px 22px rgba(16,24,40,.10);
}
.scoreBadge{
  min-width:94px; padding:6px 10px; text-align:center;
  border-radius:14px; border:1px solid #dbe3ff;
  background: #f5f8ff; font-size:36px; font-weight:900;
  font-variant-numeric: tabular-nums;
}

/* Keep the old slider + score around but invisible so existing code still works */
.pane input[type=range].visually-hidden { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
.pane .score { display:none; }

/* Pager dots: cleaner + slightly larger for visibility */
.pager { margin-left:0; gap:8px; }
.pager .dot{ width:10px; height:10px; background:#e2e8f0; }
.pager .dot.on{ background:#0b74ff; }

/* Anti-width-creep: never let swipes or long controls expand the page */
.stage, .pane-slot { overflow:hidden; }
html, body { max-width:100%; overflow-x:hidden; overscroll-behavior-x:none; }
.pane-controls > * { min-width:0; }
.pager { min-width:0; flex:0 1 auto; overflow:hidden; }





/* ——— Rhombus buttons with rounded corners ——— */
/* Works for the big red flag and big mic. No markup changes needed. */

.flagBtn.big,
.mic.big{
  position: relative;
  isolation: isolate;       /* keeps the shadow/overlay tidy */
  background: transparent;  /* the shape comes from ::before */
  border: 0;
}

/* Shared “diamond” skin */
.flagBtn.big::before,
.mic.big::before{
  content: "";
  position: absolute;
  left: 50%; top: 50%;
  width: 100%; height: 100%;
  transform: translate(-50%,-50%) rotate(45deg) scale(var(--rhombus-scale, .86));
  border-radius: 18px;        /* rounded rhombus corners */
  pointer-events: none;       /* clicks go to the button */
}

/* Size & typography (accessible) */
.flagBtn.big{
  width: 92px; height: 92px;             /* large touch target */
  font-size: 34px; font-weight: 900;
  --rhombus-scale: .86;
}
.mic.big{
  /* responsive long rhombus */
  width: min(88vw, 280px);
  height: 92px;
  padding: 0 10px;                        /* space for label */
  font-size: 22px; font-weight: 900; line-height: 1;
  display: inline-flex; align-items: center; justify-content: center;
  gap: 10px;
  color: #0b74ff;
  --rhombus-scale: .90;
}

/* Inner dot stays normal (not rotated) */
.mic.big .dot{ width:16px; height:16px; background:#0b74ff; }

/* Colorways + depth */
.flagBtn.big::before{
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%);
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset;
}
.mic.big::before{
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%);
  box-shadow: 0 18px 40px rgba(11,116,255,.25), 0 0 0 1px #e7ecff inset;
}

/* Press + focus states */
.flagBtn.big:active::before,
.mic.big:active::before{
  transform: translate(-50%,-50%) rotate(45deg) scale(calc(var(--rhombus-scale, .86) * .97));
}
.flagBtn.big:focus-visible::before,
.mic.big:focus-visible::before{
  box-shadow:
    0 0 0 4px rgba(11,116,255,.25),
    0 18px 40px rgba(11,116,255,.25),
    0 0 0 1px #e7ecff inset;
  outline: none;
}

/* Keep layout from “growing” during transforms */
.flagBtn.big, .mic.big { overflow: visible; }

/* --- Fix diamond overflow on big buttons --- */

/* Keep the ::before square the size of the button's height */
.flagBtn.big { --btn-h: 92px; width: var(--btn-h); height: var(--btn-h); } /* stays square */
.mic.big     { --btn-h: 92px; height: var(--btn-h); }                      /* already 92px tall */

.mic.big::before{
  /* was width:100%; height:100%; — that caused the diagonal blade */
  width: var(--btn-h);
  height: var(--btn-h);
}

/* Ensure the diamond sits behind the content, not above neighbors */
.flagBtn.big::before,
.mic.big::before{
  z-index: -1;              /* behind the emoji/text */
}

/* Safety: confine any remaining overflow to the button box */
.flagBtn.big, .mic.big {
  overflow: clip;
}
@supports not (overflow: clip){
  .flagBtn.big, .mic.big { overflow: hidden; } /* Safari fallback */
}


/* --- Clean up legacy shapes & set final button geometry --- */

/* 1) FLAG: keep the diamond, remove the old circular button behind it */
.flagBtn.big{
  background: transparent !important;   /* no white circle */
  border: 0 !important;
  border-radius: 0 !important;          /* removes circular silhouette */
  box-shadow: none !important;          /* shadow comes from ::before */
  width: 92px; height: 92px;            /* square hit area */
  position: relative; isolation: isolate;
  overflow: clip;
}
@supports not (overflow: clip){ .flagBtn.big{ overflow: hidden; } }

/* Ensure the diamond stays the only visual */
.flagBtn.big::before{
  content:"";
  position:absolute; inset:0;
  margin:auto;
  width: 92px; height: 92px;            /* square, then rotate */
  transform: rotate(45deg);
  border-radius: 18px;
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%);
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset;
  z-index:-1;
}

/* 2) MIC: straight rounded rectangle, no diamond */
.mic.big{
  /* override the old pill */
  border-radius: 18px !important;
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%) !important;
  border: 1px solid #dbe3ff !important;
  box-shadow: 0 10px 24px rgba(11,116,255,.18);
  color:#0b74ff; font-weight:900; font-size:20px;

  height: 92px;
  min-width: clamp(220px, 80vw, 340px); /* room for dot + “Listen” */
  padding: 0 18px;
  display:inline-flex; align-items:center; justify-content:center; gap:12px;

  background-clip: padding-box;
}
.mic.big::before{ content:none !important; }   /* kill the rhombus layer */
.mic.big .dot{ width:16px; height:16px; background:#0b74ff; border-radius:50%; }

/* Press/focus states */
.mic.big:active{ transform: translateY(1px); }
.mic.big:focus-visible{
  outline: none;
  box-shadow:
    0 0 0 4px rgba(11,116,255,.25),
    0 10px 24px rgba(11,116,255,.18);
}


/* 3) Optional: if you truly want the mic to be a 1:1 square,
   add class="mic big square" in the HTML. */
.mic.big.square{
  width: 92px; min-width: 92px; padding:0; gap:0;
  justify-content:center;
  text-indent: -9999px;                 /* hide "Listen" text visually */
}
.mic.big.square::after{
  content: "🎤";
  text-indent: 0; font-size: 32px; line-height: 1;
}
.mic.big.square .dot{ display:none; }

/* --- FIX: keep the flag rhombus from being cut off --- */
.flagBtn.big{
  /* Make the rotated square fit entirely inside the 92×92 button */
  --rhombus-scale: .70;                  /* ~1/√2 ≈ .707; .70 gives a little breathing room */
  background: transparent !important;    /* no legacy circle */
  border: 0 !important;
  box-shadow: none !important;           /* depth comes from ::before */
  overflow: visible;                      /* safe: shape now fits; shadow can breathe */
}

/* Ensure we use the centered + scaled transform (override any earlier/later rule) */
.flagBtn.big::before{
  width: 100% !important;
  height: 100% !important;
  left: 50% !important;
  top: 50% !important;
  transform: translate(-50%, -50%) rotate(45deg) scale(var(--rhombus-scale)) !important;
  border-radius: 18px !important;
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%) !important;
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset !important;
  z-index: -1;
}

/* Keep the mic as a plain rounded rectangle (no diamond layer) */
.mic.big::before{ content: none !important; }


/* Keep your diamond exactly as-is via ::before.
   Center the flag glyph visually via ::after. */
.flagBtn.big{
  display: inline-grid;              /* easy centering */
  place-items: center;
  font-size: 0;                      /* hide the raw emoji text node */
  --icon-x: 6px;                     /* tweak these if needed */
  --icon-y: -35px;
}

.flagBtn.big::after{
  content: "🚩";
  font-size: 36px;                   /* size of the glyph */
  line-height: 1;
  transform: translate(var(--icon-x), var(--icon-y));
  pointer-events: none;
  z-index: 0;                        /* above ::before (which is z:-1) */
}

  /* Header becomes a 2-column bar: titles on the left, flag on the right */
.pane-head{
  display:grid;
  grid-template-columns: 1fr auto;
  align-items:center;
  gap:12px;
  padding-bottom:6px;                 /* tightens vertical spacing */
}

/* Right-side action area for the flag */
.pane-actions{ display:flex; align-items:center; }

/* Make the header flag a bit smaller so it fits nicely */
.pane-head .flagBtn.big{ --btn-h:72px; }         /* was 92px */
.pane-head .flagBtn.big{ --rhombus-scale:.74; }  /* keeps rounded diamond inside button */

/* Tighten the controls row since it no longer holds the flag */
.pane-controls{ gap:10px; margin-top:2px; }

/* On very narrow phones, shrink the header flag a touch more */
@media (max-width: 380px){
  .pane-head .flagBtn.big{ --btn-h:64px; --rhombus-scale:.72; }
}

  /* Give the header a hair more top room and bump the flag down a bit */
  .pane-head{ padding-top: 6px; overflow: visible; }   /* keep any glow visible */
  .pane-head .flagBtn.big{ margin-top: 6px; }          /* nudges the diamond down */
  
  @media (max-width: 380px){
    .pane-head{ padding-top: 8px; }
	  .pane-head .flagBtn.big{ margin-top: 8px; }
	  }
	  
	  
	  /* Score cluster should always hug the left edge */
.scoreWrap{ margin-left: 0 !important; }

/* Pager dots slide to the far right so they never push the score */
.pager{ margin-left: auto !important; }


/* ——— Toasts (center of screen, all of them) ——— */
.toasts{
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);      /* hard-center the stack */
  display: flex;
  flex-direction: column;
  align-items: center;                    /* center each toast */
  gap: 10px;
  z-index: 10000;
  pointer-events: none;                   /* lets you tap through gaps */
  max-width: calc(100vw - 32px);
}

.toast{
  pointer-events: auto;                   /* but the toast itself is clickable */
  background:#fff; color:#0f172a;
  border:1px solid #e7ecff; border-left:6px solid #0b74ff;
  border-radius:12px;
  width: min(560px, 92vw);                /* nice centered width */
  padding:12px 14px;
  box-shadow:0 10px 30px rgba(16,24,40,.15);
  font-weight:800; line-height:1.2;
  display:flex; flex-direction:column; gap:4px;
  animation: toast-in .18s ease-out;
}

.toast.success{ border-left-color:#16a34a; }
.toast.error{   border-left-color:#ef4444; }
.toast .sub{ font-weight:600; color:#475467; font-size:12px; }

/* animate only vertical so center math stays crisp */
@keyframes toast-in  { from { transform: translateY(8px);  opacity:0 } to { transform: translateY(0); opacity:1 } }
@keyframes toast-out { to   { transform: translateY(8px);  opacity:0 } }
.toast.hide{ animation: toast-out .15s ease-in forwards; }

/* Bigger, phone-friendly toast */
.toast{
  pointer-events: auto;
  background:#fff; color:#0f172a;
  border:1px solid #e7ecff; border-left:8px solid #0b74ff; /* thicker accent */
  border-radius:14px;

  /* wider + responsive type / padding */
  width: min(640px, 96vw);
  font-weight:800; line-height:1.25;
  font-size: clamp(16px, 4.8vw, 20px);
  padding: clamp(14px, 3.6vw, 22px) clamp(16px, 4.2vw, 24px);

  box-shadow:0 14px 34px rgba(16,24,40,.18);
  display:flex; flex-direction:column; gap:6px;
  animation: toast-in .18s ease-out;
}
.toast .sub{
  font-weight:600; color:#475467;
  font-size: clamp(13px, 3.6vw, 16px);
}

/* keep the exit anim */
@keyframes toast-in  { from { transform: translateY(8px);  opacity:0 } to { transform: translateY(0); opacity:1 } }
@keyframes toast-out { to   { transform: translateY(8px);  opacity:0 } }
.toast.hide{ animation: toast-out .15s ease-in forwards; }

/* XXL toast (bigger than xl) */
.toast.xxl{
  /* bigger readable type + comfy padding */
  font-size: clamp(22px, 7.2vw, 30px);
  line-height: 1.25;
  padding: clamp(24px, 6vw, 36px) clamp(26px, 7vw, 40px);

  /* stronger visual weight */
  border-left-width: 12px;
  border-radius: 16px;
  box-shadow: 0 18px 44px rgba(16,24,40,.22);

  /* give it more room, still safe on tiny phones */
  width: min(720px, 98vw);
}

.toast.xxl .sub{
  font-size: clamp(16px, 4.8vw, 20px);
  line-height: 1.3;
}

/* Compact dog card */
#dogCard { padding: 10px 12px; }
#dogCard .dog-head{
  display:grid;
  grid-template-columns: 1fr auto;
  align-items:center;
  gap:10px;
  padding-bottom: 0;
}
#dogCard .dog-left{
  display:flex; align-items:baseline; gap:8px;
}
#dogCard .dog-left .kind{ font-size:16px; font-weight:900; color:#0b74ff; }
#dogCard .dog-left .title{ font-size:20px; font-weight:900; color:#0f172a; }

/* Make the DOG mic about half width, a bit shorter, emoji-only */
#dogMic.mic.big.half{
  min-width: clamp(120px, 44vw, 180px);
  height: 72px;
  padding: 0 14px;
  font-size: 22px;           /* emoji size */
  gap: 10px;
}

/* Optional: smaller hint + tighter spacing */
#dogCard .hint{ margin-top: 6px; font-size: 12px; color:#667085; }

[hidden]{ display:none !important; }


</style>
</head>
<body>
  <div id="fitViewport">
  <div id="fitRoot">
    <div class="wrap">


	
<div class="card" id="dogCard" style="margin-bottom:12px;">
  <div class="pane-head dog-head">
    <div class="dog-left">
      <span class="kind">Dog:</span>
      <span class="title" id="dogName">—</span>
    </div>

    <button class="mic big half" id="dogMic" type="button" title="Say a dog’s name">
      <span class="dot"></span> 🔄 Switch
    </button>
  </div>

  <div class="hint" id="dogHint">Say a name</div>


      <div id="items" class="items"></div>
	  <div id="stage" class="stage" aria-live="polite"></div>

    </div>

<div class="card" style="margin-top:12px" hidden>
  <strong>Say things like…</strong>
  <ul class="sub" style="margin:6px 0 0 18px">
    <li>“flag big hunt and overran, rating seven point five”</li>
    <li>“remove didn’t mark and poor initial, increase by point five”</li>
    <li>“clear flags, score 6”</li>
    <li>“7.5” (just a number sets the score)</li>
  </ul>
</div>

  <!-- Missed phrases overlay -->
  <div id="missedOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases</strong></div>
        <div class="hint">These didn’t map to flags. Tap 🎤 to retry or apply a suggestion.</div>
      </div>
      <div id="missedList" class="sheet-body"></div>
      <div class="sheet-foot">
        <button class="btn" id="missedClose">Close</button>
        <button class="btn ghost" id="missedClear">Dismiss all</button>
      </div>
    </div>
  </div>
  

  <!-- Master log overlay -->
  <div id="logOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases – log</strong></div>
        <div class="hint">Kept in localStorage to spot trends. Clear anytime.</div>
      </div>
      <div id="logList" class="sheet-body log-list"></div>
      <div class="sheet-foot">
        <button class="btn" id="logClose">Close</button>
        <button class="btn danger" style="border-color:#fca5a5;color:#7f1d1d" id="logClear">Clear log</button>
      </div>
    </div>
  </div>
  
  
  <!-- User picker -->
<div id="userOverlay" class="overlay" aria-hidden="true">
  <div class="sheet" style="max-width:420px">
    <div class="sheet-head"><strong>Who are you?</strong></div>
    <div class="sheet-body" style="display:flex;gap:10px;flex-wrap:wrap">
      <button class="btn primary" data-user="Scott">Scott</button>
      <button class="btn primary" data-user="Cody">Cody</button>
      <button class="btn primary" data-user="Brian">Brian</button>
      <button class="btn primary" data-user="BJ">BJ</button>
    </div>
  </div>
</div>

  
<!-- Active-flags peek (hold the red circle, swipe down to clear) -->
<div id="peekOverlay" class="overlay" aria-hidden="true">
  <div class="peek">
    <div class="peek-head">Active flags for this item</div>
    <div id="peekList" class="peek-list"></div>

    <div id="pullZone" class="pull-zone">
      <div id="pullBar" class="pull-bar"></div>
      <div id="pullLabel" class="pull-label">Swipe down to clear</div>
    </div>
  </div>
</div>



<div class="bar" hidden>
  <button id="clearBtn" class="btn">Clear all</button>
  <button id="viewLogBtn" class="btn ghost">Unassigned Log</button>
  <div id="status" class="status">Status: idle</div>
</div>
 </div>
</div>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>


  // reuse trailer.html config
  const firebaseConfig = {
    apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
    authDomain: "task-tracker-73b77.firebaseapp.com",
    projectId: "task-tracker-73b77",
    storageBucket: "task-tracker-73b77.firebasestorage.app",
    messagingSenderId: "795274673000",
    appId: "1:795274673000:web:0ea07130e45c72384134dd",
    measurementId: "G-VLW5KLY4FF"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  
  // ---------- Run context (trainer/day/setup) ----------
let currentTrainer = 'Scott';                   // default
let currentDateKey = null;
let currentSetupId = null;
let currentSetupOrder = 1;
let unsubRun = null;
let currentUser = localStorage.getItem('currentUser') || null;  // doubles as trainer
let unsubSession = null;                                        // session listener
// (keep your existing: let unsubRun = null;)


// Build a reference to the score "run" doc for a dog
function runDocRef(dogName){
  if (!dogName || !currentSetupId || !currentTrainer || !currentDateKey) return null;
  return db.collection('setups').doc(currentTrainer)
           .collection('days').doc(currentDateKey)
           .collection('setups').doc(currentSetupId)
           .collection('scores').doc(dogName)
           .collection('runs').doc('current'); // one doc per day/setup/dog
}

function sessionDocRef(){
  if (!currentTrainer || !currentDateKey || !currentSetupId) return null;
  return db.collection('setups').doc(currentTrainer)
           .collection('days').doc(currentDateKey)
           .collection('setups').doc(currentSetupId)
           .collection('session').doc('current');
}

function attachSessionListener(){
  const ref = sessionDocRef();
  if (!ref) return;

  if (unsubSession) { try{unsubSession();}catch{} unsubSession = null; }

  unsubSession = ref.onSnapshot(snap => {
    const data = snap.data() || {};
    const docDog = data.selectedDog || null;
    if (docDog && docDog !== selectedDog){
      // This will fire your existing dog:selected flow (loadDogRun + attachRunListener)
      setSelectedDog(docDog);
    }
  }, err => console.warn('session listener error:', err));
}


// Tiny debounce helper + per-item debouncers
function debounce(fn, ms=350){
  let t = null;
  const d = (...a) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...a), ms);
  };
  d.cancel = () => { clearTimeout(t); t = null; };
  return d;
}

function cancelPendingSaves(){
  Object.values(saveDebouncers).forEach(fn => fn?.cancel?.());
  for (const k in saveDebouncers) delete saveDebouncers[k];
}


const saveDebouncers = {};
function debouncedSaver(itemId){
  if (!saveDebouncers[itemId]){
    saveDebouncers[itemId] = debounce(async ()=>{
      const dogName = selectedDog;
      const ref = runDocRef(dogName);
      if (!ref) return;
      const it = items.find(x=>x.id===itemId);
      if (!it) return;

      // Persist score + flags for this one item
      const payload = { score: it.score || 0, flags: it.flags || {} };
      await ref.set({
        trainer: currentTrainer,
        dateKey: currentDateKey,
        setupId: currentSetupId,
        setupOrder: currentSetupOrder,
        // tip: if you need a numeric "handles" count later, add it alongside
        items: { [itemId]: payload },
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    }, 350);
  }
  return saveDebouncers[itemId];
}

// Load this dog's saved scores/flags into our in-memory `items` and re-render
async function loadDogRun(dogName){
  const ref = runDocRef(dogName);
  if (!ref) return;

  const snap  = await ref.get();
  const saved = snap.exists ? (snap.data()?.items || {}) : {};

  let changed = false;

  items.forEach(it => {
    const s = saved[it.id];

    // NEW: hard reset to a clean baseline first
    const newScore = Number.isFinite(s?.score) ? quant05(s.score) : 0;
    const newFlags = (s?.flags && typeof s.flags === 'object') ? { ...s.flags } : {};

    // Only mark changed if values differ (prevents noisy re-renders)
    const flagsChanged = JSON.stringify(it.flags || {}) !== JSON.stringify(newFlags);
    const scoreChanged = (it.score ?? 0) !== newScore;

    if (flagsChanged || scoreChanged){
      it.flags = newFlags;
      it.score = newScore;
      changed = true;
    }
  });

  if (changed){
  renderAll();
  refreshStage();     // <— rebuild both visible panes for the new dog
}
attachRunListener(dogName);
}


function attachRunListener(dogName){
  const ref = runDocRef(dogName);
  if (!ref) return;

  // stop any previous listener
  if (unsubRun) { try{unsubRun();}catch{} unsubRun = null; }

  unsubRun = ref.onSnapshot(snap => {
    const saved = snap.exists ? (snap.data()?.items || {}) : {};

    let changed = false;

    // bring local items in sync with what Firestore has
    items.forEach(it => {
      const s = saved[it.id];

      const newScore = Number.isFinite(s?.score) ? quant05(s.score) : 0;
      const newFlags = (s?.flags && typeof s.flags === 'object') ? { ...s.flags } : {};

      const flagsChanged = JSON.stringify(it.flags || {}) !== JSON.stringify(newFlags);
      const scoreChanged = (it.score ?? 0) !== newScore;

      if (flagsChanged || scoreChanged){
        it.flags = newFlags;
        it.score = newScore;
        changed = true;

        // keep both UI modes in sync
        syncRow(it);
        syncStageForItem?.(it);
      }
    });

    if (changed){
      refreshStage(); // ensures the visible panes reflect changes
      setStatus('live update');
    }
  }, err => console.warn('run listener error:', err));
}



/* ---------------- Flag dictionary & variants (for positioning/fuzzy) ---------------- */
const FLAGS = [
  { key:'bigHunt',        label:'Big Hunt',         variants:['big hunt'] },
  { key:'marginalHunt',   label:'Marginal Hunt',    variants:['marginal hunt'] },

  // add split/inflected variants
  { key:'overran',        label:'Overran',          variants:['overran','overrun','over run','over-run','over ran','ran over'] },

  { key:'shortCheckDown', label:'Short Checkdown',  variants:[
      'short checkdown','short check down','short-check down','short check-down'
    ] },

  // allow articles + shorthand
  { key:'backSideOfGun',  label:'Backside of Gun',  variants:[
      'backside of gun','backside of the gun','back side of gun','back side of the gun',
      'back of gun','back of the gun'
    ] },

  { key:'handled',        label:'Handled',          variants:['handled','handles'] },
  { key:'castRefusal',    label:'Cast Refusal',     variants:['cast refusal','cast refused','refused cast'] },

  // sit/sat + article
  { key:'sitOnWhistle',   label:'Sit on Whistle',   variants:[
      'sit on whistle','sit on the whistle','sat on whistle','sat on the whistle'
    ] },

  // didn’t vs did not
  { key:'didntMark', label:"Didn't Mark", variants:['didnt mark', "didn't mark", 'did not mark'] },


  { key:'poorInitial',    label:'Poor Initial',     variants:['poor initial'] },

  // head swing vs swung
  { key:'headswing',      label:'Headswing',        variants:['headswing','head swing','head swung'] },

  { key:'break',          label:'Broke',            variants:['broke','break'] },
  { key:'switched',       label:'Switched',         variants:['switched','switch','did a switch'] },
  { key:'noGo',           label:'No-Go',            variants:['no go','no-go'] },

  // pick-up hyphen + article
  { key:'pickedUpPoison', label:'Poison Pick Up',   variants:[
      'poison pick up','poison pick-up','picked up poison','picked up the poison'
    ] },
  { key:'noPickUp',       label:'No Pick Up',       variants:[
      'no pick up','no pick-up','no pickup'
    ] },

  { key:'stoodOut',       label:'Stood Out',        variants:['stood out','stood way out'] },
  { key:'popped',         label:'Popped',           variants:['popped','pop'] },
];
const FLAG_MAP = Object.fromEntries(FLAGS.map(f=>[f.key,f]));

/* Regex bundle for fast detection (multi-match) */
/* NOTE: these broaden matching but preserve existing behavior */
const FLAG_RX = {
  bigHunt: [
    /big[\s-]*hunt/gi,
    /(?:big|wide|large)\s+(?:area\s+)?hunt/gi,
    /hunted\s+big/gi,
    /big\s+search/gi
  ],

  marginalHunt: [
    /marginal[\s-]*hunt/gi,
    /(?:small|short|brief|light)\s+hunt/gi
  ],

  // overran / over ran / over run / ran over + synonyms
  overran: [
    /\boverran\b/gi, /\bover[\s-]*(?:ran|run)\b/gi, /\bran\s+over\b/gi,
    /\bovershot\b/gi, /\bover\s*shot\b/gi,
    /ran\s+past/gi, /(?:pushed|carried|blew)\s+(?:past|deep)\b/gi,
    /\btoo\s+deep\b/gi
  ],

  // short checkdown + synonyms
  shortCheckDown: [
    /short[\s-]*check[\s-]*down/gi, /short[\s-]*checkdown/gi,
    /short\s+check\b/gi, /checked\s+down\s+(?:short|close)\b/gi,
    /check\s*down\s*short\b/gi, /checked\s+early\b/gi
  ],

  // backside/back of/behind/past gun
  backSideOfGun: [
    /back\s*side\s*of\s*(?:the\s*)?gun/gi,
    /backside\s*of\s*(?:the\s*)?gun/gi,
    /back\s*of\s*(?:the\s*)?gun/gi,
    /behind\s*(?:the\s*)?gun(?:ner)?\b/gi,
    /back\s*of\s*(?:the\s*)?gunner\b/gi,
    /past\s*(?:the\s*)?gun\b/gi
  ],

  // handled + inflections
  handled: [
    /\bhandled?\b/gi,
    /had\s+to\s+handle\b/gi,
    /took\s+(?:a|the)?\s*handle\b/gi,
    /needed\s+(?:a|the)?\s*handle\b/gi,
    /(?:double|re)[-\s]?handle\b/gi,
    /\bi\s+handled\b/gi
  ],

  // cast refusal + inflections
  castRefusal: [
    /cast[\s-]*refusal/gi, /cast[\s-]*refused/gi, /refused[\s-]*cast/gi,
    /refus(?:ed|al)\s+(?:a\s*)?cast/gi,
    /wouldn'?t\s+cast/gi, /ignored\s+the\s+cast/gi,
    /\bno\s+cast\b/gi, /refused\s+the\s*re[-\s]?cast\b/gi
  ],

  // sit|sat on/to whistle (+ late/slow sit)
  sitOnWhistle: [
    /\b(?:sit|sat)\s*on\s*(?:the\s*)?whistle\b/gi,
    /\bsit\s*to\s*(?:the\s*)?whistle\b/gi, /\bsat\s*to\s*whistle\b/gi,
    /\blate\s+sit(?:\s+on\s+whistle)?\b/gi, /\bslow\s+sit(?:\s+on\s+whistle)?\b/gi
  ],

  // didn't|did not mark + synonyms
  didntMark: [
    /(?:didn'?t|did\s+not)\s*mark/gi,
    /\bno\s+mark\b/gi, /failed\s+to\s+mark\b/gi,
    /didn'?t\s+see\s+it\b/gi, /lost\s+the\s+mark\b/gi,
    /poor\s+mark\b/gi
  ],

  poorInitial: [
    /poor\s*initial/gi,
    /\b(?:bad|weak)\s+initial(?:\s+line)?\b/gi,
    /\boff\s+the\s+line\b/gi,
    /poor\s+initial\s+line\b/gi
  ],

  // head swing / headswing / head swung + synonyms
  headswing: [
    /head\s*swing/gi, /\bheadswing\b/gi, /\bhead\s*swung\b/gi,
    /swung\s+(?:his|her|the)?\s*head\b/gi, /head\s*whip\b/gi,
    /looked\s+off\b/gi, /head\s*swing\s+(?:left|right)\b/gi
  ],

  break: [
    /\bbroke?\b/gi, /\bbreak\b/gi,
    /\bjumped\b/gi, /left\s+early\b/gi, /\bbolted\b/gi,
    /came\s+off\s+the\s+line\b/gi, /\bcrept\b/gi
  ],

  switched: [
    /\bswitch(?:ed|)\b/gi, /did\s*(?:a\s*)?switch\b/gi,
    /switched\s+birds?\b/gi, /(?:changed|swapped)\s+birds?\b/gi,
    /picked\s+the\s+other\s+bird\b/gi, /\bwrong\s+bird\b/gi
  ],

  noGo: [
    /\bno[-\s]?go\b/gi,
    /wouldn'?t\s+go\b/gi, /didn'?t\s+go\b/gi, /refused\s+to\s+go\b/gi,
    /\bbalked\b/gi, /stuck\s+on\s+the\s+line\b/gi
  ],

  pickedUpPoison: [
    /poison\s*pick[-\s]*up/gi, /picked\s*up\s*(?:the\s*)?poison/gi,
    /(?:took|grabbed)\s*(?:the\s*)?poison\b/gi,
    /went\s+for\s+(?:the\s*)?poison\b/gi,
    /picked\s+(?:the\s*)?poison\s+bird\b/gi
  ],

  noPickUp: [
    /\bno\s*pick[-\s]*up\b/gi, /\bno\s*pickup\b/gi,
    /didn'?t\s+pick\s+up\b/gi, /\bno\s+retrieve\b/gi,
    /left\s+(?:it|the\s+bird)\b/gi
  ],

  stoodOut: [
    /stood\s*out/gi, /hung\s+out\b/gi, /stayed\s+out\b/gi, /\blingered\b/gi
  ],

  popped: [
    /\bpopped?\b/gi,
    /popped\s+on\s+the\s+blind\b/gi,
    /stopped\s+and\s+looked\b/gi,
    /stopped\s+short\b/gi
  ],
};

// Add/remove verb detectors (single source of truth)
const RX_ADD_VERB =
  /\b(?:add|flag|set|give|tag|check|activate|turn\s+on|mark(?:\s+it)?\s+as)\b/;

const RX_REMOVE_VERB =
  /\b(?:remove|clear|unset|delete|drop|kill|unflag|turn\s+off|take\s+off)\b/;



/* ---------------- Demo items ---------------- */
let items = [];
/* ---------------- UI ---------------- */
const itemsEl = document.getElementById('items');
const statusEl = document.getElementById('status');

// --- Stage (carousel) refs/state ---
const stageEl = document.getElementById('stage');
let idxMark  = +(localStorage.getItem('idxMark')  || 0);
let idxBlind = +(localStorage.getItem('idxBlind') || 0);

// ------- Helpers for today + formatting -------
function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
function yards(n){ return (typeof n==='number' && isFinite(n)) ? Math.round(n) : 0; }

// Build our speech-page item objects from setups doc
function buildSpeechItemsFromSetupDoc(data){
  const out = [];
  const marks  = Array.isArray(data.items)  ? data.items  : [];
  const blinds = Array.isArray(data.blinds) ? data.blinds : [];

  marks.forEach((m, i) => {
    out.push({
      id: m.id || `m_${i+1}`,
      kind: 'Mark',
      title: `#${i+1} — ${yards(m.dist)} yards`,
      score: 0,
      flags: {}
    });
  });

  blinds.forEach((b, i) => {
    out.push({
      id: b.id || `b_${i+1}`,
      kind: 'Blind',
      title: `#${i+1} — ${yards(b.dist)} yards`,
      score: 0,
      flags: {}
    });
  });

  return out;
}

// Reset stage so new data doesn't inherit old panes
function resetStage(){
  idxMark = 0; idxBlind = 0;
  try {
    localStorage.setItem('idxMark', '0');
    localStorage.setItem('idxBlind', '0');
  } catch {}
  stageEl.innerHTML = '';   // remove previous .pane-slot(s)
  itemsEl.innerHTML = '';   // clear old rows list
}

// Load today's Setup N for a trainer (defaults: Scott / 1)
async function loadTodaysSetup({ trainer = (currentUser ?? 'Scott'), setupOrder=1 } = {}){
const dateKey = ymd(new Date());
currentDateKey = dateKey;          

  setStatus(`Loading ${trainer} – ${dateKey} (Setup ${setupOrder})…`);

  const dayColl = db.collection('setups').doc(trainer)
                    .collection('days').doc(dateKey)
                    .collection('setups');

  const snap = await dayColl.orderBy('order').get();
  if (snap.empty){
    setStatus('No setups found for today. Using empty list.');
    resetStage();
    items = [];
    renderAll();
    renderStage();
    return;
  }

  // choose requested order if present, else first doc
let chosen = snap.docs[0];
if (setupOrder > 1){
  const found = snap.docs.find(d => (d.data()?.order ?? 0) === setupOrder);
  if (found) chosen = found;
}
currentTrainer = trainer;                  // <— add
currentSetupId = chosen.id;                // <— add
currentSetupOrder = setupOrder || 1;       // <— add


  const data = chosen.data() || {};
  items = buildSpeechItemsFromSetupDoc(data);

  resetStage();
  renderAll();
  renderStage();
if (selectedDog) { loadDogRun(selectedDog).catch(console.error); }
  const m = items.filter(x=>x.kind==='Mark').length;
  const b = items.filter(x=>x.kind==='Blind').length;
  setStatus(`Loaded ${trainer} – ${dateKey} • ${m} marks / ${b} blinds`);
  attachSessionListener();
}

// (optional) expose for console testing
window.loadTodaysSetup = loadTodaysSetup;


function clamp(i, len){ if(len<=0) return 0; return (i%len+len)%len; }
function saveIdx(){ localStorage.setItem('idxMark', idxMark); localStorage.setItem('idxBlind', idxBlind); }


function chip(key,on){
  const el=document.createElement('span');
  el.className='chip'+(on?' on':'');
  el.dataset.key=key;
  el.textContent=FLAG_MAP[key].label;
  return el;
}
function renderRow(it){
  const row=document.createElement('div'); row.className='row'; row.id='row-'+it.id;

  const left=document.createElement('div');
  left.innerHTML=`<div class="kind">${it.kind}</div><div class="title">${it.title}</div>`;

  const mid=document.createElement('div');
  const chips=document.createElement('div'); chips.className='chips';
  FLAGS.forEach(f=> chips.appendChild(chip(f.key, !!it.flags[f.key])));
  mid.appendChild(chips);
  
 const right=document.createElement('div'); right.className='controls';
const flagBtn = document.createElement('button');
flagBtn.type='button';
flagBtn.className='flagBtn big';
flagBtn.title='Hold to view flags • Swipe down to clear';
flagBtn.textContent='🚩';
setupFlagPeek(flagBtn, it.id);

const mic=document.createElement('button'); mic.type='button'; mic.className='mic big';
mic.innerHTML='<span class="dot"></span> 🎤 Say Red Flags/Score';

  mic.addEventListener('click',()=>startListeningFor(it.id));
  
  const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='10'; slider.step='0.5'; slider.value=it.score;
  slider.addEventListener('input',()=>{ it.score=+slider.value; score.textContent=it.score.toFixed(1);debouncedSaver(it.id)();});
  const score=document.createElement('div'); score.className='score'; score.textContent=it.score.toFixed(1);
 right.append(flagBtn, mic, slider, score);

  row.append(left,mid,right);
  itemsEl.appendChild(row);
}
function renderAll(){ itemsEl.innerHTML=''; items.forEach(renderRow); }

function ensureSlot(type){
  let slot = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if(!slot){
    slot = document.createElement('div');
    slot.className = 'pane-slot';
    slot.dataset.type = type;
    stageEl.appendChild(slot);
  }
  return slot;
}

function renderStage(){
  const marks  = items.filter(it=>it.kind==='Mark');
  const blinds = items.filter(it=>it.kind==='Blind');
  if (!stageEl) return;

  idxMark  = clamp(idxMark,  marks.length);
  idxBlind = clamp(idxBlind, blinds.length);

  // Ensure slots exist (one for each)
  const markSlot  = ensureSlot('mark');
  const blindSlot = ensureSlot('blind');

  // First time render: if slot empty, just place the pane (no animation)
  if(!markSlot.querySelector('.pane')){
    markSlot.appendChild(renderPane('Mark', marks[idxMark], marks.length, 'mark'));
  }
  if(!blindSlot.querySelector('.pane')){
    blindSlot.appendChild(renderPane('Blind', blinds[idxBlind], blinds.length, 'blind'));
  }
}

// direction: 'left' (next) or 'right' (prev)
function animateSwap(type, direction){
  const isMark = (type==='mark');
  const list   = items.filter(it=> it.kind === (isMark ? 'Mark' : 'Blind'));
  const total  = list.length;
  const idx    = isMark ? idxMark : idxBlind;
  const slot   = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if(!slot || !total) return;

  const current = slot.querySelector('.pane');
  const label   = isMark ? 'Mark' : 'Blind';
  const next    = renderPane(label, list[idx], total, type);

  // stage the new pane off-screen
  next.classList.add(direction==='left' ? 'enter-from-right' : 'enter-from-left');
  slot.appendChild(next);

  // lock both panes to the slot for animation
  next.style.position = current.style.position = 'absolute';
  next.style.inset    = current.style.inset    = '0';

  // kick the transition – ensure the off-screen state is committed first
requestAnimationFrame(() => {
  void next.offsetWidth; // layout flush (or use next.getBoundingClientRect())
  requestAnimationFrame(() => {
    current.classList.add(direction === 'left' ? 'exit-to-left' : 'exit-to-right');
    next.classList.remove('enter-from-right', 'enter-from-left');
  });
});


  const cleanup = () => {
    current?.remove();
    // let the survivor be normal flow for focus/scroll if you prefer (or stay absolute)
    next.style.position = 'absolute';  // keep absolute so future swaps overlay cleanly
    next.style.inset = '0';
  };
  next.addEventListener('transitionend', cleanup, { once:true });
}


function renderPane(label, it, total, type){
  const pane = document.createElement('div');
  pane.className = 'pane';
  pane.dataset.type = type;

  // ---- HEADER: titles on the left, flag on the right ----
  const head = document.createElement('div');
  head.className = 'pane-head';

  const headLeft = document.createElement('div');
  headLeft.innerHTML = `
    <div class="kind">${label}</div>
    <div class="title">${it ? it.title : '—'}</div>
  `;

  const headRight = document.createElement('div');
  headRight.className = 'pane-actions';

  // Flag lives in the header now
  const flagBtn = document.createElement('button');
  flagBtn.type='button';
  flagBtn.className='flagBtn big';
  flagBtn.title='Hold to view flags • Swipe down to clear';
  flagBtn.textContent='🚩';
  if (it) setupFlagPeek(flagBtn, it.id);

  headRight.appendChild(flagBtn);
  head.append(headLeft, headRight);

  // ---- CONTROLS: mic + score + pager (flag removed) ----
  const ctrls = document.createElement('div');
  ctrls.className = 'pane-controls';

  const mic = document.createElement('button');
mic.type='button';
mic.className='mic big';
mic.innerHTML='<span class="dot"></span> 🎤 Say Red Flags/Score';

// NEW: default to “not blocking click”
mic.dataset.blockClick = '0';

  // Hidden range for existing logic
  const range = document.createElement('input');
  range.type='range'; range.min='0'; range.max='10'; range.step='0.5';
  range.value = it ? it.score : 0;
  range.className = 'visually-hidden';

  const legacyScore = document.createElement('div');
  legacyScore.className='score big';
  legacyScore.textContent = (it ? it.score : 0).toFixed(1);

  const scoreWrap = document.createElement('div');
  scoreWrap.className = 'scoreWrap';

  const dec = document.createElement('button');
  dec.type='button'; dec.className='scoreBtn'; dec.setAttribute('aria-label','Decrease score'); dec.textContent='–';

  const badge = document.createElement('div');
  badge.className='scoreBadge';
  badge.textContent = (it ? it.score : 0).toFixed(1);

  const inc = document.createElement('button');
  inc.type='button'; inc.className='scoreBtn'; inc.setAttribute('aria-label','Increase score'); inc.textContent='+';

  scoreWrap.append(dec, badge, inc);

  const pager = document.createElement('div');
  pager.className = 'pager';
  if (total > 1){
    for(let i=0;i<total;i++){
      const d=document.createElement('div');
      d.className='dot' + (i === (type==='mark'?idxMark:idxBlind) ? ' on' : '');
      pager.appendChild(d);
    }
  }

  if (it){
    mic.addEventListener('click', (ev) => {
  // If a horizontal swipe started on the mic, cancel this click
  if (mic.dataset.blockClick === '1') {
    ev.preventDefault();
    ev.stopPropagation();
    return;
  }
  startListeningFor(it.id);
});


    range.addEventListener('input', ()=>{
      it.score = +range.value;
      const v = it.score = quant05(it.score);
      badge.textContent = v.toFixed(1);
      legacyScore.textContent = v.toFixed(1);
      debouncedSaver(it.id)();
    });
    range.addEventListener('pointerdown', (e)=> e.stopPropagation());

    const nudge = (dir)=> {
      const raw = (it.score ?? 0) + (dir * 0.5);
      const v = it.score = Math.max(0, Math.min(10, quant05(raw)));
      range.value = v;
      badge.textContent = v.toFixed(1);
      legacyScore.textContent = v.toFixed(1);
      syncRow(it);
      debouncedSaver(it.id)();
    };
    dec.addEventListener('click', ()=> nudge(-1));
    inc.addEventListener('click', ()=> nudge(+1));

    attachSwipeX(pane, 60,
      () => { if (type==='mark'){ idxMark = clamp(idxMark+1, total); } else { idxBlind = clamp(idxBlind+1, total); } saveIdx(); animateSwap(type, 'left'); },
      () => { if (type==='mark'){ idxMark = clamp(idxMark-1, total); } else { idxBlind = clamp(idxBlind-1, total); } saveIdx(); animateSwap(type, 'right'); }
    );
  }

  // Order: header (with flag) + controls (mic/score/pager)
  ctrls.append(scoreWrap, mic, pager, range, legacyScore);

  pane.append(head, ctrls);
  return pane;
}



function attachSwipeX(el, threshold, onLeft, onRight){
  let pid = null, sx = 0, dx = 0, ignore = false;
  let micEl = null;        // if gesture started on the mic
  let swiping = false;

  el.addEventListener('pointerdown', (e)=>{
    const t = e.target;
    const startedOnRange = t.closest?.('input[type="range"]');
    const startedOnFlag  = t.closest?.('.flagBtn');
    micEl                = t.closest?.('.mic') || null;

    // still block swipes that start on the range or the flag
    if (startedOnRange || startedOnFlag){
      ignore = true; pid = null; sx = 0; dx = 0; micEl = null; swiping = false;
      return;
    }

    ignore = false;
    pid = e.pointerId; sx = e.clientX; dx = 0; swiping = false;

    // IMPORTANT: do NOT capture yet if we started on the mic.
    // Let the tap produce a normal click unless we detect a swipe.
    if (!micEl) el.setPointerCapture?.(pid);
  });

  el.addEventListener('pointermove', (e)=>{
    if (ignore || e.pointerId !== pid) return;
    dx = e.clientX - sx;

    // If the gesture began on the mic and moves horizontally,
    // mark swipe, block the mic's click, and now capture.
    if (micEl && !swiping && Math.abs(dx) > 8){
      swiping = true;
      micEl.dataset.blockClick = '1';
      el.setPointerCapture?.(pid);
    }
  });

  const end = (e)=>{
    if (ignore || e.pointerId !== pid){
      micEl = null; return;
    }

    // If we started on mic and never swiped, do nothing here;
    // let the mic's normal click fire naturally.
    if (micEl && !swiping){
      // ensure it's not blocked just in case
      micEl.dataset.blockClick = '0';
      micEl = null;
      pid = null; dx = 0;
      return;
    }

    // otherwise, handle the swipe
    if (dx <= -threshold) onLeft?.();
    else if (dx >= threshold) onRight?.();

    // re-enable mic clicks after this event cycle
    if (micEl){
      setTimeout(()=> { micEl.dataset.blockClick = '0'; micEl = null; }, 0);
    }

    pid = null; dx = 0; swiping = false;
  };

  el.addEventListener('pointerup', end);
  el.addEventListener('pointercancel', end);
}





renderAll();          // safe no-op while empty
renderStage();



// --- Peek overlay state/refs ---
const peekOverlay = document.getElementById('peekOverlay');
const peekListEl  = document.getElementById('peekList');
const pullZone    = document.getElementById('pullZone');
const pullBar     = document.getElementById('pullBar');
const pullLabel   = document.getElementById('pullLabel');

// Close when tapping the dim backdrop or pressing Escape
peekOverlay.addEventListener('click', (e)=>{
  if (e.target === peekOverlay) closePeek();
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') closePeek();
});

peekOverlay.addEventListener('pointermove', (e)=>{
  if (peekHold.itemId == null) return;
  if (peekHold.pid != null && e.pointerId !== peekHold.pid) return; // ignore other fingers
  const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
  updatePull(y - peekHold.startY);
}, { passive: true });

document.addEventListener('dog:selected', (e)=>{
  // when the user picks a dog, pull their saved scores/flags for the current setup
  loadDogRun(e.detail.name).catch(console.error);
});


// Global safety net: if the button loses the pointerup, still close
const closeFromDoc = (e)=>{
  if (peekHold.itemId == null) return;
  const y  = e?.clientY ?? (e?.touches?.[0]?.clientY ?? peekHold.startY);
  const dy = y - peekHold.startY;
  if (dy >= peekHold.threshold) clearAllFlags(peekHold.itemId);
  closePeek();
};
document.addEventListener('pointerup', closeFromDoc, { capture:true });
document.addEventListener('pointercancel', closeFromDoc, { capture:true });


// Suppress long-press context menu and text selection on the flag + overlay
['contextmenu', 'selectstart'].forEach(evt => {
  document.addEventListener(evt, (e) => {
    const t = e.target;
    if (t && typeof t.closest === 'function' &&
        (t.closest('.flagBtn') || t.closest('#peekOverlay'))) {
      e.preventDefault();
    }
  }, { passive:false });
});


let peekHold = { itemId:null, startY:0, threshold:90, pid:null };


function openPeek(itemId){
  document.documentElement.classList.add('overlay-open');
  peekHold.itemId = itemId;
  fillPeek(itemId);
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
  pullLabel.textContent = 'Swipe down to clear';
  peekOverlay.classList.add('open');
  peekOverlay.setAttribute('aria-hidden','false');
}
function closePeek(){
  peekOverlay.classList.remove('open');
  peekOverlay.setAttribute('aria-hidden','true');
  peekHold.itemId = null;
  peekHold.pid = null;                 // <— add this
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
 if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
}


function fillPeek(itemId){
  const it = items.find(x=>x.id===itemId);
  const labels = FLAGS.filter(f => !!(it?.flags?.[f.key])).map(f=>f.label);
  peekListEl.innerHTML = labels.length
    ? labels.map(l=>`<div class="peek-flag">${l}</div>`).join('')
    : `<div class="hint">No flags set</div>`;
}

function updatePull(dy){
  const h = Math.max(0, Math.min(140, dy));
  pullBar.style.height = h + 'px';
  const ready = dy >= peekHold.threshold;
  pullZone.classList.toggle('ready', ready);
  pullLabel.textContent = ready ? 'Release to clear' : 'Swipe down to clear';
}

function clearAllFlags(itemId){
  const it = items.find(x=>x.id===itemId);
  if(!it) return;
  it.flags = {};
  syncRow(it);
  renderStage();
debouncedSaver(itemId)();                     // <— persist this item

  fillPeek(itemId);
  pullZone.classList.add('cleared');
  pullLabel.textContent = 'Cleared';
}

// Attach pointer interactions to a given red circle button
function setupFlagPeek(btn, itemId){
  let pid = null, holding = false;

  // prevent native long-press callout / selection on this control
  btn.addEventListener('contextmenu', e => e.preventDefault(), { passive:false });
  btn.addEventListener('selectstart', e => e.preventDefault(), { passive:false });
  btn.addEventListener('touchstart',  e => e.preventDefault(), { passive:false });

  btn.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  holding = true;
  pid = e.pointerId;
  peekHold.pid = e.pointerId;          // <— add this
  btn.setPointerCapture?.(pid);
  peekHold.startY = e.clientY ?? (e.touches?.[0]?.clientY || 0);
  openPeek(itemId);
});


  btn.addEventListener('pointermove', (e)=>{
    if(!holding || e.pointerId !== pid) return;
    const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
    updatePull(y - peekHold.startY);
  });

  const end = (e)=>{
  if(!holding || e.pointerId !== pid) return;
  const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
  const dy = y - peekHold.startY;
  if (dy >= peekHold.threshold) clearAllFlags(itemId);
  holding = false;
  try { btn.releasePointerCapture?.(pid); } catch {}
  pid = null;
  peekHold.pid = null;                 // <— add this
  closePeek();
};

btn.addEventListener('pointerup', end);
btn.addEventListener('pointercancel', end);

}


/* ---------------- Speech engine ---------------- */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let rec=null, activeId=null, activeFix=null; // activeFix = { itemId, phrase, suggestKey }
let listeningToastId = null;
if (SR){
  rec=new SR(); rec.lang='en-US'; rec.interimResults=false; rec.continuous=false;
  rec.onstart = () => {
  setStatus('listening…');
  if (listeningToastId) hideToast(listeningToastId);
  listeningToastId = showToast('🎤 Listening…', { duration: 0, size: 'xxl' });
};

rec.onerror = e => {
  setStatus('error: ' + (e.error || 'unknown'));
  if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
  showToast('Speech error', { type:'error', sub:String(e.error || ''), duration:2000 });
  endListen();
};

rec.onend = () => {
  setStatus('idle');
  if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
  endListen();
};

  rec.onresult = (e) => {
  // Build a “best guess” and capture alternatives (browser-dependent confidence)
  const tx = [...e.results].map(r => r[0].transcript).join(' ').trim();
  const last = e.results[e.results.length - 1];
  const alts = last
    ? Array.from(last).map(a => ({
        transcript: (a.transcript || '').trim(),
        confidence: (typeof a.confidence === 'number') ? +a.confidence.toFixed(3) : null
      }))
    : [];
  const best = alts[0]?.transcript || tx;

  // ---- Dog-name listening fast-path (single block) ----
  if (dogListenActive) {
    const cmd = normalize(best);

    // Voice shortcuts
    if (/\bgo\s+to\s+gps\b/.test(cmd)) {
      if (listeningToastId) { hideToast(listeningToastId); listeningToastId = null; }
      dogListenActive = false;
      dogMicBtn?.classList.remove('listening');
      const who = currentTrainer || currentUser || 'Scott';
      window.location.href = `https://morrowind4732.github.io/task-tracker/gps.html?trainer=${encodeURIComponent(who)}`;
      return;
    }
    if (/\bgo\s+to\s+setup(?:s)?\b/.test(cmd)) {
      if (listeningToastId) { hideToast(listeningToastId); listeningToastId = null; }
      dogListenActive = false;
      dogMicBtn?.classList.remove('listening');
      window.location.href = 'https://morrowind4732.github.io/task-tracker/setups.html';
      return;
    }

    // Dog-name match
    const name = matchDogName(best);
    if (name) {
      setSelectedDog(name);
      setStatus('Dog: ' + name);
    } else {
      setStatus('Heard: "' + best + '", didn’t match a dog');
    }
    dogListenActive = false;
    dogMicBtn?.classList.remove('listening');
    if (listeningToastId) { hideToast(listeningToastId); listeningToastId = null; }
    return;
  }

  // ---- Debug log for regular command handling ----
  console.groupCollapsed(
    `%cSpeech(final) → %c${best}`,
    'color:#888', 'color:#111;font-weight:700'
  );
  console.log('activeId:', activeId, 'activeFix:', activeFix);
  if (alts.length) console.table(alts);
  console.groupEnd();

  let summary = null;

  // ---- Missed-phrase “fix” mode ----
  if (activeFix) {
    const before = snapshotFlags(items.find(x => x.id === activeFix.itemId));
    summary = applyTranscript(activeFix.itemId, best);
    const after  = snapshotFlags(items.find(x => x.id === activeFix.itemId));
    const changed = diffFlags(before, after);

    const matchedSuggestion =
      (activeFix.suggestKey && (
        changed.added.includes(activeFix.suggestKey) ||
        (Array.isArray(changed.toggled) && changed.toggled.includes(activeFix.suggestKey))
      )) ||
      ((changed.added.length + (changed.toggled?.length || 0)) > 0);

    if (matchedSuggestion) {
      if (activeFix.suggestKey) {
        const canon = canonicalPhraseForKey(activeFix.suggestKey);
        if (canon) addAutoFix(activeFix.phrase, canon);
      }
      removeMissed(activeFix.itemId, activeFix.phrase);
      renderMissedOverlay();
    }
    activeFix = null;

  // ---- Normal per-item flow ----
  } else if (activeId) {
    summary = applyTranscript(activeId, best);
  }

  // Close the “Listening…” toast if it’s up
  if (listeningToastId) { hideToast(listeningToastId); listeningToastId = null; }

  // ---- Result toasts / feedback ----
  if (summary?.batchApplied) {
    const range =
      summary.batchApplied > 1
        ? `${summary.batchFrom} → ${summary.batchTo}`
        : `${summary.batchFrom}`;
    showToast('✅ Applied scores', {
      type: 'success',
      size: 'xxl',
      sub: `${summary.batchApplied} ${summary.batchKind.toLowerCase()}(s) • ${range}`,
      duration: 2600
    });
  } else if (summary) {
    const parts = [];
    if (summary.added?.length) parts.push(`Added: ${labelsFor(summary.added).join(', ')}`);
    if (summary.setScore)      parts.push(`Score: ${summary.score.toFixed(1)}`);
    else if (summary.adjust)   parts.push(`Score ${summary.adjust>0?'+':''}${summary.adjust.toFixed(1)} → ${summary.score.toFixed(1)}`);
    if (!parts.length && summary.removed?.length) {
      parts.push(`Removed: ${labelsFor(summary.removed).join(', ')}`);
    }
    if (parts.length) {
      showToast('✅ Updated', { type:'success', size: 'xxl', sub: parts.join(' • '), duration: 2400 });
    } else {
      showToast('No flags recognized', { type:'info', duration: 1400 });
    }
  }
};





}else{
  setStatus('Speech API not supported in this browser.');
}
function setStatus(s){ statusEl.textContent='Status: '+s; }
function startListeningFor(id){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeFix=null;
  activeId=id;
  document.querySelectorAll('.row')
    .forEach(r=> r.classList.toggle('listening', r.id==='row-'+id));
  rec.start();
}

let __toastSeq = 0;
function showToast(text, { type='info', duration=1800, sub=null, placement='center', size=null } = {}){
  const wrap = document.getElementById('toasts'); if(!wrap) return null;
  const id = (++__toastSeq);
  const el = document.createElement('div');
  el.className = 'toast' + (type !== 'info' ? ' ' + type : '') + (size ? ' ' + size : '');
  if (placement === 'center') el.classList.add('center');
  el.dataset.id = String(id);
  el.innerHTML = `<div>${text}</div>${sub ? `<div class="sub">${sub}</div>` : ''}`;
  wrap.appendChild(el);
  if (duration > 0) setTimeout(()=> hideToast(id), duration);
  return id;
}


function hideToast(id){
  const wrap = document.getElementById('toasts'); if(!wrap) return;
  const el = wrap.querySelector(`.toast[data-id="${id}"]`); if(!el) return;
  el.classList.add('hide');
  el.addEventListener('animationend', ()=> el.remove(), { once:true });
}

const toastsWrap = document.getElementById('toasts');
function setToastCenter(on){ toastsWrap?.classList.toggle('center', !!on); }


function labelsFor(keys){ return keys.map(k => FLAG_MAP[k]?.label || k); }


function startFixListening(itemId, phrase, suggestKey){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeId=null;
  activeFix={ itemId, phrase, suggestKey };
  document.querySelectorAll('.row').forEach(r=>r.classList.remove('listening'));
  document.getElementById('row-'+itemId)?.classList.add('listening');
  rec.start();
}
function endListen(){
  activeId=null;
  document.querySelectorAll('.row').forEach(r=> r.classList.remove('listening'));
}


/* ---------------- Persistent Auto-Fix Dictionary ---------------- */
const FIX_KEY = 'speech_autofix_map_v1';

function readFixMap(){
  try { return JSON.parse(localStorage.getItem(FIX_KEY) || '{}'); }
  catch { return {}; }
}
function writeFixMap(map){
  localStorage.setItem(FIX_KEY, JSON.stringify(map));
}
function escapeRegex(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

/** Save a mapping like "big hut" -> "big hunt" (normalized, word-bounded) */
function addAutoFix(heard, corrected){
  const map = readFixMap();
  const h = normalize(heard);
  const c = normalize(corrected);
  if (!h || !c) return;
  map[h] = c;
  writeFixMap(map);
  // optional UI sugar:
  showToast('Saved auto-fix', { type:'success', sub:`"${heard}" → "${corrected}"`, duration: 1600 });
}

/** Apply all saved replacements to a normalized transcript */
function applyAutoFixes(tx){
  const map = readFixMap();
  let out = tx;
  for (const [h, c] of Object.entries(map)){
    const rx = new RegExp(`\\b${escapeRegex(h)}\\b`, 'g');  // whole-phrase, case-normalized
    out = out.replace(rx, c);
  }
  return out;
}

/** Get a canonical phrase string for a given flag key (first variant is best) */
function canonicalPhraseForKey(key){
  const f = FLAGS.find(x => x.key === key);
  return f?.variants?.[0] || f?.label || null;
}


/* ---------------- NLP core ---------------- */
function normalize(s){
  return String(s||'')
    .toLowerCase()
.replace(/[’‘']/g,'')            // "didn't" → "didnt"
.replace(/[^a-z0-9.\s-]/g,' ')

    .replace(/\s+/g,' ')
    .trim();
}
const NUM_WORDS = {
  zero:0, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9, ten:10,
  eleven:11, twelve:12, thirteen:13, fourteen:14, fifteen:15, sixteen:16, seventeen:17, eighteen:18, nineteen:19,
  twenty:20, half:0.5
};
function wordsToNumber(s){
  s=normalize(s);
  if(/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);
  const tok=s.split(/\s+/);
  const i=tok.indexOf('point');
  if(i>-1){
    const A=tok.slice(0,i).join(' ');
    const B=tok.slice(i+1).join(' ');
    const ia=NUM_WORDS[A]; const ib=NUM_WORDS[B];
    if(Number.isFinite(ia) && Number.isFinite(ib)) return +(ia + '.' + Math.round(ib*10));
  }
  if(s in NUM_WORDS) return NUM_WORDS[s];
  return NaN;
}

// Extracts a sequence of numbers like "5 4.5 3 10" or "five four point five three ten"
function extractNumberSequence(s){
  const tok = normalize(s).split(/[\s,]+/).filter(Boolean);
  const out = [];

  for (let i = 0; i < tok.length; i++){
    const t = tok[i];

    // ----- DIGITS (e.g., "7", "7.5", and "7 and a half") -----
    if (/^\d+(\.\d+)?$/.test(t)){
      let n = parseFloat(t);

      // digits + "and (a) half"
      if (tok[i+1] === 'and' && (tok[i+2] === 'half' || (tok[i+2] === 'a' && tok[i+3] === 'half'))){
        n = (isFinite(n) ? n : 0) + 0.5;
        i += (tok[i+2] === 'half' ? 2 : 3);
      }

      out.push(n);
      continue;
    }

    // ----- WORD NUMBERS -----
    if (t in NUM_WORDS){
      // word + "point X"
      if (tok[i+1] === 'point' && (tok[i+2] in NUM_WORDS || /^\d+$/.test(tok[i+2]))){
        const rhs = (tok[i+2] in NUM_WORDS) ? NUM_WORDS[tok[i+2]] : parseInt(tok[i+2], 10);
        const n   = wordsToNumber(`${t} point ${rhs}`);
        if (Number.isFinite(n)) out.push(n);
        i += 2;
        continue;
      }

      // word + "and (a) half"
      if (tok[i+1] === 'and' && (tok[i+2] === 'half' || (tok[i+2] === 'a' && tok[i+3] === 'half'))){
        const base = NUM_WORDS[t];
        if (Number.isFinite(base)) out.push(base + 0.5);
        i += (tok[i+2] === 'half' ? 2 : 3);
        continue;
      }

      // plain word number
      const n = wordsToNumber(t);
      if (Number.isFinite(n)) out.push(n);
    }
  }
  return out;
}


const ORD_WORDS = { first:1, second:2, third:3, fourth:4, fifth:5,
                    sixth:6, seventh:7, eighth:8, ninth:9, tenth:10 };
function romanToInt(s){
  // supports i..xl (1..40) safely; extend if you ever need more
  const map = {i:1, v:5, x:10, l:50, c:100, d:500, m:1000};
  const r = String(s||'').toLowerCase().replace(/[^ivxlcdm]/g,'');
  if (!r) return NaN;
  let total = 0, prev = 0;
  for (let i = r.length - 1; i >= 0; i--){
    const val = map[r[i]] || 0;
    total += (val < prev) ? -val : val;
    prev = val;
  }
  return total;
}
function wordToIndex(s){
  // number word (“two”), plain digit (“2”), ordinal word (“second”),
  // or roman numeral (“ii”, “iv”, “x”)
  const n = wordsToNumber(s);
  if (Number.isFinite(n)) return n;

  const key = normalize(s);
  if (ORD_WORDS[key]) return ORD_WORDS[key];

  if (/^[ivxlcdm]+$/i.test(key)){
    const r = romanToInt(key);
    if (Number.isFinite(r)) return r;
  }
  return NaN;
}



function findAddressedGroups(tx){
  // “mark 3 …”, “marks three …”, “blind 2 …”, “blind number four …”
  const RX = /\b(mark|blind)s?\s+(?:number\s+)?(one|two|three|four|five|six|seven|eight|nine|ten|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|[ivxlcdm]+|\d{1,2})\b/gi;

  const groups = [];
  let m;
  while ((m = RX.exec(tx)) !== null){
    const kind  = m[1].toLowerCase() === 'mark' ? 'Mark' : 'Blind';
    const idx   = Number.isFinite(+m[2]) ? +m[2] : wordToIndex(m[2]);
    const start = m.index + m[0].length;
    groups.push({ kind, index: idx, start, end: tx.length });
  }
  // set group ends to the next header’s start
  for (let i=0;i<groups.length-1;i++) groups[i].end = groups[i+1].start;
  return groups.filter(g => Number.isFinite(g.index) && g.index >= 1);
}

function parseGroupBody(txSlice){
  // Reuse your existing pieces on the slice:
  const { keys } = detectFlagsMulti(txSlice);
const isRemove = RX_REMOVE_VERB.test(txSlice);
const isAdd    = RX_ADD_VERB.test(txSlice);


  const add = new Set(), remove = new Set(), toggle = new Set();
  keys.forEach(k => {
    if (isRemove) remove.add(k);
    else if (isAdd) add.add(k);
    else toggle.add(k);
  });

  // Optional: support “score …” inside the group
  let score = null, adjust = 0, clearAll = /\bclear\s+flags?\b/.test(txSlice);
  const afterCmd = txSlice.match(/\b(?:score|rating|set|make)\b([\s\S]*)$/)?.[1]?.trim() || '';
  if (afterCmd){
    const nums = parseScoreListFlexible(afterCmd);
    if (nums.length >= 1) score = quant05(quantClamp(nums[0]));
  }
  // small +/- inside the group
  const inc = txSlice.match(/\b(increase|raise|up|\+|plus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  const dec = txSlice.match(/\b(decrease|lower|down|-|minus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  if (inc && !dec){
    const amt = inc[2] ? (Number.isFinite(wordsToNumber(inc[2])) ? wordsToNumber(inc[2]) : parseFloat(inc[2])) : 0.5;
    adjust += Number.isFinite(amt) ? amt : 0.5;
  }
  if (dec && !inc){
    const amt = dec[2] ? (Number.isFinite(wordsToNumber(dec[2])) ? wordsToNumber(dec[2]) : parseFloat(dec[2])) : 0.5;
    adjust -= Number.isFinite(amt) ? amt : 0.5;
  }

  return { add, remove, toggle, score, adjust, clearAll };
}



function quant05(n){ return Math.max(0, Math.min(10, Math.round(n*2)/2)); }

// treat digits or number-words as numeric (e.g., "nine", "seven point five")
function isNumberish(s){
  const t = normalize(s);
  if(!t) return false;
  if(/^\d+(\.\d+)?$/.test(t)) return true;
  return Number.isFinite(wordsToNumber(t));
}


function detectFlagsMulti(tx){
  const found=new Set();
  const hits=[]; // {key,start,end}
  for (const f of FLAGS){
    for (const rx of (FLAG_RX[f.key] || [])){
      rx.lastIndex = 0;
      let m;
      while ((m = rx.exec(tx)) !== null){
        found.add(f.key);
      }
    }
    // position by variants (first occurrence)
    let best=null;
    for (const v of f.variants){
      const ix = tx.indexOf(v);
      if (ix>=0 && (best==null || ix<best.start)){
        best = {start:ix, end:ix+v.length};
      }
    }
    if (best) hits.push({ key:f.key, start:best.start, end:best.end });
  }
  hits.sort((a,b)=>a.start-b.start);
  return { keys:[...found], hits };
}

// Already have parseSquashedScores() from earlier; keep it as-is.
// Add this helper to choose the best interpretation per your rules.

function parseScoreListFlexible(s){
  const spaced   = extractNumberSequence(s);   // e.g., ["8.5","103","6.5"] → [8.5, 103, 6.5]
  const squashed = parseSquashedScores(s);     // e.g., "8.5 103 6.5" → [8.5, 10, 3, 6.5]

  // Heuristics: prefer squashed if it explains more numbers or fixes >10 artifacts.
  const spacedHasBig = spaced.some(n => n > 10.0);
  if (squashed.length > spaced.length || spacedHasBig){
    return squashed;
  }
  return spaced;
}


/* Parse utterance → intents + missed phrases (between hits) */
function parseUtterance(raw){
  const tx = applyAutoFixes(normalize(raw));
  const intents = {
    add:new Set(), remove:new Set(), toggle:new Set(),
    clearAll:false, score:null, adjust:0, batchScores:[]
  };

  if (/\bclear\s+flags?\b/.test(tx)) intents.clearAll = true;

  // ----- SCORES / BATCH DETECTION -----
  const afterCmd = tx.match(/\b(?:scores?|rating|set|make)\b([\s\S]*)$/)?.[1]?.trim() || '';

  if (afterCmd){
    const nums = parseScoreListFlexible(afterCmd);
    if (nums.length > 1){
      intents.batchScores = nums.map(n => quant05(Math.max(0, Math.min(10, n))));
    } else if (nums.length === 1){
      intents.score = quant05(nums[0]);
    }
  } else {
    // Pure-number utterance → may be a single score OR a squashed list
    const onlyDigitsDots = /^[\d.\s]+$/.test(tx);
    if (onlyDigitsDots){
      const nums = parseScoreListFlexible(tx);
      if (nums.length > 1){
        intents.batchScores = nums.map(n => quant05(Math.max(0, Math.min(10, n))));
      } else if (nums.length === 1){
        intents.score = quant05(nums[0]);
      }
    } else if (/^\d+(\.\d+)?$/.test(tx) || Number.isFinite(wordsToNumber(tx))){
      intents.score = quant05(wordsToNumber(tx));
    }
  }

  // ----- ADJUSTMENTS (+/- by X; defaults to 0.5) -----
  const inc = tx.match(/\b(increase|raise|up|\+|plus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  const dec = tx.match(/\b(decrease|lower|down|-|minus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  if (inc && !dec){
    const amt = inc[2] ? (Number.isFinite(wordsToNumber(inc[2])) ? wordsToNumber(inc[2]) : parseFloat(inc[2])) : 0.5;
    intents.adjust += Number.isFinite(amt) ? amt : 0.5;
  }
  if (dec && !inc){
    const amt = dec[2] ? (Number.isFinite(wordsToNumber(dec[2])) ? wordsToNumber(dec[2]) : parseFloat(dec[2])) : 0.5;
    intents.adjust -= Number.isFinite(amt) ? amt : 0.5;
  }

  // ----- FLAGS -----
  const { keys, hits } = detectFlagsMulti(tx);
  const isAdd    = /\b(add|flag|set)\b/.test(tx);
  const isRemove = /\b(remove|clear|unset|delete)\b/.test(tx);

  for (const k of keys){
    if (isRemove) intents.remove.add(k);
    else if (isAdd) intents.add.add(k);
    else intents.toggle.add(k);
  }

  // ----- ADDRESSed GROUPS (Mark/Blind N …) -----
  const groups = findAddressedGroups(tx).map(g => {
    const body = tx.slice(g.start, g.end);
    const parsed = parseGroupBody(body);
    return {
      kind: g.kind,
      index: g.index,
      start: g.start,
      end: g.end,
      add: parsed.add,
      remove: parsed.remove,
      toggle: parsed.toggle,
      score: parsed.score,
      adjust: parsed.adjust,
      clearAll: parsed.clearAll
    };
  });

  // ----- MISSED PHRASES -----
  const missed = (hits.length >= 2) ? inferMissedSegments(tx, hits) : inferMissedLoose(tx, hits);

  // DEBUG
  console.groupCollapsed('%cNLP', 'color:#0b74ff;font-weight:700');
  console.log('raw:', raw);
  console.log('normalized:', tx);
  console.log('groups:', groups.map(g => ({ kind:g.kind, index:g.index, span:[g.start,g.end] })));
  console.log('batchScores:', intents.batchScores);
  console.log('score:', intents.score, 'adjust:', intents.adjust, 'clearAll:', intents.clearAll);
  console.log('add:', Array.from(intents.add));
  console.log('remove:', Array.from(intents.remove));
  console.log('toggle:', Array.from(intents.toggle));
  console.groupEnd();

  return { intents, missed, hits, keys, groups };
}





/* Heuristic: segments between detected flags that still have meaningful tokens */
const STOPWORDS = /\b(?:and|then|uh|um|a|an|the|please|flag|set|add|give|tag|check|activate|remove|clear|unset|delete|drop|kill|unflag|by|to|at|on|in|into|onto|with|plus|as\s+well\s+as|along\s+with|together\s+with|for|from|about|around|like|as|score|rating|make|turn|minus|up|down|of|this|that|there|here|it|him|her|them|they|their|his|hers|just)\b/gi;


function cleanSegment(seg){
  return seg.replace(/[^a-z0-9.\s-]/g,' ').replace(/\s+/g,' ').replace(STOPWORDS,' ').replace(/\s+/g,' ').trim();
}
function inferMissedSegments(tx, hits){
  const out = [];
  if (!hits.length) return out;

  const sorted = hits.slice().sort((a,b)=>a.start - b.start);

  // HEAD (before first hit)
  {
    const first = sorted[0];
    const head = cleanSegment(tx.slice(0, first.start));
    if (head && !isNumberish(head)) {
      const suggestion = bestSuggestion(head);
      out.push({
        raw: head,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: null,
        rightKey: first.key
      });
    }
  }

  // BETWEEN hits
  for (let i = 0; i < sorted.length - 1; i++){
    const a = sorted[i], b = sorted[i+1];
    if (b.start <= a.end) continue;
    const mid = cleanSegment(tx.slice(a.end, b.start));
    if (mid && !isNumberish(mid)) {
      const suggestion = bestSuggestion(mid);
      out.push({
        raw: mid,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: a.key,
        rightKey: b.key
      });
    }
  }

  // TAIL (after last hit)
  {
    const last = sorted[sorted.length - 1];
    const tail = cleanSegment(tx.slice(last.end));
    if (tail && !isNumberish(tail)) {
      const suggestion = bestSuggestion(tail);
      out.push({
        raw: tail,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: last.key,
        rightKey: null
      });
    }
  }

  return dedupeMissed(out);
}

function dedupeMissed(arr){
  const seen=new Set(); const out=[];
  for (const x of arr){
    const k=x.raw.toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k); out.push(x);
  }
  return out;
}

// treat the whole utterance (0 hits) or edge segments (1 hit) as candidates
function inferMissedLoose(tx, hits){
  const out = [];
  const addCand = (raw, leftKey=null, rightKey=null) => {
    const cleaned = cleanSegment(raw);
    if (!cleaned) return;
    // ignore numbers-only like "7" or "7.5"
    if (isNumberish(cleaned)) return;

    const suggestion = bestSuggestion(cleaned);
    out.push({
      raw: cleaned,
      suggestKey: suggestion?.key || null,
      suggestLabel: suggestion?.label || null,
      leftKey, rightKey
    });
  };

  if (hits.length === 0) {
    // no flags detected -> whole utterance is a candidate
    addCand(tx);
    return dedupeMissed(out);
  }

  if (hits.length === 1) {
    const h = hits[0];
    const pre  = tx.slice(0, h.start);
    const post = tx.slice(h.end);
    addCand(pre, null, h.key);
    addCand(post, h.key, null);
    return dedupeMissed(out);
  }

  return out; // fallback – shouldn't happen here
}


/* Fuzzy suggestion (Levenshtein) to nearest canonical phrase */
function lev(a,b){
  const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}
function bestSuggestion(seg){
  let best=null; const s=seg.toLowerCase();
  for (const f of FLAGS){
    for (const v of f.variants){
      const d = lev(s, v);
      const sim = 1 - d / Math.max(s.length, v.length);
      if (!best || sim > best.sim) best = { key:f.key, label:f.label, sim };
    }
  }
  return (best && best.sim >= 0.55) ? best : null; // threshold
}

let DOG_NAMES = [];
let selectedDog = localStorage.getItem('selectedDog') || null;
const dogNameEl = document.getElementById('dogName');
const dogHintEl = document.getElementById('dogHint');
const dogMicBtn = document.getElementById('dogMic');

// show persisted selection on load
if (selectedDog) dogNameEl.textContent = selectedDog;

// pull all names from every `layouts/*` doc you’re already writing in trailer.html
async function fetchDogNames(){
  const snap = await db.collection('layouts').get();
  const bucket = [];
  snap.forEach(doc => {
    const d = doc.data() || {};
    if (Array.isArray(d.masterNames)) bucket.push(...d.masterNames);
    if (Array.isArray(d.dockNames))   bucket.push(...d.dockNames);
    if (d.slotData && typeof d.slotData === 'object') {
      bucket.push(...Object.values(d.slotData).filter(Boolean));
    }
  });
  // unique + cleaned + sorted
  DOG_NAMES = [...new Set(bucket.map(n => String(n).trim()).filter(Boolean))]
               .sort((a,b)=>a.localeCompare(b));
  dogHintEl.textContent = DOG_NAMES.length
    ? `Say a name (${DOG_NAMES.length} loaded)`
    : `No names found in Firestore layouts`;
}
fetchDogNames().catch(err=>{
  console.error(err);
  dogHintEl.textContent = 'Failed to load names';
});

// similarity helper using your existing lev()
function sim(a,b){
  const A = normalize(a), B = normalize(b);
  if (!A || !B) return 0;
  const d = lev(A,B);
  return 1 - d / Math.max(A.length, B.length);
}

// find the best dog name for a transcript
function matchDogName(heard){
  const q = normalize(heard);
  if (!q) return null;

  // 1) exact token contain check (fast path)
  let exact = DOG_NAMES.find(n => q.includes(normalize(n)));
  if (exact) return exact;

  // 2) highest similarity
  let best = null;
  for (const n of DOG_NAMES){
    const s = sim(q, n);
    if (!best || s > best.s) best = { n, s };
  }
  // require a reasonably strong match
  return (best && best.s >= 0.72) ? best.n : null;
}

function setSelectedDog(name){
  selectedDog = name;
  dogNameEl.textContent = name;
  localStorage.setItem('selectedDog', name);

  cancelPendingSaves();        // ← NEW: stop any in-flight writes from previous dog
  closePeek?.();               // optional: avoids showing stale flags while switching
  closeMissed?.();             // optional

  document.dispatchEvent(new CustomEvent('dog:selected', { detail: { name } }));
  // NEW: publish to shared session so all devices follow along
  const sref = sessionDocRef();
  if (sref){
    sref.set({
      selectedDog: name,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      source: currentUser || 'anon'
    }, { merge:true }).catch(console.error);
  }
}

// We’ll reuse your existing SpeechRecognition instance `rec`
let dogListenActive = false;

// attach the button
if (dogMicBtn){
  dogMicBtn.addEventListener('click', ()=>{
    if (!rec){ alert('Speech API not supported'); return; }
    try{ rec.abort(); }catch{}
    dogListenActive = true;
    // optional little UI cue
    dogMicBtn.classList.add('listening');
    setStatus('listening… (dog name)');
    rec.start();
  });
}

// Parse smooshed digit runs like "108.57.56" or "10835"
// Rules: (1) only "10" is two-digit, (2) decimals are ".5" only, else single digits.
function parseSquashedScores(str){
  // normalize, keep only digits and dots, make "point" a dot
  let s = normalize(str)
    .replace(/point/g, '.')      // spoken "point"
    .replace(/[^\d.]/g, '')      // keep 0-9 and .
    .replace(/\.+/g, '.');       // collapse accidental multiple dots

  if (!s) return [];

  const out = [];
  let i = 0;
  while (i < s.length){
    const ch = s[i];

    if (ch === '.'){ i++; continue; } // skip stray separators

    // "10" is the only two-digit number
    if (ch === '1' && s[i+1] === '0'){
      out.push(10); i += 2; continue;
    }

    // single digit
    if (/\d/.test(ch)){
      const d = ch.charCodeAt(0) - 48;

      // optional ".5" right after → halves only
      if (s[i+1] === '.'){
        if (s[i+2] === '5'){ out.push(d + 0.5); i += 3; continue; }

        // if some other decimal sneaks in, round to the closest half policy
        if (/\d/.test(s[i+2])){
          const dec = s[i+2].charCodeAt(0) - 48;
          out.push(d + (dec >= 5 ? 0.5 : 0));
          i += 3; continue;
        }
      }

      out.push(d); i += 1; continue;
    }

    i++; // safety
  }
  return out;
}


// Update the legacy list row UI (chips + tiny score) and keep stage in sync
function syncRow(it){
  const row = document.getElementById('row-' + it.id);
  if (!row) { 
    // still keep the stage/badge in sync even if the row list is hidden
    syncStageForItem?.(it);
    return; 
  }

  // chips
  row.querySelectorAll('.chip').forEach(ch => {
    const key = ch.dataset.key;
    ch.classList.toggle('on', !!(it.flags && it.flags[key]));
  });

  // tiny slider + score in the row (the list view is hidden but still present)
  const slider = row.querySelector('input[type="range"]');
  if (slider) slider.value = it.score ?? 0;

  const scoreEl = row.querySelector('.score');
  if (scoreEl) scoreEl.textContent = (it.score ?? 0).toFixed(1);

  // also update the big visible badge in the active pane
  syncStageForItem?.(it);
}



/* ---------------- Apply to row, then surface missed overlay + logging ---------------- */
function quantClamp(n){ return Math.max(0, Math.min(10, n)); }

// Update the on-screen pane (Mark or Blind) without re-rendering the whole stage
function syncStageForItem(it){
  const type = it.kind === 'Mark' ? 'mark' : 'blind';
  const slot = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if (!slot) return;

  // If an animation left 2 panes in the slot, take the topmost (last)
  const panes = slot.querySelectorAll('.pane');
  const pane = panes[panes.length - 1] || panes[0];
  if (!pane) return;

  const rangeEl  = pane.querySelector('input[type="range"]');
  const legacyEl = pane.querySelector('.score');       // hidden by CSS
  const badgeEl  = pane.querySelector('.scoreBadge');  // the big visible number

  if (rangeEl)  rangeEl.value = it.score;
  if (legacyEl) legacyEl.textContent = it.score.toFixed(1);
  if (badgeEl)  badgeEl.textContent  = it.score.toFixed(1);
}


function refreshVisiblePane(type){
  const isMark = (type === 'mark');
  const list   = items.filter(it => it.kind === (isMark ? 'Mark' : 'Blind'));
  if (!list.length) return;

  const idx  = isMark ? idxMark : idxBlind;
  const slot = ensureSlot(type);

  const newPane = renderPane(isMark ? 'Mark' : 'Blind', list[idx], list.length, type);
  const oldPane = slot.querySelector('.pane');
  if (oldPane) slot.replaceChild(newPane, oldPane);
  else slot.appendChild(newPane);
}

function refreshStage(){
  refreshVisiblePane('mark');
  refreshVisiblePane('blind');
}



function applyTranscript(itemId, raw){
  const it = items.find(x => x.id === itemId);
  if (!it) return;

  const parsed = parseUtterance(raw);
  const { intents, missed, groups } = parsed;

  // ----- Addressed group path (“Mark 3 …”, “Blind 2 …”) -----
  if (groups && groups.length){
    let applied = 0;
    const labels = [];

    for (const g of groups){
      const lane = items.filter(x => x.kind === g.kind);
      const target = lane[g.index - 1];  // 1-based spoken index

      if (!target){
        showToast(`No ${g.kind} #${g.index}`, { type:'error', duration: 1800 });
        continue;
      }

      if (g.clearAll) target.flags = {};
      g.add.forEach(k    => { target.flags[k] = true; });
      g.remove.forEach(k => { target.flags[k] = false; });
      g.toggle.forEach(k => { target.flags[k] = !target.flags[k]; });

      if (Number.isFinite(g.score)) target.score = g.score;
      if (g.adjust) target.score = quant05(quantClamp((target.score ?? 0) + g.adjust));

      syncRow(target);
      debouncedSaver(target.id)();
      applied++;
      labels.push(`${g.kind} #${g.index}`);
    }

    if (applied){
      refreshStage();
      showToast('✅ Applied to specific slots', {
        type:'success',
        size:'xxl',
        sub: labels.join(' • '),
        duration: 2600
      });
    }

    // We handled everything addressed; do not continue into the single/batch logic.
    return;
  }

  // ----- Batch scoring path (applies to the current pane onward) -----
  if (intents.batchScores && intents.batchScores.length){
    const start = it;
    const kind  = start.kind; // 'Mark' or 'Blind'
    const list  = items.filter(x => x.kind === kind);
    const startIdx = list.findIndex(x => x.id === itemId);

    let applied = 0;
    for (let i = 0; i < intents.batchScores.length; i++){
      const idx = startIdx + i;
      if (idx >= list.length) break;
      const target = list[idx];
      const v = quant05(Math.max(0, Math.min(10, intents.batchScores[i])));
      target.score = v;
      syncRow(target);
      debouncedSaver(target.id)();
      applied++;
    }

    refreshStage(); // keep UI in sync with the visible pane(s)

    return {
      batchApplied: applied,
      batchKind: kind,
      batchFrom: list[startIdx]?.title || '',
      batchTo: list[startIdx + Math.max(0, applied-1)]?.title || '',
      score: list[startIdx]?.score ?? null,
      added: [], removed: [], setScore: false, adjust: 0
    };
  }

  // ----- Normal single-item path (flags, single score, adjust, missed) -----
  const before = snapshotFlags(it);



  if (missed.length && (!intents.add.size && !intents.remove.size && !intents.toggle.size)){
    setStatus('No flags matched; queued ' + missed.length + ' missed phrase(s).');
  }

  if (intents.clearAll) it.flags = {};

  intents.add.forEach(k => it.flags[k] = true);
  intents.remove.forEach(k => it.flags[k] = false);
  intents.toggle.forEach(k => it.flags[k] = !it.flags[k]);

  if (Number.isFinite(intents.score)) it.score = intents.score;
  if (intents.adjust !== 0) it.score = quant05(it.score + intents.adjust);
  it.score = quantClamp(it.score);

  syncRow(it);
  syncStageForItem(it); // instantly reflect score on the visible pane
  debouncedSaver(itemId)();

  if (missed.length){
    for (const m of missed){
      addMissed(itemId, it.title, m.raw, m.suggestKey, m.suggestLabel);
      logUnassigned(m.raw);
    }
    renderMissedOverlay();
  }

  const after = snapshotFlags(it);
  const changed = diffFlags(before, after);

  return {
    added: changed.added,
    removed: changed.removed,
    setScore: Number.isFinite(intents.score),
    adjust: intents.adjust || 0,
    score: it.score
  };
}


function snapshotFlags(it){
  const on = Object.entries(it.flags||{}).filter(([k,v])=>!!v).map(([k])=>k);
  return { on: new Set(on) };
}
function diffFlags(before, after){
  const b=[...before.on], a=[...after.on];
  const added = a.filter(k=>!before.on.has(k));
  const removed = b.filter(k=>!new Set(a).has(k));
  // treat simple toggles as added for our purposes:
  return { added, removed, toggled: added };
}

/* ---------------- Missed overlay state ---------------- */
const missedOverlay = document.getElementById('missedOverlay');
const missedListEl = document.getElementById('missedList');
document.getElementById('missedClose').addEventListener('click', ()=> closeMissed());
document.getElementById('missedClear').addEventListener('click', ()=> { missedItems.length=0; renderMissedOverlay(); });

let missedItems = []; // { itemId, rowTitle, phrase, suggestKey?, suggestLabel? }
function addMissed(itemId, rowTitle, phrase, suggestKey, suggestLabel){
  const key = `${itemId}||${phrase.toLowerCase()}`;
  if (missedItems.some(x => `${x.itemId}||${x.phrase.toLowerCase()}`===key)) return;
  missedItems.push({ itemId, rowTitle, phrase, suggestKey, suggestLabel });
}
function removeMissed(itemId, phrase){
  missedItems = missedItems.filter(x => !(x.itemId===itemId && x.phrase.toLowerCase()===phrase.toLowerCase()));
}
function openMissed(){ 
  document.documentElement.classList.add('overlay-open');
  missedOverlay.classList.add('open'); 
  missedOverlay.setAttribute('aria-hidden','false'); 
}
function closeMissed(){ 
  missedOverlay.classList.remove('open'); 
  missedOverlay.setAttribute('aria-hidden','true'); 
  if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
}

function renderMissedOverlay(){
  missedListEl.innerHTML = '';
  if (!missedItems.length){ closeMissed(); return; }

  for (const m of missedItems){
    const row = document.createElement('div'); row.className='missed-item';
    const meta = document.createElement('div'); meta.className='missed-meta';
    meta.innerHTML = `
      <div class="missed-phrase">${m.phrase}</div>
      <div class="missed-row">Row: ${m.rowTitle}</div>
      ${m.suggestLabel ? `<div class="hint">Did you mean <b>${m.suggestLabel}</b>?</div>` : ''}
    `;
    const actions = document.createElement('div'); actions.className='missed-actions';
    const mic = document.createElement('button'); mic.className='btn small'; mic.innerHTML='🎤 Say again';
    mic.addEventListener('click', ()=> startFixListening(m.itemId, m.phrase, m.suggestKey||null));
    actions.appendChild(mic);

    if (m.suggestKey){
  const quick = document.createElement('button'); quick.className='btn small primary';
  quick.textContent = `✓ Apply ${m.suggestLabel}`;
  quick.addEventListener('click', ()=>{
    const it = items.find(x=>x.id===m.itemId); if (!it) return;
    it.flags[m.suggestKey] = true;
    const canon = canonicalPhraseForKey(m.suggestKey);
    if (canon) addAutoFix(m.phrase, canon);      // ← persist future auto-fix

    debouncedSaver(it.id)();
    syncRow(it);
    removeMissed(m.itemId, m.phrase);
    renderMissedOverlay();
  });
  actions.appendChild(quick);
}


    const dismiss = document.createElement('button'); dismiss.className='btn small';
    dismiss.textContent='Dismiss';
    dismiss.addEventListener('click', ()=>{ removeMissed(m.itemId, m.phrase); renderMissedOverlay(); });
    actions.appendChild(dismiss);

    row.append(meta, actions);
    missedListEl.appendChild(row);
  }
  openMissed();
}

/* ---------------- Master unassigned log (localStorage) ---------------- */
const LOG_KEY = 'speech_unassigned_log_v1';
function readLog(){ try{ return JSON.parse(localStorage.getItem(LOG_KEY)||'[]'); }catch{return[];} }
function writeLog(arr){ localStorage.setItem(LOG_KEY, JSON.stringify(arr)); }
function logUnassigned(phrase){
  const p = phrase.toLowerCase();
  const arr = readLog();
  const idx = arr.findIndex(x=>x.phrase===p);
  if (idx>=0){ arr[idx].count += 1; arr[idx].last = Date.now(); }
  else { arr.push({ phrase:p, count:1, last:Date.now() }); }
  writeLog(arr);
}
function clearLog(){ writeLog([]); }
function renderLog(){
  const listEl = document.getElementById('logList');
  listEl.innerHTML='';
  const arr = readLog().sort((a,b)=>b.count-a.count);
  if (!arr.length){
    const empty = document.createElement('div'); empty.className='hint'; empty.textContent='No data yet.';
    listEl.appendChild(empty); return;
  }
  arr.forEach(x=>{
    const row = document.createElement('div'); row.className='log-item';
    const left = document.createElement('div'); left.innerHTML = `<strong>${x.phrase}</strong>`;
    const right = document.createElement('div'); right.innerHTML = `<span class="count">${x.count}</span>`;
    row.append(left, right); listEl.appendChild(row);
  });
}

document.getElementById('viewLogBtn').addEventListener('click', ()=>{
  renderLog();
  document.documentElement.classList.add('overlay-open');
  logOverlay.classList.add('open');
});
document.getElementById('logClose').addEventListener('click', ()=>{
  logOverlay.classList.remove('open');
  if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
});

const logOverlay = document.getElementById('logOverlay');

function showUserOverlay(){
  const ov = document.getElementById('userOverlay');
  ov.classList.add('open'); ov.setAttribute('aria-hidden','false');
  document.documentElement.classList.add('overlay-open');
  ov.querySelectorAll('button[data-user]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      currentUser = btn.dataset.user;
      localStorage.setItem('currentUser', currentUser);
      ov.classList.remove('open'); ov.setAttribute('aria-hidden','true');
      if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
      bootAfterUser();
    }, { once:true });
  });
}

function bootAfterUser(){
  // currentUser is already set by the overlay
  loadTodaysSetup(); // ← no need to pass trainer/setupOrder unless overriding
}


// Boot:
if (currentUser){
  bootAfterUser();
} else {
  showUserOverlay();
}



/* ---------------- Clear all ---------------- */
document.getElementById('clearBtn').addEventListener('click',()=>{
  items.forEach(it=>{
    it.flags = {};
    it.score = 0;
    syncRow(it);
    debouncedSaver(it.id)();          // persist resets per item
  });
  missedItems.length = 0;
  renderMissedOverlay();
  renderStage();
  refreshStage();
  setStatus('cleared');
});

</script>
<div id="toasts" class="toasts" aria-live="polite" aria-atomic="true"></div>

</body>
</html>
rder:#e4e7ec;
    --danger:#ef4444; --ok:#16a34a;
  }
  * { box-sizing: border-box; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:#101828;}
  header{padding:20px 24px 8px;}
  h1{margin:0 0 6px;font-size:28px;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:14px}
  .wrap{padding:0 24px 24px;max-width:1100px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 1px 2px rgba(16,24,40,.04)}
  .items{display:flex;flex-direction:column;gap:14px}
  .row{display:grid;grid-template-columns:minmax(160px,260px) 1fr auto;gap:14px;align-items:center;padding:12px;border:1px solid var(--border);border-radius:14px;background:#fafafa}
  .kind{font-size:12px;font-weight:800;color:#344054}
  .title{font-size:16px;font-weight:800}
  /* FLAGS AREA → responsive columns */
  .chips{
    display:grid; gap:8px;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    align-items:start;
  }
  .chip{border:1px solid #d0d5dd;background:#fff;border-radius:999px;padding:6px 10px;font-size:13px;user-select:none;display:block}
  .chip.on{background:#eef4ff;border-color:#c7d7fe}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  
  .row.listening .mic{border-color:#ffb4b4;box-shadow:0 0 0 4px rgba(255,59,48,.12)}
  .row.listening .mic .dot{background:#ff3b30;animation:pulse 1s infinite alternate}
  @keyframes pulse{from{transform:scale(.9)}to{transform:scale(1.2)}}
  input[type=range]{width:220px}
  .score{font-weight:800;min-width:44px;text-align:right;font-variant-numeric:tabular-nums}
  .bar{display:flex;gap:10px;align-items:center;padding:0 24px 12px;flex-wrap:wrap}
  .status{color:var(--muted);font-weight:700}
  .btn{appearance:none;border:1px solid var(--border);background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  .btn.ghost{background:#fff}
  .btn.small{padding:6px 8px;border-radius:8px;font-size:12px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:12px}
  .pill.ok{border-color:#c7f1d9;background:#ecfdf5;color:#065f46}
  .pill.bad{border-color:#ffd5d5;background:#fff1f1;color:#7f1d1d}
/* Hide the old grid; voice still toggles in the background */
.chips{ display:none; }

/* Red circle “flag” button — bigger default + explicit BIG variant */
.flagBtn{
  width:64px; height:64px; border-radius:999px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#FFFFFF; border:none; cursor:pointer;
  box-shadow:0 14px 28px rgba(239,68,68,.35);
  touch-action:none; /* enables swipe tracking on mobile */
  font-size:26px; font-weight:900;
}
.flagBtn.big{
  width:76px; height:76px;
  font-size:32px;
  box-shadow:0 18px 38px rgba(239,68,68,.35);
}
.flagBtn:active{ transform:translateY(1px); }


/* Peek overlay: big, easy-to-read list */

.peek-head{font-weight:800; font-size:14px; color:#475467; margin-bottom:8px}
.peek-list{display:flex; flex-direction:column; gap:12px; margin:10px 0 6px}
.peek-flag{font-size:22px; font-weight:800; padding:8px 12px; border-radius:12px;
  background:#f8fafc; border:1px solid #e5e7eb}

/* Pull-to-clear zone at bottom of the card */
.pull-zone{position:relative; height:64px; border-radius:12px; overflow:hidden;
  background:#fafafa; border:1px dashed #e5e7eb; margin-top:8px}
.pull-bar{position:absolute; left:0; top:0; width:100%; height:0;
  background:rgba(239,68,68,.25); transition:height .1s linear}
.pull-zone.ready .pull-bar{ background:rgba(239,68,68,.45); }
.pull-zone.cleared{ background:#fee2e2; border-color:#fecaca; }
.pull-label{position:relative; z-index:1; line-height:64px; font-weight:800; color:#7f1d1d}


  /* Overlay (missed phrases) */
  
  .overlay.open{display:flex;}
  
  .sheet-head{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--border)}
  .sheet-body{padding:12px 16px;display:flex;flex-direction:column;gap:10px}
  .missed-item{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:12px}
  .missed-meta{display:flex;flex-direction:column;gap:4px}
  .missed-phrase{font-weight:800}
  .missed-row{color:#475467;font-size:12px}
  .missed-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sheet-foot{padding:12px 16px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end}
  .hint{color:#475467;font-size:12px}

  /* Overlay (master log) */
  .log-list{display:flex;flex-direction:column;gap:8px}
  .log-item{display:flex;justify-content:space-between;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:10px}
  .count{font-variant-numeric:tabular-nums;font-weight:800}
  
  /* Kill native long-press callout + text selection where we hold */
.flagBtn,
#peekOverlay,
#peekOverlay *,
.mic,
.row {
  -webkit-touch-callout: none; /* iOS copy/paste bubble */
  -webkit-user-select: none;
  user-select: none;
}

.flagBtn,
.peek { touch-action: none; } /* prevent native gestures during hold */

/* --- Large, swipeable stage showing 1 Mark + 1 Blind --- */
.items { display:none; }            /* hide old list view on this test page */
.stage {
  display: grid;
  gap: 14px;
}
.pane {
  background:#fff;
  border:1px solid var(--border);
  border-radius:16px;
  box-shadow:0 1px 2px rgba(16,24,40,.04);
  padding:16px;
  min-height: 36vh;                 /* nice big touch target area */
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  touch-action: pan-y;              /* allow vertical scrolling; we handle horizontal */
}
/* Bigger Mark/Blind label */
.pane-head .kind { font-size:22px; font-weight:900; color:#475467; }
/* tiny spacing tweak so the bigger label breathes */
.pane-head .title{ font-size:24px; font-weight:900; margin-top:4px; }


.pane-controls{ display:flex; align-items:center; gap:12px; flex-wrap:wrap }

.score.big { font-size:24px; font-weight:900; min-width:56px; text-align:right; }

.navBtn{
  appearance:none; border:1px solid var(--border); background:#fff;
  width:46px; height:46px; border-radius:12px; cursor:pointer; font-size:20px; font-weight:800;
}
.navBtn:active{ transform:translateY(1px); }

.pager{ margin-left:auto; display:flex; gap:6px; align-items:center }
.dot{ width:8px; height:8px; border-radius:50%; background:#d0d5dd }
.dot.on{ background:#0b74ff }

/* Stretch the range to breathe on mobile */
.pane input[type=range]{
  flex:1 1 240px; min-width:180px;
}
/* --- Swipe slide animation --- */
.stage { position: relative; }                /* anchor absolute panes */
.pane-slot{
  position: relative;                         /* local stacking for each slot */
  min-height: 36vh;                           /* match pane's min-height */
}
.pane{
  position: absolute; inset: 0;
  transition: transform .28s ease, opacity .28s ease;
  transform: translateX(0); opacity: 1;
  will-change: transform, opacity;
}

.pane.enter-from-right { transform: translateX(100%); opacity: 0; }
.pane.enter-from-left  { transform: translateX(-100%); opacity: 0; }
.pane.exit-to-left     { transform: translateX(-100%); opacity: 0; }
.pane.exit-to-right    { transform: translateX(100%);  opacity: 0; }


/* allow vertical scroll; we'll handle horizontal swipes */
.mic { touch-action: pan-y; }


.mic{
  display:inline-flex;align-items:center;gap:10px;
  padding:12px 14px;border-radius:999px;background:#fff;border:1px solid #d0d5dd;
  cursor:pointer;font-weight:800;font-size:16px;min-height:44px
  
}
.mic .dot{width:12px;height:12px;border-radius:50%;background:#94a3b8}
.mic.big{ font-size:22px; padding:16px 18px; min-height:56px }
.mic.big .dot{ width:16px; height:16px }

#peekOverlay { touch-action: none; }

/* Overlay container */
.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center;
  z-index:9999;

  /* keep content inside the viewport even with outer padding */
  padding:16px;
  /* notch-safe padding on iOS */
  padding-left: max(16px, env(safe-area-inset-left));
  padding-right:max(16px, env(safe-area-inset-right));
  padding-top:  max(16px, env(safe-area-inset-top));
  padding-bottom:max(16px, env(safe-area-inset-bottom));
}

/* Flags peek card */
.peek{
  /* width that *always* fits inside overlay padding */
  width: min(420px, calc(100dvw - 32px));
  /* prevent vertical overflow off-screen */
  max-height: calc(100dvh - 32px);
  overflow:auto;

  background:#fff; border:1px solid var(--border);
  border-radius:16px; padding:16px; text-align:center;
  box-shadow:0 20px 50px rgba(0,0,0,.25);
}

/* Missed/log sheet */
.sheet{
  width: min(720px, calc(100dvw - 32px));
  max-height: calc(100dvh - 32px);
  overflow:auto;

  background:#fff; border:1px solid var(--border);
  border-radius:16px; box-shadow:0 20px 50px rgba(0,0,0,.25);
}

/* Keep peek draggable; keep sheets scrollable */
#peekOverlay { touch-action: none; }
#missedOverlay, #logOverlay { touch-action: pan-y; }


html.overlay-open, body.overlay-open { overflow: hidden; }

/* Keep slide animations from ever expanding layout width */
.stage,
.pane-slot { overflow: hidden; }

/* Belt-and-suspenders: never allow horizontal page growth */
html, body { max-width: 100%; overflow-x: hidden; overscroll-behavior-x: none; }

/* Controls can wrap, but children must be allowed to shrink */
.pane-controls > * { min-width: 0; }

/* Pager shouldn't force the row wider than the screen */
.pager { min-width: 0; flex: 0 1 auto; overflow: hidden; }

/* ——— Home screen refresh (mobile-first, high-contrast) ——— */

/* Tweak base card padding and shadow for depth */
.wrap { padding: 12px 16px 24px; }
.card { border-radius: 18px; box-shadow: 0 10px 30px rgba(16,24,40,.08); }

/* Dog card: subtle gradient with large name */
#dogCard {
  background: linear-gradient(180deg, #ffffff 0%, #f6f8ff 100%);
  border: 1px solid #e7ecff;
  box-shadow: 0 8px 26px rgba(11,116,255,.10);
}
#dogCard .pane-head .kind { font-size: 18px; letter-spacing:.3px; color:#0b74ff; }
#dogCard .pane-head .title { font-size: 28px; font-weight:900; margin-top:6px; }

/* Stage panes — cleaner surface */
.pane {
  border: 1px solid #e7ecff;
  border-radius: 18px;
  background: #ffffff;
  box-shadow: 0 10px 30px rgba(16,24,40,.06);
  padding: 16px 14px 18px;
}

/* Pane header: bigger label + title */
.pane-head .kind   { font-size: 18px; font-weight:900; color:#0b74ff; }
.pane-head .title  { font-size: 22px; font-weight:900; color:#0f172a; margin-top:4px; }

/* Control row: space things nicely on small screens */
.pane-controls { gap: 12px; flex-wrap: wrap; align-items: center; }

/* Giant mic button (pill) */
.mic.big{
  border: 0;
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%);
  box-shadow: 0 10px 24px rgba(11,116,255,.20);
  padding: 14px 18px;
  border-radius: 999px;
  font-size: 20px;
}
.mic.big .dot{ width:14px; height:14px; background:#0b74ff; }

/* Giant red flag button */
.flagBtn.big{
  width: 84px; height: 84px; font-size: 34px;
  border: 0;
  box-shadow: 0 20px 44px rgba(239,68,68,.40);
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 65%, #ffecec 100%);
}

/* Score cluster (new): big ± buttons + badge */
.scoreWrap{
  display:flex; align-items:center; gap:10px;
  margin-left:auto; /* push toward the right by default */
}
.scoreBtn{
  width:58px; height:58px; border-radius:14px;
  border:1px solid #dbe3ff; background:#fff; font-size:28px; font-weight:900;
  box-shadow: 0 10px 22px rgba(16,24,40,.10);
}
.scoreBadge{
  min-width:94px; padding:6px 10px; text-align:center;
  border-radius:14px; border:1px solid #dbe3ff;
  background: #f5f8ff; font-size:36px; font-weight:900;
  font-variant-numeric: tabular-nums;
}

/* Keep the old slider + score around but invisible so existing code still works */
.pane input[type=range].visually-hidden { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
.pane .score { display:none; }

/* Pager dots: cleaner + slightly larger for visibility */
.pager { margin-left:0; gap:8px; }
.pager .dot{ width:10px; height:10px; background:#e2e8f0; }
.pager .dot.on{ background:#0b74ff; }

/* Anti-width-creep: never let swipes or long controls expand the page */
.stage, .pane-slot { overflow:hidden; }
html, body { max-width:100%; overflow-x:hidden; overscroll-behavior-x:none; }
.pane-controls > * { min-width:0; }
.pager { min-width:0; flex:0 1 auto; overflow:hidden; }





/* ——— Rhombus buttons with rounded corners ——— */
/* Works for the big red flag and big mic. No markup changes needed. */

.flagBtn.big,
.mic.big{
  position: relative;
  isolation: isolate;       /* keeps the shadow/overlay tidy */
  background: transparent;  /* the shape comes from ::before */
  border: 0;
}

/* Shared “diamond” skin */
.flagBtn.big::before,
.mic.big::before{
  content: "";
  position: absolute;
  left: 50%; top: 50%;
  width: 100%; height: 100%;
  transform: translate(-50%,-50%) rotate(45deg) scale(var(--rhombus-scale, .86));
  border-radius: 18px;        /* rounded rhombus corners */
  pointer-events: none;       /* clicks go to the button */
}

/* Size & typography (accessible) */
.flagBtn.big{
  width: 92px; height: 92px;             /* large touch target */
  font-size: 34px; font-weight: 900;
  --rhombus-scale: .86;
}
.mic.big{
  /* responsive long rhombus */
  width: min(88vw, 280px);
  height: 92px;
  padding: 0 10px;                        /* space for label */
  font-size: 22px; font-weight: 900; line-height: 1;
  display: inline-flex; align-items: center; justify-content: center;
  gap: 10px;
  color: #0b74ff;
  --rhombus-scale: .90;
}

/* Inner dot stays normal (not rotated) */
.mic.big .dot{ width:16px; height:16px; background:#0b74ff; }

/* Colorways + depth */
.flagBtn.big::before{
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%);
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset;
}
.mic.big::before{
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%);
  box-shadow: 0 18px 40px rgba(11,116,255,.25), 0 0 0 1px #e7ecff inset;
}

/* Press + focus states */
.flagBtn.big:active::before,
.mic.big:active::before{
  transform: translate(-50%,-50%) rotate(45deg) scale(calc(var(--rhombus-scale, .86) * .97));
}
.flagBtn.big:focus-visible::before,
.mic.big:focus-visible::before{
  box-shadow:
    0 0 0 4px rgba(11,116,255,.25),
    0 18px 40px rgba(11,116,255,.25),
    0 0 0 1px #e7ecff inset;
  outline: none;
}

/* Keep layout from “growing” during transforms */
.flagBtn.big, .mic.big { overflow: visible; }

/* --- Fix diamond overflow on big buttons --- */

/* Keep the ::before square the size of the button's height */
.flagBtn.big { --btn-h: 92px; width: var(--btn-h); height: var(--btn-h); } /* stays square */
.mic.big     { --btn-h: 92px; height: var(--btn-h); }                      /* already 92px tall */

.mic.big::before{
  /* was width:100%; height:100%; — that caused the diagonal blade */
  width: var(--btn-h);
  height: var(--btn-h);
}

/* Ensure the diamond sits behind the content, not above neighbors */
.flagBtn.big::before,
.mic.big::before{
  z-index: -1;              /* behind the emoji/text */
}

/* Safety: confine any remaining overflow to the button box */
.flagBtn.big, .mic.big {
  overflow: clip;
}
@supports not (overflow: clip){
  .flagBtn.big, .mic.big { overflow: hidden; } /* Safari fallback */
}


/* --- Clean up legacy shapes & set final button geometry --- */

/* 1) FLAG: keep the diamond, remove the old circular button behind it */
.flagBtn.big{
  background: transparent !important;   /* no white circle */
  border: 0 !important;
  border-radius: 0 !important;          /* removes circular silhouette */
  box-shadow: none !important;          /* shadow comes from ::before */
  width: 92px; height: 92px;            /* square hit area */
  position: relative; isolation: isolate;
  overflow: clip;
}
@supports not (overflow: clip){ .flagBtn.big{ overflow: hidden; } }

/* Ensure the diamond stays the only visual */
.flagBtn.big::before{
  content:"";
  position:absolute; inset:0;
  margin:auto;
  width: 92px; height: 92px;            /* square, then rotate */
  transform: rotate(45deg);
  border-radius: 18px;
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%);
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset;
  z-index:-1;
}

/* 2) MIC: straight rounded rectangle, no diamond */
.mic.big{
  /* override the old pill */
  border-radius: 18px !important;
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%) !important;
  border: 1px solid #dbe3ff !important;
  box-shadow: 0 10px 24px rgba(11,116,255,.18);
  color:#0b74ff; font-weight:900; font-size:20px;

  height: 92px;
  min-width: clamp(220px, 80vw, 340px); /* room for dot + “Listen” */
  padding: 0 18px;
  display:inline-flex; align-items:center; justify-content:center; gap:12px;

  background-clip: padding-box;
}
.mic.big::before{ content:none !important; }   /* kill the rhombus layer */
.mic.big .dot{ width:16px; height:16px; background:#0b74ff; border-radius:50%; }

/* Press/focus states */
.mic.big:active{ transform: translateY(1px); }
.mic.big:focus-visible{
  outline: none;
  box-shadow:
    0 0 0 4px rgba(11,116,255,.25),
    0 10px 24px rgba(11,116,255,.18);
}


/* 3) Optional: if you truly want the mic to be a 1:1 square,
   add class="mic big square" in the HTML. */
.mic.big.square{
  width: 92px; min-width: 92px; padding:0; gap:0;
  justify-content:center;
  text-indent: -9999px;                 /* hide "Listen" text visually */
}
.mic.big.square::after{
  content: "🎤";
  text-indent: 0; font-size: 32px; line-height: 1;
}
.mic.big.square .dot{ display:none; }

/* --- FIX: keep the flag rhombus from being cut off --- */
.flagBtn.big{
  /* Make the rotated square fit entirely inside the 92×92 button */
  --rhombus-scale: .70;                  /* ~1/√2 ≈ .707; .70 gives a little breathing room */
  background: transparent !important;    /* no legacy circle */
  border: 0 !important;
  box-shadow: none !important;           /* depth comes from ::before */
  overflow: visible;                      /* safe: shape now fits; shadow can breathe */
}

/* Ensure we use the centered + scaled transform (override any earlier/later rule) */
.flagBtn.big::before{
  width: 100% !important;
  height: 100% !important;
  left: 50% !important;
  top: 50% !important;
  transform: translate(-50%, -50%) rotate(45deg) scale(var(--rhombus-scale)) !important;
  border-radius: 18px !important;
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%) !important;
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset !important;
  z-index: -1;
}

/* Keep the mic as a plain rounded rectangle (no diamond layer) */
.mic.big::before{ content: none !important; }


/* Keep your diamond exactly as-is via ::before.
   Center the flag glyph visually via ::after. */
.flagBtn.big{
  display: inline-grid;              /* easy centering */
  place-items: center;
  font-size: 0;                      /* hide the raw emoji text node */
  --icon-x: 6px;                     /* tweak these if needed */
  --icon-y: -35px;
}

.flagBtn.big::after{
  content: "🚩";
  font-size: 36px;                   /* size of the glyph */
  line-height: 1;
  transform: translate(var(--icon-x), var(--icon-y));
  pointer-events: none;
  z-index: 0;                        /* above ::before (which is z:-1) */
}

  /* Header becomes a 2-column bar: titles on the left, flag on the right */
.pane-head{
  display:grid;
  grid-template-columns: 1fr auto;
  align-items:center;
  gap:12px;
  padding-bottom:6px;                 /* tightens vertical spacing */
}

/* Right-side action area for the flag */
.pane-actions{ display:flex; align-items:center; }

/* Make the header flag a bit smaller so it fits nicely */
.pane-head .flagBtn.big{ --btn-h:72px; }         /* was 92px */
.pane-head .flagBtn.big{ --rhombus-scale:.74; }  /* keeps rounded diamond inside button */

/* Tighten the controls row since it no longer holds the flag */
.pane-controls{ gap:10px; margin-top:2px; }

/* On very narrow phones, shrink the header flag a touch more */
@media (max-width: 380px){
  .pane-head .flagBtn.big{ --btn-h:64px; --rhombus-scale:.72; }
}

  /* Give the header a hair more top room and bump the flag down a bit */
  .pane-head{ padding-top: 6px; overflow: visible; }   /* keep any glow visible */
  .pane-head .flagBtn.big{ margin-top: 6px; }          /* nudges the diamond down */
  
  @media (max-width: 380px){
    .pane-head{ padding-top: 8px; }
	  .pane-head .flagBtn.big{ margin-top: 8px; }
	  }
	  
	  
	  /* Score cluster should always hug the left edge */
.scoreWrap{ margin-left: 0 !important; }

/* Pager dots slide to the far right so they never push the score */
.pager{ margin-left: auto !important; }


/* ——— Toasts (center of screen, all of them) ——— */
.toasts{
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);      /* hard-center the stack */
  display: flex;
  flex-direction: column;
  align-items: center;                    /* center each toast */
  gap: 10px;
  z-index: 10000;
  pointer-events: none;                   /* lets you tap through gaps */
  max-width: calc(100vw - 32px);
}

.toast{
  pointer-events: auto;                   /* but the toast itself is clickable */
  background:#fff; color:#0f172a;
  border:1px solid #e7ecff; border-left:6px solid #0b74ff;
  border-radius:12px;
  width: min(560px, 92vw);                /* nice centered width */
  padding:12px 14px;
  box-shadow:0 10px 30px rgba(16,24,40,.15);
  font-weight:800; line-height:1.2;
  display:flex; flex-direction:column; gap:4px;
  animation: toast-in .18s ease-out;
}

.toast.success{ border-left-color:#16a34a; }
.toast.error{   border-left-color:#ef4444; }
.toast .sub{ font-weight:600; color:#475467; font-size:12px; }

/* animate only vertical so center math stays crisp */
@keyframes toast-in  { from { transform: translateY(8px);  opacity:0 } to { transform: translateY(0); opacity:1 } }
@keyframes toast-out { to   { transform: translateY(8px);  opacity:0 } }
.toast.hide{ animation: toast-out .15s ease-in forwards; }

/* Bigger, phone-friendly toast */
.toast{
  pointer-events: auto;
  background:#fff; color:#0f172a;
  border:1px solid #e7ecff; border-left:8px solid #0b74ff; /* thicker accent */
  border-radius:14px;

  /* wider + responsive type / padding */
  width: min(640px, 96vw);
  font-weight:800; line-height:1.25;
  font-size: clamp(16px, 4.8vw, 20px);
  padding: clamp(14px, 3.6vw, 22px) clamp(16px, 4.2vw, 24px);

  box-shadow:0 14px 34px rgba(16,24,40,.18);
  display:flex; flex-direction:column; gap:6px;
  animation: toast-in .18s ease-out;
}
.toast .sub{
  font-weight:600; color:#475467;
  font-size: clamp(13px, 3.6vw, 16px);
}

/* keep the exit anim */
@keyframes toast-in  { from { transform: translateY(8px);  opacity:0 } to { transform: translateY(0); opacity:1 } }
@keyframes toast-out { to   { transform: translateY(8px);  opacity:0 } }
.toast.hide{ animation: toast-out .15s ease-in forwards; }

/* XXL toast (bigger than xl) */
.toast.xxl{
  /* bigger readable type + comfy padding */
  font-size: clamp(22px, 7.2vw, 30px);
  line-height: 1.25;
  padding: clamp(24px, 6vw, 36px) clamp(26px, 7vw, 40px);

  /* stronger visual weight */
  border-left-width: 12px;
  border-radius: 16px;
  box-shadow: 0 18px 44px rgba(16,24,40,.22);

  /* give it more room, still safe on tiny phones */
  width: min(720px, 98vw);
}

.toast.xxl .sub{
  font-size: clamp(16px, 4.8vw, 20px);
  line-height: 1.3;
}

/* Compact dog card */
#dogCard { padding: 10px 12px; }
#dogCard .dog-head{
  display:grid;
  grid-template-columns: 1fr auto;
  align-items:center;
  gap:10px;
  padding-bottom: 0;
}
#dogCard .dog-left{
  display:flex; align-items:baseline; gap:8px;
}
#dogCard .dog-left .kind{ font-size:16px; font-weight:900; color:#0b74ff; }
#dogCard .dog-left .title{ font-size:20px; font-weight:900; color:#0f172a; }

/* Make the DOG mic about half width, a bit shorter, emoji-only */
#dogMic.mic.big.half{
  min-width: clamp(120px, 44vw, 180px);
  height: 72px;
  padding: 0 14px;
  font-size: 22px;           /* emoji size */
  gap: 10px;
}

/* Optional: smaller hint + tighter spacing */
#dogCard .hint{ margin-top: 6px; font-size: 12px; color:#667085; }

[hidden]{ display:none !important; }


</style>
</head>
<body>
  <div id="fitViewport">
  <div id="fitRoot">
    <div class="wrap">


	
<div class="card" id="dogCard" style="margin-bottom:12px;">
  <div class="pane-head dog-head">
    <div class="dog-left">
      <span class="kind">Dog:</span>
      <span class="title" id="dogName">—</span>
    </div>

    <button class="mic big half" id="dogMic" type="button" title="Say a dog’s name">
      <span class="dot"></span> 🔄 Switch
    </button>
  </div>

  <div class="hint" id="dogHint">Say a name</div>


      <div id="items" class="items"></div>
	  <div id="stage" class="stage" aria-live="polite"></div>

    </div>

<div class="card" style="margin-top:12px" hidden>
  <strong>Say things like…</strong>
  <ul class="sub" style="margin:6px 0 0 18px">
    <li>“flag big hunt and overran, rating seven point five”</li>
    <li>“remove didn’t mark and poor initial, increase by point five”</li>
    <li>“clear flags, score 6”</li>
    <li>“7.5” (just a number sets the score)</li>
  </ul>
</div>

  <!-- Missed phrases overlay -->
  <div id="missedOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases</strong></div>
        <div class="hint">These didn’t map to flags. Tap 🎤 to retry or apply a suggestion.</div>
      </div>
      <div id="missedList" class="sheet-body"></div>
      <div class="sheet-foot">
        <button class="btn" id="missedClose">Close</button>
        <button class="btn ghost" id="missedClear">Dismiss all</button>
      </div>
    </div>
  </div>
  

  <!-- Master log overlay -->
  <div id="logOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases – log</strong></div>
        <div class="hint">Kept in localStorage to spot trends. Clear anytime.</div>
      </div>
      <div id="logList" class="sheet-body log-list"></div>
      <div class="sheet-foot">
        <button class="btn" id="logClose">Close</button>
        <button class="btn danger" style="border-color:#fca5a5;color:#7f1d1d" id="logClear">Clear log</button>
      </div>
    </div>
  </div>
  
<!-- Active-flags peek (hold the red circle, swipe down to clear) -->
<div id="peekOverlay" class="overlay" aria-hidden="true">
  <div class="peek">
    <div class="peek-head">Active flags for this item</div>
    <div id="peekList" class="peek-list"></div>

    <div id="pullZone" class="pull-zone">
      <div id="pullBar" class="pull-bar"></div>
      <div id="pullLabel" class="pull-label">Swipe down to clear</div>
    </div>
  </div>
</div>



<div class="bar" hidden>
  <button id="clearBtn" class="btn">Clear all</button>
  <button id="viewLogBtn" class="btn ghost">Unassigned Log</button>
  <div id="status" class="status">Status: idle</div>
</div>
 </div>
</div>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>


  // reuse trailer.html config
  const firebaseConfig = {
    apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
    authDomain: "task-tracker-73b77.firebaseapp.com",
    projectId: "task-tracker-73b77",
    storageBucket: "task-tracker-73b77.firebasestorage.app",
    messagingSenderId: "795274673000",
    appId: "1:795274673000:web:0ea07130e45c72384134dd",
    measurementId: "G-VLW5KLY4FF"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  
  // ---------- Run context (trainer/day/setup) ----------
let currentTrainer = 'Scott';                   // default
let currentDateKey = null;
let currentSetupId = null;
let currentSetupOrder = 1;
let unsubRun = null;


// Build a reference to the score "run" doc for a dog
function runDocRef(dogName){
  if (!dogName || !currentSetupId || !currentTrainer || !currentDateKey) return null;
  return db.collection('setups').doc(currentTrainer)
           .collection('days').doc(currentDateKey)
           .collection('setups').doc(currentSetupId)
           .collection('scores').doc(dogName)
           .collection('runs').doc('current'); // one doc per day/setup/dog
}

// Tiny debounce helper + per-item debouncers
function debounce(fn, ms=350){
  let t = null;
  const d = (...a) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...a), ms);
  };
  d.cancel = () => { clearTimeout(t); t = null; };
  return d;
}

function cancelPendingSaves(){
  Object.values(saveDebouncers).forEach(fn => fn?.cancel?.());
  for (const k in saveDebouncers) delete saveDebouncers[k];
}


const saveDebouncers = {};
function debouncedSaver(itemId){
  if (!saveDebouncers[itemId]){
    saveDebouncers[itemId] = debounce(async ()=>{
      const dogName = selectedDog;
      const ref = runDocRef(dogName);
      if (!ref) return;
      const it = items.find(x=>x.id===itemId);
      if (!it) return;

      // Persist score + flags for this one item
      const payload = { score: it.score || 0, flags: it.flags || {} };
      await ref.set({
        trainer: currentTrainer,
        dateKey: currentDateKey,
        setupId: currentSetupId,
        setupOrder: currentSetupOrder,
        // tip: if you need a numeric "handles" count later, add it alongside
        items: { [itemId]: payload },
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    }, 350);
  }
  return saveDebouncers[itemId];
}

// Load this dog's saved scores/flags into our in-memory `items` and re-render
async function loadDogRun(dogName){
  const ref = runDocRef(dogName);
  if (!ref) return;

  const snap  = await ref.get();
  const saved = snap.exists ? (snap.data()?.items || {}) : {};

  let changed = false;

  items.forEach(it => {
    const s = saved[it.id];

    // NEW: hard reset to a clean baseline first
    const newScore = Number.isFinite(s?.score) ? quant05(s.score) : 0;
    const newFlags = (s?.flags && typeof s.flags === 'object') ? { ...s.flags } : {};

    // Only mark changed if values differ (prevents noisy re-renders)
    const flagsChanged = JSON.stringify(it.flags || {}) !== JSON.stringify(newFlags);
    const scoreChanged = (it.score ?? 0) !== newScore;

    if (flagsChanged || scoreChanged){
      it.flags = newFlags;
      it.score = newScore;
      changed = true;
    }
  });

  if (changed){
  renderAll();
  refreshStage();     // <— rebuild both visible panes for the new dog
}
attachRunListener(dogName);
}


function attachRunListener(dogName){
  const ref = runDocRef(dogName);
  if (!ref) return;

  // stop any previous listener
  if (unsubRun) { try{unsubRun();}catch{} unsubRun = null; }

  unsubRun = ref.onSnapshot(snap => {
    const saved = snap.exists ? (snap.data()?.items || {}) : {};

    let changed = false;

    // bring local items in sync with what Firestore has
    items.forEach(it => {
      const s = saved[it.id];

      const newScore = Number.isFinite(s?.score) ? quant05(s.score) : 0;
      const newFlags = (s?.flags && typeof s.flags === 'object') ? { ...s.flags } : {};

      const flagsChanged = JSON.stringify(it.flags || {}) !== JSON.stringify(newFlags);
      const scoreChanged = (it.score ?? 0) !== newScore;

      if (flagsChanged || scoreChanged){
        it.flags = newFlags;
        it.score = newScore;
        changed = true;

        // keep both UI modes in sync
        syncRow(it);
        syncStageForItem?.(it);
      }
    });

    if (changed){
      refreshStage(); // ensures the visible panes reflect changes
      setStatus('live update');
    }
  }, err => console.warn('run listener error:', err));
}



/* ---------------- Flag dictionary & variants (for positioning/fuzzy) ---------------- */
const FLAGS = [
  { key:'bigHunt',        label:'Big Hunt',         variants:['big hunt'] },
  { key:'marginalHunt',   label:'Marginal Hunt',    variants:['marginal hunt'] },

  // add split/inflected variants
  { key:'overran',        label:'Overran',          variants:['overran','overrun','over run','over-run','over ran','ran over'] },

  { key:'shortCheckDown', label:'Short Checkdown',  variants:[
      'short checkdown','short check down','short-check down','short check-down'
    ] },

  // allow articles + shorthand
  { key:'backSideOfGun',  label:'Backside of Gun',  variants:[
      'backside of gun','backside of the gun','back side of gun','back side of the gun',
      'back of gun','back of the gun'
    ] },

  { key:'handled',        label:'Handled',          variants:['handled','handles'] },
  { key:'castRefusal',    label:'Cast Refusal',     variants:['cast refusal','cast refused','refused cast'] },

  // sit/sat + article
  { key:'sitOnWhistle',   label:'Sit on Whistle',   variants:[
      'sit on whistle','sit on the whistle','sat on whistle','sat on the whistle'
    ] },

  // didn’t vs did not
  { key:'didntMark', label:"Didn't Mark", variants:['didnt mark', "didn't mark", 'did not mark'] },


  { key:'poorInitial',    label:'Poor Initial',     variants:['poor initial'] },

  // head swing vs swung
  { key:'headswing',      label:'Headswing',        variants:['headswing','head swing','head swung'] },

  { key:'break',          label:'Broke',            variants:['broke','break'] },
  { key:'switched',       label:'Switched',         variants:['switched','switch','did a switch'] },
  { key:'noGo',           label:'No-Go',            variants:['no go','no-go'] },

  // pick-up hyphen + article
  { key:'pickedUpPoison', label:'Poison Pick Up',   variants:[
      'poison pick up','poison pick-up','picked up poison','picked up the poison'
    ] },
  { key:'noPickUp',       label:'No Pick Up',       variants:[
      'no pick up','no pick-up','no pickup'
    ] },

  { key:'stoodOut',       label:'Stood Out',        variants:['stood out','stood way out'] },
  { key:'popped',         label:'Popped',           variants:['popped','pop'] },
];
const FLAG_MAP = Object.fromEntries(FLAGS.map(f=>[f.key,f]));

/* Regex bundle for fast detection (multi-match) */
/* NOTE: these broaden matching but preserve existing behavior */
const FLAG_RX = {
  bigHunt: [
    /big[\s-]*hunt/gi,
    /(?:big|wide|large)\s+(?:area\s+)?hunt/gi,
    /hunted\s+big/gi,
    /big\s+search/gi
  ],

  marginalHunt: [
    /marginal[\s-]*hunt/gi,
    /(?:small|short|brief|light)\s+hunt/gi
  ],

  // overran / over ran / over run / ran over + synonyms
  overran: [
    /\boverran\b/gi, /\bover[\s-]*(?:ran|run)\b/gi, /\bran\s+over\b/gi,
    /\bovershot\b/gi, /\bover\s*shot\b/gi,
    /ran\s+past/gi, /(?:pushed|carried|blew)\s+(?:past|deep)\b/gi,
    /\btoo\s+deep\b/gi
  ],

  // short checkdown + synonyms
  shortCheckDown: [
    /short[\s-]*check[\s-]*down/gi, /short[\s-]*checkdown/gi,
    /short\s+check\b/gi, /checked\s+down\s+(?:short|close)\b/gi,
    /check\s*down\s*short\b/gi, /checked\s+early\b/gi
  ],

  // backside/back of/behind/past gun
  backSideOfGun: [
    /back\s*side\s*of\s*(?:the\s*)?gun/gi,
    /backside\s*of\s*(?:the\s*)?gun/gi,
    /back\s*of\s*(?:the\s*)?gun/gi,
    /behind\s*(?:the\s*)?gun(?:ner)?\b/gi,
    /back\s*of\s*(?:the\s*)?gunner\b/gi,
    /past\s*(?:the\s*)?gun\b/gi
  ],

  // handled + inflections
  handled: [
    /\bhandled?\b/gi,
    /had\s+to\s+handle\b/gi,
    /took\s+(?:a|the)?\s*handle\b/gi,
    /needed\s+(?:a|the)?\s*handle\b/gi,
    /(?:double|re)[-\s]?handle\b/gi,
    /\bi\s+handled\b/gi
  ],

  // cast refusal + inflections
  castRefusal: [
    /cast[\s-]*refusal/gi, /cast[\s-]*refused/gi, /refused[\s-]*cast/gi,
    /refus(?:ed|al)\s+(?:a\s*)?cast/gi,
    /wouldn'?t\s+cast/gi, /ignored\s+the\s+cast/gi,
    /\bno\s+cast\b/gi, /refused\s+the\s*re[-\s]?cast\b/gi
  ],

  // sit|sat on/to whistle (+ late/slow sit)
  sitOnWhistle: [
    /\b(?:sit|sat)\s*on\s*(?:the\s*)?whistle\b/gi,
    /\bsit\s*to\s*(?:the\s*)?whistle\b/gi, /\bsat\s*to\s*whistle\b/gi,
    /\blate\s+sit(?:\s+on\s+whistle)?\b/gi, /\bslow\s+sit(?:\s+on\s+whistle)?\b/gi
  ],

  // didn't|did not mark + synonyms
  didntMark: [
    /(?:didn'?t|did\s+not)\s*mark/gi,
    /\bno\s+mark\b/gi, /failed\s+to\s+mark\b/gi,
    /didn'?t\s+see\s+it\b/gi, /lost\s+the\s+mark\b/gi,
    /poor\s+mark\b/gi
  ],

  poorInitial: [
    /poor\s*initial/gi,
    /\b(?:bad|weak)\s+initial(?:\s+line)?\b/gi,
    /\boff\s+the\s+line\b/gi,
    /poor\s+initial\s+line\b/gi
  ],

  // head swing / headswing / head swung + synonyms
  headswing: [
    /head\s*swing/gi, /\bheadswing\b/gi, /\bhead\s*swung\b/gi,
    /swung\s+(?:his|her|the)?\s*head\b/gi, /head\s*whip\b/gi,
    /looked\s+off\b/gi, /head\s*swing\s+(?:left|right)\b/gi
  ],

  break: [
    /\bbroke?\b/gi, /\bbreak\b/gi,
    /\bjumped\b/gi, /left\s+early\b/gi, /\bbolted\b/gi,
    /came\s+off\s+the\s+line\b/gi, /\bcrept\b/gi
  ],

  switched: [
    /\bswitch(?:ed|)\b/gi, /did\s*(?:a\s*)?switch\b/gi,
    /switched\s+birds?\b/gi, /(?:changed|swapped)\s+birds?\b/gi,
    /picked\s+the\s+other\s+bird\b/gi, /\bwrong\s+bird\b/gi
  ],

  noGo: [
    /\bno[-\s]?go\b/gi,
    /wouldn'?t\s+go\b/gi, /didn'?t\s+go\b/gi, /refused\s+to\s+go\b/gi,
    /\bbalked\b/gi, /stuck\s+on\s+the\s+line\b/gi
  ],

  pickedUpPoison: [
    /poison\s*pick[-\s]*up/gi, /picked\s*up\s*(?:the\s*)?poison/gi,
    /(?:took|grabbed)\s*(?:the\s*)?poison\b/gi,
    /went\s+for\s+(?:the\s*)?poison\b/gi,
    /picked\s+(?:the\s*)?poison\s+bird\b/gi
  ],

  noPickUp: [
    /\bno\s*pick[-\s]*up\b/gi, /\bno\s*pickup\b/gi,
    /didn'?t\s+pick\s+up\b/gi, /\bno\s+retrieve\b/gi,
    /left\s+(?:it|the\s+bird)\b/gi
  ],

  stoodOut: [
    /stood\s*out/gi, /hung\s+out\b/gi, /stayed\s+out\b/gi, /\blingered\b/gi
  ],

  popped: [
    /\bpopped?\b/gi,
    /popped\s+on\s+the\s+blind\b/gi,
    /stopped\s+and\s+looked\b/gi,
    /stopped\s+short\b/gi
  ],
};

// Add/remove verb detectors (single source of truth)
const RX_ADD_VERB =
  /\b(?:add|flag|set|give|tag|check|activate|turn\s+on|mark(?:\s+it)?\s+as)\b/;

const RX_REMOVE_VERB =
  /\b(?:remove|clear|unset|delete|drop|kill|unflag|turn\s+off|take\s+off)\b/;



/* ---------------- Demo items ---------------- */
let items = [];
/* ---------------- UI ---------------- */
const itemsEl = document.getElementById('items');
const statusEl = document.getElementById('status');

// --- Stage (carousel) refs/state ---
const stageEl = document.getElementById('stage');
let idxMark  = +(localStorage.getItem('idxMark')  || 0);
let idxBlind = +(localStorage.getItem('idxBlind') || 0);

// ------- Helpers for today + formatting -------
function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
function yards(n){ return (typeof n==='number' && isFinite(n)) ? Math.round(n) : 0; }

// Build our speech-page item objects from setups doc
function buildSpeechItemsFromSetupDoc(data){
  const out = [];
  const marks  = Array.isArray(data.items)  ? data.items  : [];
  const blinds = Array.isArray(data.blinds) ? data.blinds : [];

  marks.forEach((m, i) => {
    out.push({
      id: m.id || `m_${i+1}`,
      kind: 'Mark',
      title: `#${i+1} — ${yards(m.dist)} yards`,
      score: 0,
      flags: {}
    });
  });

  blinds.forEach((b, i) => {
    out.push({
      id: b.id || `b_${i+1}`,
      kind: 'Blind',
      title: `#${i+1} — ${yards(b.dist)} yards`,
      score: 0,
      flags: {}
    });
  });

  return out;
}

// Reset stage so new data doesn't inherit old panes
function resetStage(){
  idxMark = 0; idxBlind = 0;
  try {
    localStorage.setItem('idxMark', '0');
    localStorage.setItem('idxBlind', '0');
  } catch {}
  stageEl.innerHTML = '';   // remove previous .pane-slot(s)
  itemsEl.innerHTML = '';   // clear old rows list
}

// Load today's Setup N for a trainer (defaults: Scott / 1)
async function loadTodaysSetup({ trainer='Scott', setupOrder=1 } = {}){
const dateKey = ymd(new Date());
currentDateKey = dateKey;          

  setStatus(`Loading ${trainer} – ${dateKey} (Setup ${setupOrder})…`);

  const dayColl = db.collection('setups').doc(trainer)
                    .collection('days').doc(dateKey)
                    .collection('setups');

  const snap = await dayColl.orderBy('order').get();
  if (snap.empty){
    setStatus('No setups found for today. Using empty list.');
    resetStage();
    items = [];
    renderAll();
    renderStage();
    return;
  }

  // choose requested order if present, else first doc
let chosen = snap.docs[0];
if (setupOrder > 1){
  const found = snap.docs.find(d => (d.data()?.order ?? 0) === setupOrder);
  if (found) chosen = found;
}
currentTrainer = trainer;                  // <— add
currentSetupId = chosen.id;                // <— add
currentSetupOrder = setupOrder || 1;       // <— add


  const data = chosen.data() || {};
  items = buildSpeechItemsFromSetupDoc(data);

  resetStage();
  renderAll();
  renderStage();
if (selectedDog) { loadDogRun(selectedDog).catch(console.error); }
  const m = items.filter(x=>x.kind==='Mark').length;
  const b = items.filter(x=>x.kind==='Blind').length;
  setStatus(`Loaded ${trainer} – ${dateKey} • ${m} marks / ${b} blinds`);
}

// (optional) expose for console testing
window.loadTodaysSetup = loadTodaysSetup;


function clamp(i, len){ if(len<=0) return 0; return (i%len+len)%len; }
function saveIdx(){ localStorage.setItem('idxMark', idxMark); localStorage.setItem('idxBlind', idxBlind); }


function chip(key,on){
  const el=document.createElement('span');
  el.className='chip'+(on?' on':'');
  el.dataset.key=key;
  el.textContent=FLAG_MAP[key].label;
  return el;
}
function renderRow(it){
  const row=document.createElement('div'); row.className='row'; row.id='row-'+it.id;

  const left=document.createElement('div');
  left.innerHTML=`<div class="kind">${it.kind}</div><div class="title">${it.title}</div>`;

  const mid=document.createElement('div');
  const chips=document.createElement('div'); chips.className='chips';
  FLAGS.forEach(f=> chips.appendChild(chip(f.key, !!it.flags[f.key])));
  mid.appendChild(chips);
  
 const right=document.createElement('div'); right.className='controls';
const flagBtn = document.createElement('button');
flagBtn.type='button';
flagBtn.className='flagBtn big';
flagBtn.title='Hold to view flags • Swipe down to clear';
flagBtn.textContent='🚩';
setupFlagPeek(flagBtn, it.id);

const mic=document.createElement('button'); mic.type='button'; mic.className='mic big';
mic.innerHTML='<span class="dot"></span> 🎤 Say Red Flags/Score';

  mic.addEventListener('click',()=>startListeningFor(it.id));
  
  const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='10'; slider.step='0.5'; slider.value=it.score;
  slider.addEventListener('input',()=>{ it.score=+slider.value; score.textContent=it.score.toFixed(1);debouncedSaver(it.id)();});
  const score=document.createElement('div'); score.className='score'; score.textContent=it.score.toFixed(1);
 right.append(flagBtn, mic, slider, score);

  row.append(left,mid,right);
  itemsEl.appendChild(row);
}
function renderAll(){ itemsEl.innerHTML=''; items.forEach(renderRow); }

function ensureSlot(type){
  let slot = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if(!slot){
    slot = document.createElement('div');
    slot.className = 'pane-slot';
    slot.dataset.type = type;
    stageEl.appendChild(slot);
  }
  return slot;
}

function renderStage(){
  const marks  = items.filter(it=>it.kind==='Mark');
  const blinds = items.filter(it=>it.kind==='Blind');
  if (!stageEl) return;

  idxMark  = clamp(idxMark,  marks.length);
  idxBlind = clamp(idxBlind, blinds.length);

  // Ensure slots exist (one for each)
  const markSlot  = ensureSlot('mark');
  const blindSlot = ensureSlot('blind');

  // First time render: if slot empty, just place the pane (no animation)
  if(!markSlot.querySelector('.pane')){
    markSlot.appendChild(renderPane('Mark', marks[idxMark], marks.length, 'mark'));
  }
  if(!blindSlot.querySelector('.pane')){
    blindSlot.appendChild(renderPane('Blind', blinds[idxBlind], blinds.length, 'blind'));
  }
}

// direction: 'left' (next) or 'right' (prev)
function animateSwap(type, direction){
  const isMark = (type==='mark');
  const list   = items.filter(it=> it.kind === (isMark ? 'Mark' : 'Blind'));
  const total  = list.length;
  const idx    = isMark ? idxMark : idxBlind;
  const slot   = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if(!slot || !total) return;

  const current = slot.querySelector('.pane');
  const label   = isMark ? 'Mark' : 'Blind';
  const next    = renderPane(label, list[idx], total, type);

  // stage the new pane off-screen
  next.classList.add(direction==='left' ? 'enter-from-right' : 'enter-from-left');
  slot.appendChild(next);

  // lock both panes to the slot for animation
  next.style.position = current.style.position = 'absolute';
  next.style.inset    = current.style.inset    = '0';

  // kick the transition – ensure the off-screen state is committed first
requestAnimationFrame(() => {
  void next.offsetWidth; // layout flush (or use next.getBoundingClientRect())
  requestAnimationFrame(() => {
    current.classList.add(direction === 'left' ? 'exit-to-left' : 'exit-to-right');
    next.classList.remove('enter-from-right', 'enter-from-left');
  });
});


  const cleanup = () => {
    current?.remove();
    // let the survivor be normal flow for focus/scroll if you prefer (or stay absolute)
    next.style.position = 'absolute';  // keep absolute so future swaps overlay cleanly
    next.style.inset = '0';
  };
  next.addEventListener('transitionend', cleanup, { once:true });
}


function renderPane(label, it, total, type){
  const pane = document.createElement('div');
  pane.className = 'pane';
  pane.dataset.type = type;

  // ---- HEADER: titles on the left, flag on the right ----
  const head = document.createElement('div');
  head.className = 'pane-head';

  const headLeft = document.createElement('div');
  headLeft.innerHTML = `
    <div class="kind">${label}</div>
    <div class="title">${it ? it.title : '—'}</div>
  `;

  const headRight = document.createElement('div');
  headRight.className = 'pane-actions';

  // Flag lives in the header now
  const flagBtn = document.createElement('button');
  flagBtn.type='button';
  flagBtn.className='flagBtn big';
  flagBtn.title='Hold to view flags • Swipe down to clear';
  flagBtn.textContent='🚩';
  if (it) setupFlagPeek(flagBtn, it.id);

  headRight.appendChild(flagBtn);
  head.append(headLeft, headRight);

  // ---- CONTROLS: mic + score + pager (flag removed) ----
  const ctrls = document.createElement('div');
  ctrls.className = 'pane-controls';

  const mic = document.createElement('button');
mic.type='button';
mic.className='mic big';
mic.innerHTML='<span class="dot"></span> 🎤 Say Red Flags/Score';

// NEW: default to “not blocking click”
mic.dataset.blockClick = '0';

  // Hidden range for existing logic
  const range = document.createElement('input');
  range.type='range'; range.min='0'; range.max='10'; range.step='0.5';
  range.value = it ? it.score : 0;
  range.className = 'visually-hidden';

  const legacyScore = document.createElement('div');
  legacyScore.className='score big';
  legacyScore.textContent = (it ? it.score : 0).toFixed(1);

  const scoreWrap = document.createElement('div');
  scoreWrap.className = 'scoreWrap';

  const dec = document.createElement('button');
  dec.type='button'; dec.className='scoreBtn'; dec.setAttribute('aria-label','Decrease score'); dec.textContent='–';

  const badge = document.createElement('div');
  badge.className='scoreBadge';
  badge.textContent = (it ? it.score : 0).toFixed(1);

  const inc = document.createElement('button');
  inc.type='button'; inc.className='scoreBtn'; inc.setAttribute('aria-label','Increase score'); inc.textContent='+';

  scoreWrap.append(dec, badge, inc);

  const pager = document.createElement('div');
  pager.className = 'pager';
  if (total > 1){
    for(let i=0;i<total;i++){
      const d=document.createElement('div');
      d.className='dot' + (i === (type==='mark'?idxMark:idxBlind) ? ' on' : '');
      pager.appendChild(d);
    }
  }

  if (it){
    mic.addEventListener('click', (ev) => {
  // If a horizontal swipe started on the mic, cancel this click
  if (mic.dataset.blockClick === '1') {
    ev.preventDefault();
    ev.stopPropagation();
    return;
  }
  startListeningFor(it.id);
});


    range.addEventListener('input', ()=>{
      it.score = +range.value;
      const v = it.score = quant05(it.score);
      badge.textContent = v.toFixed(1);
      legacyScore.textContent = v.toFixed(1);
      debouncedSaver(it.id)();
    });
    range.addEventListener('pointerdown', (e)=> e.stopPropagation());

    const nudge = (dir)=> {
      const raw = (it.score ?? 0) + (dir * 0.5);
      const v = it.score = Math.max(0, Math.min(10, quant05(raw)));
      range.value = v;
      badge.textContent = v.toFixed(1);
      legacyScore.textContent = v.toFixed(1);
      syncRow(it);
      debouncedSaver(it.id)();
    };
    dec.addEventListener('click', ()=> nudge(-1));
    inc.addEventListener('click', ()=> nudge(+1));

    attachSwipeX(pane, 60,
      () => { if (type==='mark'){ idxMark = clamp(idxMark+1, total); } else { idxBlind = clamp(idxBlind+1, total); } saveIdx(); animateSwap(type, 'left'); },
      () => { if (type==='mark'){ idxMark = clamp(idxMark-1, total); } else { idxBlind = clamp(idxBlind-1, total); } saveIdx(); animateSwap(type, 'right'); }
    );
  }

  // Order: header (with flag) + controls (mic/score/pager)
  ctrls.append(scoreWrap, mic, pager, range, legacyScore);

  pane.append(head, ctrls);
  return pane;
}



function attachSwipeX(el, threshold, onLeft, onRight){
  let pid = null, sx = 0, dx = 0, ignore = false;
  let micEl = null;        // if gesture started on the mic
  let swiping = false;

  el.addEventListener('pointerdown', (e)=>{
    const t = e.target;
    const startedOnRange = t.closest?.('input[type="range"]');
    const startedOnFlag  = t.closest?.('.flagBtn');
    micEl                = t.closest?.('.mic') || null;

    // still block swipes that start on the range or the flag
    if (startedOnRange || startedOnFlag){
      ignore = true; pid = null; sx = 0; dx = 0; micEl = null; swiping = false;
      return;
    }

    ignore = false;
    pid = e.pointerId; sx = e.clientX; dx = 0; swiping = false;

    // IMPORTANT: do NOT capture yet if we started on the mic.
    // Let the tap produce a normal click unless we detect a swipe.
    if (!micEl) el.setPointerCapture?.(pid);
  });

  el.addEventListener('pointermove', (e)=>{
    if (ignore || e.pointerId !== pid) return;
    dx = e.clientX - sx;

    // If the gesture began on the mic and moves horizontally,
    // mark swipe, block the mic's click, and now capture.
    if (micEl && !swiping && Math.abs(dx) > 8){
      swiping = true;
      micEl.dataset.blockClick = '1';
      el.setPointerCapture?.(pid);
    }
  });

  const end = (e)=>{
    if (ignore || e.pointerId !== pid){
      micEl = null; return;
    }

    // If we started on mic and never swiped, do nothing here;
    // let the mic's normal click fire naturally.
    if (micEl && !swiping){
      // ensure it's not blocked just in case
      micEl.dataset.blockClick = '0';
      micEl = null;
      pid = null; dx = 0;
      return;
    }

    // otherwise, handle the swipe
    if (dx <= -threshold) onLeft?.();
    else if (dx >= threshold) onRight?.();

    // re-enable mic clicks after this event cycle
    if (micEl){
      setTimeout(()=> { micEl.dataset.blockClick = '0'; micEl = null; }, 0);
    }

    pid = null; dx = 0; swiping = false;
  };

  el.addEventListener('pointerup', end);
  el.addEventListener('pointercancel', end);
}





renderAll();          // safe no-op while empty
renderStage();
loadTodaysSetup({ trainer: 'Scott', setupOrder: 1 }).catch(err=>{
  console.error(err);
  setStatus('Failed to load today’s setup.');
});


// --- Peek overlay state/refs ---
const peekOverlay = document.getElementById('peekOverlay');
const peekListEl  = document.getElementById('peekList');
const pullZone    = document.getElementById('pullZone');
const pullBar     = document.getElementById('pullBar');
const pullLabel   = document.getElementById('pullLabel');

// Close when tapping the dim backdrop or pressing Escape
peekOverlay.addEventListener('click', (e)=>{
  if (e.target === peekOverlay) closePeek();
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') closePeek();
});

peekOverlay.addEventListener('pointermove', (e)=>{
  if (peekHold.itemId == null) return;
  if (peekHold.pid != null && e.pointerId !== peekHold.pid) return; // ignore other fingers
  const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
  updatePull(y - peekHold.startY);
}, { passive: true });

document.addEventListener('dog:selected', (e)=>{
  // when the user picks a dog, pull their saved scores/flags for the current setup
  loadDogRun(e.detail.name).catch(console.error);
});


// Global safety net: if the button loses the pointerup, still close
const closeFromDoc = (e)=>{
  if (peekHold.itemId == null) return;
  const y  = e?.clientY ?? (e?.touches?.[0]?.clientY ?? peekHold.startY);
  const dy = y - peekHold.startY;
  if (dy >= peekHold.threshold) clearAllFlags(peekHold.itemId);
  closePeek();
};
document.addEventListener('pointerup', closeFromDoc, { capture:true });
document.addEventListener('pointercancel', closeFromDoc, { capture:true });


// Suppress long-press context menu and text selection on the flag + overlay
['contextmenu', 'selectstart'].forEach(evt => {
  document.addEventListener(evt, (e) => {
    const t = e.target;
    if (t && typeof t.closest === 'function' &&
        (t.closest('.flagBtn') || t.closest('#peekOverlay'))) {
      e.preventDefault();
    }
  }, { passive:false });
});


let peekHold = { itemId:null, startY:0, threshold:90, pid:null };


function openPeek(itemId){
  document.documentElement.classList.add('overlay-open');
  peekHold.itemId = itemId;
  fillPeek(itemId);
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
  pullLabel.textContent = 'Swipe down to clear';
  peekOverlay.classList.add('open');
  peekOverlay.setAttribute('aria-hidden','false');
}
function closePeek(){
  peekOverlay.classList.remove('open');
  peekOverlay.setAttribute('aria-hidden','true');
  peekHold.itemId = null;
  peekHold.pid = null;                 // <— add this
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
 if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
}


function fillPeek(itemId){
  const it = items.find(x=>x.id===itemId);
  const labels = FLAGS.filter(f => !!(it?.flags?.[f.key])).map(f=>f.label);
  peekListEl.innerHTML = labels.length
    ? labels.map(l=>`<div class="peek-flag">${l}</div>`).join('')
    : `<div class="hint">No flags set</div>`;
}

function updatePull(dy){
  const h = Math.max(0, Math.min(140, dy));
  pullBar.style.height = h + 'px';
  const ready = dy >= peekHold.threshold;
  pullZone.classList.toggle('ready', ready);
  pullLabel.textContent = ready ? 'Release to clear' : 'Swipe down to clear';
}

function clearAllFlags(itemId){
  const it = items.find(x=>x.id===itemId);
  if(!it) return;
  it.flags = {};
  syncRow(it);
  renderStage();
debouncedSaver(itemId)();                     // <— persist this item

  fillPeek(itemId);
  pullZone.classList.add('cleared');
  pullLabel.textContent = 'Cleared';
}

// Attach pointer interactions to a given red circle button
function setupFlagPeek(btn, itemId){
  let pid = null, holding = false;

  // prevent native long-press callout / selection on this control
  btn.addEventListener('contextmenu', e => e.preventDefault(), { passive:false });
  btn.addEventListener('selectstart', e => e.preventDefault(), { passive:false });
  btn.addEventListener('touchstart',  e => e.preventDefault(), { passive:false });

  btn.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  holding = true;
  pid = e.pointerId;
  peekHold.pid = e.pointerId;          // <— add this
  btn.setPointerCapture?.(pid);
  peekHold.startY = e.clientY ?? (e.touches?.[0]?.clientY || 0);
  openPeek(itemId);
});


  btn.addEventListener('pointermove', (e)=>{
    if(!holding || e.pointerId !== pid) return;
    const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
    updatePull(y - peekHold.startY);
  });

  const end = (e)=>{
  if(!holding || e.pointerId !== pid) return;
  const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
  const dy = y - peekHold.startY;
  if (dy >= peekHold.threshold) clearAllFlags(itemId);
  holding = false;
  try { btn.releasePointerCapture?.(pid); } catch {}
  pid = null;
  peekHold.pid = null;                 // <— add this
  closePeek();
};

btn.addEventListener('pointerup', end);
btn.addEventListener('pointercancel', end);

}


/* ---------------- Speech engine ---------------- */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let rec=null, activeId=null, activeFix=null; // activeFix = { itemId, phrase, suggestKey }
let listeningToastId = null;
if (SR){
  rec=new SR(); rec.lang='en-US'; rec.interimResults=false; rec.continuous=false;
  rec.onstart = () => {
  setStatus('listening…');
  if (listeningToastId) hideToast(listeningToastId);
  listeningToastId = showToast('🎤 Listening…', { duration: 0, size: 'xxl' });
};

rec.onerror = e => {
  setStatus('error: ' + (e.error || 'unknown'));
  if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
  showToast('Speech error', { type:'error', sub:String(e.error || ''), duration:2000 });
  endListen();
};

rec.onend = () => {
  setStatus('idle');
  if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
  endListen();
};

  rec.onresult = (e) => {
  // Build a “best guess” for apply, but also capture the last result’s alternatives.
  const tx = [...e.results].map(r => r[0].transcript).join(' ').trim();

  // Log alternatives (browser-dependent confidence support)
  const last = e.results[e.results.length - 1];
  const alts = last ? Array.from(last).map(a => ({
    transcript: (a.transcript || '').trim(),
    confidence: (typeof a.confidence === 'number') ? +a.confidence.toFixed(3) : null
  })) : [];

  const best = alts[0]?.transcript || tx;

  // ---- Dog-name listening fast-path ----
  if (dogListenActive){
  
  // ---- Dog-name listening fast-path ----
if (dogListenActive){
  const cmd = normalize(best);

  // NEW: voice-nav shortcuts for the dog section
  if (/\bgo\s+to\s+gps\b/.test(cmd)) {
    // (requested to use trainer=Scott explicitly)
    if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
    dogListenActive = false;
    dogMicBtn?.classList.remove('listening');
    window.location.href = 'https://morrowind4732.github.io/task-tracker/gps.html?trainer=Scott';
    return;
  }
  if (/\bgo\s+to\s+setup(?:s)?\b/.test(cmd)) {
    if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
    dogListenActive = false;
    dogMicBtn?.classList.remove('listening');
    window.location.href = 'https://morrowind4732.github.io/task-tracker/setups.html';
    return;
  }

  // existing dog-name matching…
  const name = matchDogName(best);
  if (name){
    setSelectedDog(name);
    setStatus('Dog: ' + name);
  } else {
    setStatus('Heard: "' + best + '", didn’t match a dog');
  }
  dogListenActive = false;
  dogMicBtn?.classList.remove('listening');
  if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
  return;
}

    const name = matchDogName(best);
    if (name){
      setSelectedDog(name);
      setStatus('Dog: ' + name);
    } else {
      setStatus('Heard: "' + best + '", didn’t match a dog');
    }
    dogListenActive = false;
    dogMicBtn?.classList.remove('listening');
    if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }
    return;
  }

  console.groupCollapsed(
    `%cSpeech(final) → %c${best}`,
    'color:#888', 'color:#111;font-weight:700'
  );
  console.log('activeId:', activeId, 'activeFix:', activeFix);
  if (alts.length) console.table(alts);
  console.groupEnd();

  // ---- apply to the right item and build a toast summary
  let summary = null;

  if (activeFix){
    const before = snapshotFlags(items.find(x => x.id === activeFix.itemId));
    summary = applyTranscript(activeFix.itemId, best);
    const after  = snapshotFlags(items.find(x => x.id === activeFix.itemId));
    const changed = diffFlags(before, after);
    const matchedSuggestion = changed.added.includes(activeFix.suggestKey) ||
                              changed.toggled?.includes?.(activeFix.suggestKey);

    if (matchedSuggestion || (changed.added.length + changed.toggled?.length || 0) > 0){
      // persist auto-fix for future runs
      if (activeFix.suggestKey){
        const canon = canonicalPhraseForKey(activeFix.suggestKey);
        if (canon) addAutoFix(activeFix.phrase, canon);
      }
      removeMissed(activeFix.itemId, activeFix.phrase);
      renderMissedOverlay();
    }
    activeFix = null;

  } else if (activeId) {
    summary = applyTranscript(activeId, best);
  }

  // close the "Listening…" toast
  if (listeningToastId){ hideToast(listeningToastId); listeningToastId = null; }

  // ---- Toasts ----
  if (summary?.batchApplied){
    const range =
      summary.batchApplied > 1
        ? `${summary.batchFrom} → ${summary.batchTo}`
        : `${summary.batchFrom}`;
    showToast('✅ Applied scores', {
      type: 'success',
      size: 'xxl',
      sub: `${summary.batchApplied} ${summary.batchKind.toLowerCase()}(s) • ${range}`,
      duration: 2600
    });
  } else if (summary){
    const parts = [];
    if (summary.added?.length) parts.push(`Added: ${labelsFor(summary.added).join(', ')}`);
    if (summary.setScore)      parts.push(`Score: ${summary.score.toFixed(1)}`);
    else if (summary.adjust)   parts.push(`Score ${summary.adjust>0?'+':''}${summary.adjust.toFixed(1)} → ${summary.score.toFixed(1)}`);
    if (!parts.length && summary.removed?.length){
      parts.push(`Removed: ${labelsFor(summary.removed).join(', ')}`);
    }
    if (parts.length){
      showToast('✅ Updated', { type:'success', size: 'xxl', sub: parts.join(' • '), duration: 2400 });
    } else {
      showToast('No flags recognized', { type:'info', duration: 1400 });
    }
  }
};




}else{
  setStatus('Speech API not supported in this browser.');
}
function setStatus(s){ statusEl.textContent='Status: '+s; }
function startListeningFor(id){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeFix=null;
  activeId=id;
  document.querySelectorAll('.row')
    .forEach(r=> r.classList.toggle('listening', r.id==='row-'+id));
  rec.start();
}

let __toastSeq = 0;
function showToast(text, { type='info', duration=1800, sub=null, placement='center', size=null } = {}){
  const wrap = document.getElementById('toasts'); if(!wrap) return null;
  const id = (++__toastSeq);
  const el = document.createElement('div');
  el.className = 'toast' + (type !== 'info' ? ' ' + type : '') + (size ? ' ' + size : '');
  if (placement === 'center') el.classList.add('center');
  el.dataset.id = String(id);
  el.innerHTML = `<div>${text}</div>${sub ? `<div class="sub">${sub}</div>` : ''}`;
  wrap.appendChild(el);
  if (duration > 0) setTimeout(()=> hideToast(id), duration);
  return id;
}


function hideToast(id){
  const wrap = document.getElementById('toasts'); if(!wrap) return;
  const el = wrap.querySelector(`.toast[data-id="${id}"]`); if(!el) return;
  el.classList.add('hide');
  el.addEventListener('animationend', ()=> el.remove(), { once:true });
}

const toastsWrap = document.getElementById('toasts');
function setToastCenter(on){ toastsWrap?.classList.toggle('center', !!on); }


function labelsFor(keys){ return keys.map(k => FLAG_MAP[k]?.label || k); }


function startFixListening(itemId, phrase, suggestKey){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeId=null;
  activeFix={ itemId, phrase, suggestKey };
  document.querySelectorAll('.row').forEach(r=>r.classList.remove('listening'));
  document.getElementById('row-'+itemId)?.classList.add('listening');
  rec.start();
}
function endListen(){
  activeId=null;
  document.querySelectorAll('.row').forEach(r=> r.classList.remove('listening'));
}


/* ---------------- Persistent Auto-Fix Dictionary ---------------- */
const FIX_KEY = 'speech_autofix_map_v1';

function readFixMap(){
  try { return JSON.parse(localStorage.getItem(FIX_KEY) || '{}'); }
  catch { return {}; }
}
function writeFixMap(map){
  localStorage.setItem(FIX_KEY, JSON.stringify(map));
}
function escapeRegex(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

/** Save a mapping like "big hut" -> "big hunt" (normalized, word-bounded) */
function addAutoFix(heard, corrected){
  const map = readFixMap();
  const h = normalize(heard);
  const c = normalize(corrected);
  if (!h || !c) return;
  map[h] = c;
  writeFixMap(map);
  // optional UI sugar:
  showToast('Saved auto-fix', { type:'success', sub:`"${heard}" → "${corrected}"`, duration: 1600 });
}

/** Apply all saved replacements to a normalized transcript */
function applyAutoFixes(tx){
  const map = readFixMap();
  let out = tx;
  for (const [h, c] of Object.entries(map)){
    const rx = new RegExp(`\\b${escapeRegex(h)}\\b`, 'g');  // whole-phrase, case-normalized
    out = out.replace(rx, c);
  }
  return out;
}

/** Get a canonical phrase string for a given flag key (first variant is best) */
function canonicalPhraseForKey(key){
  const f = FLAGS.find(x => x.key === key);
  return f?.variants?.[0] || f?.label || null;
}


/* ---------------- NLP core ---------------- */
function normalize(s){
  return String(s||'')
    .toLowerCase()
.replace(/[’‘']/g,'')            // "didn't" → "didnt"
.replace(/[^a-z0-9.\s-]/g,' ')

    .replace(/\s+/g,' ')
    .trim();
}
const NUM_WORDS = {
  zero:0, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9, ten:10,
  eleven:11, twelve:12, thirteen:13, fourteen:14, fifteen:15, sixteen:16, seventeen:17, eighteen:18, nineteen:19,
  twenty:20, half:0.5
};
function wordsToNumber(s){
  s=normalize(s);
  if(/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);
  const tok=s.split(/\s+/);
  const i=tok.indexOf('point');
  if(i>-1){
    const A=tok.slice(0,i).join(' ');
    const B=tok.slice(i+1).join(' ');
    const ia=NUM_WORDS[A]; const ib=NUM_WORDS[B];
    if(Number.isFinite(ia) && Number.isFinite(ib)) return +(ia + '.' + Math.round(ib*10));
  }
  if(s in NUM_WORDS) return NUM_WORDS[s];
  return NaN;
}

// Extracts a sequence of numbers like "5 4.5 3 10" or "five four point five three ten"
function extractNumberSequence(s){
  const tok = normalize(s).split(/[\s,]+/).filter(Boolean);
  const out = [];

  for (let i = 0; i < tok.length; i++){
    const t = tok[i];

    // ----- DIGITS (e.g., "7", "7.5", and "7 and a half") -----
    if (/^\d+(\.\d+)?$/.test(t)){
      let n = parseFloat(t);

      // digits + "and (a) half"
      if (tok[i+1] === 'and' && (tok[i+2] === 'half' || (tok[i+2] === 'a' && tok[i+3] === 'half'))){
        n = (isFinite(n) ? n : 0) + 0.5;
        i += (tok[i+2] === 'half' ? 2 : 3);
      }

      out.push(n);
      continue;
    }

    // ----- WORD NUMBERS -----
    if (t in NUM_WORDS){
      // word + "point X"
      if (tok[i+1] === 'point' && (tok[i+2] in NUM_WORDS || /^\d+$/.test(tok[i+2]))){
        const rhs = (tok[i+2] in NUM_WORDS) ? NUM_WORDS[tok[i+2]] : parseInt(tok[i+2], 10);
        const n   = wordsToNumber(`${t} point ${rhs}`);
        if (Number.isFinite(n)) out.push(n);
        i += 2;
        continue;
      }

      // word + "and (a) half"
      if (tok[i+1] === 'and' && (tok[i+2] === 'half' || (tok[i+2] === 'a' && tok[i+3] === 'half'))){
        const base = NUM_WORDS[t];
        if (Number.isFinite(base)) out.push(base + 0.5);
        i += (tok[i+2] === 'half' ? 2 : 3);
        continue;
      }

      // plain word number
      const n = wordsToNumber(t);
      if (Number.isFinite(n)) out.push(n);
    }
  }
  return out;
}


const ORD_WORDS = { first:1, second:2, third:3, fourth:4, fifth:5,
                    sixth:6, seventh:7, eighth:8, ninth:9, tenth:10 };
function romanToInt(s){
  // supports i..xl (1..40) safely; extend if you ever need more
  const map = {i:1, v:5, x:10, l:50, c:100, d:500, m:1000};
  const r = String(s||'').toLowerCase().replace(/[^ivxlcdm]/g,'');
  if (!r) return NaN;
  let total = 0, prev = 0;
  for (let i = r.length - 1; i >= 0; i--){
    const val = map[r[i]] || 0;
    total += (val < prev) ? -val : val;
    prev = val;
  }
  return total;
}
function wordToIndex(s){
  // number word (“two”), plain digit (“2”), ordinal word (“second”),
  // or roman numeral (“ii”, “iv”, “x”)
  const n = wordsToNumber(s);
  if (Number.isFinite(n)) return n;

  const key = normalize(s);
  if (ORD_WORDS[key]) return ORD_WORDS[key];

  if (/^[ivxlcdm]+$/i.test(key)){
    const r = romanToInt(key);
    if (Number.isFinite(r)) return r;
  }
  return NaN;
}



function findAddressedGroups(tx){
  // “mark 3 …”, “marks three …”, “blind 2 …”, “blind number four …”
  const RX = /\b(mark|blind)s?\s+(?:number\s+)?(one|two|three|four|five|six|seven|eight|nine|ten|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|[ivxlcdm]+|\d{1,2})\b/gi;

  const groups = [];
  let m;
  while ((m = RX.exec(tx)) !== null){
    const kind  = m[1].toLowerCase() === 'mark' ? 'Mark' : 'Blind';
    const idx   = Number.isFinite(+m[2]) ? +m[2] : wordToIndex(m[2]);
    const start = m.index + m[0].length;
    groups.push({ kind, index: idx, start, end: tx.length });
  }
  // set group ends to the next header’s start
  for (let i=0;i<groups.length-1;i++) groups[i].end = groups[i+1].start;
  return groups.filter(g => Number.isFinite(g.index) && g.index >= 1);
}

function parseGroupBody(txSlice){
  // Reuse your existing pieces on the slice:
  const { keys } = detectFlagsMulti(txSlice);
const isRemove = RX_REMOVE_VERB.test(txSlice);
const isAdd    = RX_ADD_VERB.test(txSlice);


  const add = new Set(), remove = new Set(), toggle = new Set();
  keys.forEach(k => {
    if (isRemove) remove.add(k);
    else if (isAdd) add.add(k);
    else toggle.add(k);
  });

  // Optional: support “score …” inside the group
  let score = null, adjust = 0, clearAll = /\bclear\s+flags?\b/.test(txSlice);
  const afterCmd = txSlice.match(/\b(?:score|rating|set|make)\b([\s\S]*)$/)?.[1]?.trim() || '';
  if (afterCmd){
    const nums = parseScoreListFlexible(afterCmd);
    if (nums.length >= 1) score = quant05(quantClamp(nums[0]));
  }
  // small +/- inside the group
  const inc = txSlice.match(/\b(increase|raise|up|\+|plus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  const dec = txSlice.match(/\b(decrease|lower|down|-|minus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  if (inc && !dec){
    const amt = inc[2] ? (Number.isFinite(wordsToNumber(inc[2])) ? wordsToNumber(inc[2]) : parseFloat(inc[2])) : 0.5;
    adjust += Number.isFinite(amt) ? amt : 0.5;
  }
  if (dec && !inc){
    const amt = dec[2] ? (Number.isFinite(wordsToNumber(dec[2])) ? wordsToNumber(dec[2]) : parseFloat(dec[2])) : 0.5;
    adjust -= Number.isFinite(amt) ? amt : 0.5;
  }

  return { add, remove, toggle, score, adjust, clearAll };
}



function quant05(n){ return Math.max(0, Math.min(10, Math.round(n*2)/2)); }

// treat digits or number-words as numeric (e.g., "nine", "seven point five")
function isNumberish(s){
  const t = normalize(s);
  if(!t) return false;
  if(/^\d+(\.\d+)?$/.test(t)) return true;
  return Number.isFinite(wordsToNumber(t));
}


function detectFlagsMulti(tx){
  const found=new Set();
  const hits=[]; // {key,start,end}
  for (const f of FLAGS){
    for (const rx of (FLAG_RX[f.key] || [])){
      rx.lastIndex = 0;
      let m;
      while ((m = rx.exec(tx)) !== null){
        found.add(f.key);
      }
    }
    // position by variants (first occurrence)
    let best=null;
    for (const v of f.variants){
      const ix = tx.indexOf(v);
      if (ix>=0 && (best==null || ix<best.start)){
        best = {start:ix, end:ix+v.length};
      }
    }
    if (best) hits.push({ key:f.key, start:best.start, end:best.end });
  }
  hits.sort((a,b)=>a.start-b.start);
  return { keys:[...found], hits };
}

// Already have parseSquashedScores() from earlier; keep it as-is.
// Add this helper to choose the best interpretation per your rules.

function parseScoreListFlexible(s){
  const spaced   = extractNumberSequence(s);   // e.g., ["8.5","103","6.5"] → [8.5, 103, 6.5]
  const squashed = parseSquashedScores(s);     // e.g., "8.5 103 6.5" → [8.5, 10, 3, 6.5]

  // Heuristics: prefer squashed if it explains more numbers or fixes >10 artifacts.
  const spacedHasBig = spaced.some(n => n > 10.0);
  if (squashed.length > spaced.length || spacedHasBig){
    return squashed;
  }
  return spaced;
}


/* Parse utterance → intents + missed phrases (between hits) */
function parseUtterance(raw){
  const tx = applyAutoFixes(normalize(raw));
  const intents = {
    add:new Set(), remove:new Set(), toggle:new Set(),
    clearAll:false, score:null, adjust:0, batchScores:[]
  };

  if (/\bclear\s+flags?\b/.test(tx)) intents.clearAll = true;

  // ----- SCORES / BATCH DETECTION -----
  const afterCmd = tx.match(/\b(?:scores?|rating|set|make)\b([\s\S]*)$/)?.[1]?.trim() || '';

  if (afterCmd){
    const nums = parseScoreListFlexible(afterCmd);
    if (nums.length > 1){
      intents.batchScores = nums.map(n => quant05(Math.max(0, Math.min(10, n))));
    } else if (nums.length === 1){
      intents.score = quant05(nums[0]);
    }
  } else {
    // Pure-number utterance → may be a single score OR a squashed list
    const onlyDigitsDots = /^[\d.\s]+$/.test(tx);
    if (onlyDigitsDots){
      const nums = parseScoreListFlexible(tx);
      if (nums.length > 1){
        intents.batchScores = nums.map(n => quant05(Math.max(0, Math.min(10, n))));
      } else if (nums.length === 1){
        intents.score = quant05(nums[0]);
      }
    } else if (/^\d+(\.\d+)?$/.test(tx) || Number.isFinite(wordsToNumber(tx))){
      intents.score = quant05(wordsToNumber(tx));
    }
  }

  // ----- ADJUSTMENTS (+/- by X; defaults to 0.5) -----
  const inc = tx.match(/\b(increase|raise|up|\+|plus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  const dec = tx.match(/\b(decrease|lower|down|-|minus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  if (inc && !dec){
    const amt = inc[2] ? (Number.isFinite(wordsToNumber(inc[2])) ? wordsToNumber(inc[2]) : parseFloat(inc[2])) : 0.5;
    intents.adjust += Number.isFinite(amt) ? amt : 0.5;
  }
  if (dec && !inc){
    const amt = dec[2] ? (Number.isFinite(wordsToNumber(dec[2])) ? wordsToNumber(dec[2]) : parseFloat(dec[2])) : 0.5;
    intents.adjust -= Number.isFinite(amt) ? amt : 0.5;
  }

  // ----- FLAGS -----
  const { keys, hits } = detectFlagsMulti(tx);
  const isAdd    = /\b(add|flag|set)\b/.test(tx);
  const isRemove = /\b(remove|clear|unset|delete)\b/.test(tx);

  for (const k of keys){
    if (isRemove) intents.remove.add(k);
    else if (isAdd) intents.add.add(k);
    else intents.toggle.add(k);
  }

  // ----- ADDRESSed GROUPS (Mark/Blind N …) -----
  const groups = findAddressedGroups(tx).map(g => {
    const body = tx.slice(g.start, g.end);
    const parsed = parseGroupBody(body);
    return {
      kind: g.kind,
      index: g.index,
      start: g.start,
      end: g.end,
      add: parsed.add,
      remove: parsed.remove,
      toggle: parsed.toggle,
      score: parsed.score,
      adjust: parsed.adjust,
      clearAll: parsed.clearAll
    };
  });

  // ----- MISSED PHRASES -----
  const missed = (hits.length >= 2) ? inferMissedSegments(tx, hits) : inferMissedLoose(tx, hits);

  // DEBUG
  console.groupCollapsed('%cNLP', 'color:#0b74ff;font-weight:700');
  console.log('raw:', raw);
  console.log('normalized:', tx);
  console.log('groups:', groups.map(g => ({ kind:g.kind, index:g.index, span:[g.start,g.end] })));
  console.log('batchScores:', intents.batchScores);
  console.log('score:', intents.score, 'adjust:', intents.adjust, 'clearAll:', intents.clearAll);
  console.log('add:', Array.from(intents.add));
  console.log('remove:', Array.from(intents.remove));
  console.log('toggle:', Array.from(intents.toggle));
  console.groupEnd();

  return { intents, missed, hits, keys, groups };
}





/* Heuristic: segments between detected flags that still have meaningful tokens */
const STOPWORDS = /\b(?:and|then|uh|um|a|an|the|please|flag|set|add|give|tag|check|activate|remove|clear|unset|delete|drop|kill|unflag|by|to|at|on|in|into|onto|with|plus|as\s+well\s+as|along\s+with|together\s+with|for|from|about|around|like|as|score|rating|make|turn|minus|up|down|of|this|that|there|here|it|him|her|them|they|their|his|hers|just)\b/gi;


function cleanSegment(seg){
  return seg.replace(/[^a-z0-9.\s-]/g,' ').replace(/\s+/g,' ').replace(STOPWORDS,' ').replace(/\s+/g,' ').trim();
}
function inferMissedSegments(tx, hits){
  const out = [];
  if (!hits.length) return out;

  const sorted = hits.slice().sort((a,b)=>a.start - b.start);

  // HEAD (before first hit)
  {
    const first = sorted[0];
    const head = cleanSegment(tx.slice(0, first.start));
    if (head && !isNumberish(head)) {
      const suggestion = bestSuggestion(head);
      out.push({
        raw: head,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: null,
        rightKey: first.key
      });
    }
  }

  // BETWEEN hits
  for (let i = 0; i < sorted.length - 1; i++){
    const a = sorted[i], b = sorted[i+1];
    if (b.start <= a.end) continue;
    const mid = cleanSegment(tx.slice(a.end, b.start));
    if (mid && !isNumberish(mid)) {
      const suggestion = bestSuggestion(mid);
      out.push({
        raw: mid,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: a.key,
        rightKey: b.key
      });
    }
  }

  // TAIL (after last hit)
  {
    const last = sorted[sorted.length - 1];
    const tail = cleanSegment(tx.slice(last.end));
    if (tail && !isNumberish(tail)) {
      const suggestion = bestSuggestion(tail);
      out.push({
        raw: tail,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: last.key,
        rightKey: null
      });
    }
  }

  return dedupeMissed(out);
}

function dedupeMissed(arr){
  const seen=new Set(); const out=[];
  for (const x of arr){
    const k=x.raw.toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k); out.push(x);
  }
  return out;
}

// treat the whole utterance (0 hits) or edge segments (1 hit) as candidates
function inferMissedLoose(tx, hits){
  const out = [];
  const addCand = (raw, leftKey=null, rightKey=null) => {
    const cleaned = cleanSegment(raw);
    if (!cleaned) return;
    // ignore numbers-only like "7" or "7.5"
    if (isNumberish(cleaned)) return;

    const suggestion = bestSuggestion(cleaned);
    out.push({
      raw: cleaned,
      suggestKey: suggestion?.key || null,
      suggestLabel: suggestion?.label || null,
      leftKey, rightKey
    });
  };

  if (hits.length === 0) {
    // no flags detected -> whole utterance is a candidate
    addCand(tx);
    return dedupeMissed(out);
  }

  if (hits.length === 1) {
    const h = hits[0];
    const pre  = tx.slice(0, h.start);
    const post = tx.slice(h.end);
    addCand(pre, null, h.key);
    addCand(post, h.key, null);
    return dedupeMissed(out);
  }

  return out; // fallback – shouldn't happen here
}


/* Fuzzy suggestion (Levenshtein) to nearest canonical phrase */
function lev(a,b){
  const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}
function bestSuggestion(seg){
  let best=null; const s=seg.toLowerCase();
  for (const f of FLAGS){
    for (const v of f.variants){
      const d = lev(s, v);
      const sim = 1 - d / Math.max(s.length, v.length);
      if (!best || sim > best.sim) best = { key:f.key, label:f.label, sim };
    }
  }
  return (best && best.sim >= 0.55) ? best : null; // threshold
}

let DOG_NAMES = [];
let selectedDog = localStorage.getItem('selectedDog') || null;
const dogNameEl = document.getElementById('dogName');
const dogHintEl = document.getElementById('dogHint');
const dogMicBtn = document.getElementById('dogMic');

// show persisted selection on load
if (selectedDog) dogNameEl.textContent = selectedDog;

// pull all names from every `layouts/*` doc you’re already writing in trailer.html
async function fetchDogNames(){
  const snap = await db.collection('layouts').get();
  const bucket = [];
  snap.forEach(doc => {
    const d = doc.data() || {};
    if (Array.isArray(d.masterNames)) bucket.push(...d.masterNames);
    if (Array.isArray(d.dockNames))   bucket.push(...d.dockNames);
    if (d.slotData && typeof d.slotData === 'object') {
      bucket.push(...Object.values(d.slotData).filter(Boolean));
    }
  });
  // unique + cleaned + sorted
  DOG_NAMES = [...new Set(bucket.map(n => String(n).trim()).filter(Boolean))]
               .sort((a,b)=>a.localeCompare(b));
  dogHintEl.textContent = DOG_NAMES.length
    ? `Say a name (${DOG_NAMES.length} loaded)`
    : `No names found in Firestore layouts`;
}
fetchDogNames().catch(err=>{
  console.error(err);
  dogHintEl.textContent = 'Failed to load names';
});

// similarity helper using your existing lev()
function sim(a,b){
  const A = normalize(a), B = normalize(b);
  if (!A || !B) return 0;
  const d = lev(A,B);
  return 1 - d / Math.max(A.length, B.length);
}

// find the best dog name for a transcript
function matchDogName(heard){
  const q = normalize(heard);
  if (!q) return null;

  // 1) exact token contain check (fast path)
  let exact = DOG_NAMES.find(n => q.includes(normalize(n)));
  if (exact) return exact;

  // 2) highest similarity
  let best = null;
  for (const n of DOG_NAMES){
    const s = sim(q, n);
    if (!best || s > best.s) best = { n, s };
  }
  // require a reasonably strong match
  return (best && best.s >= 0.72) ? best.n : null;
}

function setSelectedDog(name){
  selectedDog = name;
  dogNameEl.textContent = name;
  localStorage.setItem('selectedDog', name);

  cancelPendingSaves();        // ← NEW: stop any in-flight writes from previous dog
  closePeek?.();               // optional: avoids showing stale flags while switching
  closeMissed?.();             // optional

  document.dispatchEvent(new CustomEvent('dog:selected', { detail: { name } }));
}

// We’ll reuse your existing SpeechRecognition instance `rec`
let dogListenActive = false;

// attach the button
if (dogMicBtn){
  dogMicBtn.addEventListener('click', ()=>{
    if (!rec){ alert('Speech API not supported'); return; }
    try{ rec.abort(); }catch{}
    dogListenActive = true;
    // optional little UI cue
    dogMicBtn.classList.add('listening');
    setStatus('listening… (dog name)');
    rec.start();
  });
}

// Parse smooshed digit runs like "108.57.56" or "10835"
// Rules: (1) only "10" is two-digit, (2) decimals are ".5" only, else single digits.
function parseSquashedScores(str){
  // normalize, keep only digits and dots, make "point" a dot
  let s = normalize(str)
    .replace(/point/g, '.')      // spoken "point"
    .replace(/[^\d.]/g, '')      // keep 0-9 and .
    .replace(/\.+/g, '.');       // collapse accidental multiple dots

  if (!s) return [];

  const out = [];
  let i = 0;
  while (i < s.length){
    const ch = s[i];

    if (ch === '.'){ i++; continue; } // skip stray separators

    // "10" is the only two-digit number
    if (ch === '1' && s[i+1] === '0'){
      out.push(10); i += 2; continue;
    }

    // single digit
    if (/\d/.test(ch)){
      const d = ch.charCodeAt(0) - 48;

      // optional ".5" right after → halves only
      if (s[i+1] === '.'){
        if (s[i+2] === '5'){ out.push(d + 0.5); i += 3; continue; }

        // if some other decimal sneaks in, round to the closest half policy
        if (/\d/.test(s[i+2])){
          const dec = s[i+2].charCodeAt(0) - 48;
          out.push(d + (dec >= 5 ? 0.5 : 0));
          i += 3; continue;
        }
      }

      out.push(d); i += 1; continue;
    }

    i++; // safety
  }
  return out;
}


// Update the legacy list row UI (chips + tiny score) and keep stage in sync
function syncRow(it){
  const row = document.getElementById('row-' + it.id);
  if (!row) { 
    // still keep the stage/badge in sync even if the row list is hidden
    syncStageForItem?.(it);
    return; 
  }

  // chips
  row.querySelectorAll('.chip').forEach(ch => {
    const key = ch.dataset.key;
    ch.classList.toggle('on', !!(it.flags && it.flags[key]));
  });

  // tiny slider + score in the row (the list view is hidden but still present)
  const slider = row.querySelector('input[type="range"]');
  if (slider) slider.value = it.score ?? 0;

  const scoreEl = row.querySelector('.score');
  if (scoreEl) scoreEl.textContent = (it.score ?? 0).toFixed(1);

  // also update the big visible badge in the active pane
  syncStageForItem?.(it);
}



/* ---------------- Apply to row, then surface missed overlay + logging ---------------- */
function quantClamp(n){ return Math.max(0, Math.min(10, n)); }

// Update the on-screen pane (Mark or Blind) without re-rendering the whole stage
function syncStageForItem(it){
  const type = it.kind === 'Mark' ? 'mark' : 'blind';
  const slot = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if (!slot) return;

  // If an animation left 2 panes in the slot, take the topmost (last)
  const panes = slot.querySelectorAll('.pane');
  const pane = panes[panes.length - 1] || panes[0];
  if (!pane) return;

  const rangeEl  = pane.querySelector('input[type="range"]');
  const legacyEl = pane.querySelector('.score');       // hidden by CSS
  const badgeEl  = pane.querySelector('.scoreBadge');  // the big visible number

  if (rangeEl)  rangeEl.value = it.score;
  if (legacyEl) legacyEl.textContent = it.score.toFixed(1);
  if (badgeEl)  badgeEl.textContent  = it.score.toFixed(1);
}


function refreshVisiblePane(type){
  const isMark = (type === 'mark');
  const list   = items.filter(it => it.kind === (isMark ? 'Mark' : 'Blind'));
  if (!list.length) return;

  const idx  = isMark ? idxMark : idxBlind;
  const slot = ensureSlot(type);

  const newPane = renderPane(isMark ? 'Mark' : 'Blind', list[idx], list.length, type);
  const oldPane = slot.querySelector('.pane');
  if (oldPane) slot.replaceChild(newPane, oldPane);
  else slot.appendChild(newPane);
}

function refreshStage(){
  refreshVisiblePane('mark');
  refreshVisiblePane('blind');
}



function applyTranscript(itemId, raw){
  const it = items.find(x => x.id === itemId);
  if (!it) return;

  const parsed = parseUtterance(raw);
  const { intents, missed, groups } = parsed;

  // ----- Addressed group path (“Mark 3 …”, “Blind 2 …”) -----
  if (groups && groups.length){
    let applied = 0;
    const labels = [];

    for (const g of groups){
      const lane = items.filter(x => x.kind === g.kind);
      const target = lane[g.index - 1];  // 1-based spoken index

      if (!target){
        showToast(`No ${g.kind} #${g.index}`, { type:'error', duration: 1800 });
        continue;
      }

      if (g.clearAll) target.flags = {};
      g.add.forEach(k    => { target.flags[k] = true; });
      g.remove.forEach(k => { target.flags[k] = false; });
      g.toggle.forEach(k => { target.flags[k] = !target.flags[k]; });

      if (Number.isFinite(g.score)) target.score = g.score;
      if (g.adjust) target.score = quant05(quantClamp((target.score ?? 0) + g.adjust));

      syncRow(target);
      debouncedSaver(target.id)();
      applied++;
      labels.push(`${g.kind} #${g.index}`);
    }

    if (applied){
      refreshStage();
      showToast('✅ Applied to specific slots', {
        type:'success',
        size:'xxl',
        sub: labels.join(' • '),
        duration: 2600
      });
    }

    // We handled everything addressed; do not continue into the single/batch logic.
    return;
  }

  // ----- Batch scoring path (applies to the current pane onward) -----
  if (intents.batchScores && intents.batchScores.length){
    const start = it;
    const kind  = start.kind; // 'Mark' or 'Blind'
    const list  = items.filter(x => x.kind === kind);
    const startIdx = list.findIndex(x => x.id === itemId);

    let applied = 0;
    for (let i = 0; i < intents.batchScores.length; i++){
      const idx = startIdx + i;
      if (idx >= list.length) break;
      const target = list[idx];
      const v = quant05(Math.max(0, Math.min(10, intents.batchScores[i])));
      target.score = v;
      syncRow(target);
      debouncedSaver(target.id)();
      applied++;
    }

    refreshStage(); // keep UI in sync with the visible pane(s)

    return {
      batchApplied: applied,
      batchKind: kind,
      batchFrom: list[startIdx]?.title || '',
      batchTo: list[startIdx + Math.max(0, applied-1)]?.title || '',
      score: list[startIdx]?.score ?? null,
      added: [], removed: [], setScore: false, adjust: 0
    };
  }

  // ----- Normal single-item path (flags, single score, adjust, missed) -----
  const before = snapshotFlags(it);



  if (missed.length && (!intents.add.size && !intents.remove.size && !intents.toggle.size)){
    setStatus('No flags matched; queued ' + missed.length + ' missed phrase(s).');
  }

  if (intents.clearAll) it.flags = {};

  intents.add.forEach(k => it.flags[k] = true);
  intents.remove.forEach(k => it.flags[k] = false);
  intents.toggle.forEach(k => it.flags[k] = !it.flags[k]);

  if (Number.isFinite(intents.score)) it.score = intents.score;
  if (intents.adjust !== 0) it.score = quant05(it.score + intents.adjust);
  it.score = quantClamp(it.score);

  syncRow(it);
  syncStageForItem(it); // instantly reflect score on the visible pane
  debouncedSaver(itemId)();

  if (missed.length){
    for (const m of missed){
      addMissed(itemId, it.title, m.raw, m.suggestKey, m.suggestLabel);
      logUnassigned(m.raw);
    }
    renderMissedOverlay();
  }

  const after = snapshotFlags(it);
  const changed = diffFlags(before, after);

  return {
    added: changed.added,
    removed: changed.removed,
    setScore: Number.isFinite(intents.score),
    adjust: intents.adjust || 0,
    score: it.score
  };
}


function snapshotFlags(it){
  const on = Object.entries(it.flags||{}).filter(([k,v])=>!!v).map(([k])=>k);
  return { on: new Set(on) };
}
function diffFlags(before, after){
  const b=[...before.on], a=[...after.on];
  const added = a.filter(k=>!before.on.has(k));
  const removed = b.filter(k=>!new Set(a).has(k));
  // treat simple toggles as added for our purposes:
  return { added, removed, toggled: added };
}

/* ---------------- Missed overlay state ---------------- */
const missedOverlay = document.getElementById('missedOverlay');
const missedListEl = document.getElementById('missedList');
document.getElementById('missedClose').addEventListener('click', ()=> closeMissed());
document.getElementById('missedClear').addEventListener('click', ()=> { missedItems.length=0; renderMissedOverlay(); });

let missedItems = []; // { itemId, rowTitle, phrase, suggestKey?, suggestLabel? }
function addMissed(itemId, rowTitle, phrase, suggestKey, suggestLabel){
  const key = `${itemId}||${phrase.toLowerCase()}`;
  if (missedItems.some(x => `${x.itemId}||${x.phrase.toLowerCase()}`===key)) return;
  missedItems.push({ itemId, rowTitle, phrase, suggestKey, suggestLabel });
}
function removeMissed(itemId, phrase){
  missedItems = missedItems.filter(x => !(x.itemId===itemId && x.phrase.toLowerCase()===phrase.toLowerCase()));
}
function openMissed(){ 
  document.documentElement.classList.add('overlay-open');
  missedOverlay.classList.add('open'); 
  missedOverlay.setAttribute('aria-hidden','false'); 
}
function closeMissed(){ 
  missedOverlay.classList.remove('open'); 
  missedOverlay.setAttribute('aria-hidden','true'); 
  if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
}

function renderMissedOverlay(){
  missedListEl.innerHTML = '';
  if (!missedItems.length){ closeMissed(); return; }

  for (const m of missedItems){
    const row = document.createElement('div'); row.className='missed-item';
    const meta = document.createElement('div'); meta.className='missed-meta';
    meta.innerHTML = `
      <div class="missed-phrase">${m.phrase}</div>
      <div class="missed-row">Row: ${m.rowTitle}</div>
      ${m.suggestLabel ? `<div class="hint">Did you mean <b>${m.suggestLabel}</b>?</div>` : ''}
    `;
    const actions = document.createElement('div'); actions.className='missed-actions';
    const mic = document.createElement('button'); mic.className='btn small'; mic.innerHTML='🎤 Say again';
    mic.addEventListener('click', ()=> startFixListening(m.itemId, m.phrase, m.suggestKey||null));
    actions.appendChild(mic);

    if (m.suggestKey){
  const quick = document.createElement('button'); quick.className='btn small primary';
  quick.textContent = `✓ Apply ${m.suggestLabel}`;
  quick.addEventListener('click', ()=>{
    const it = items.find(x=>x.id===m.itemId); if (!it) return;
    it.flags[m.suggestKey] = true;
    const canon = canonicalPhraseForKey(m.suggestKey);
    if (canon) addAutoFix(m.phrase, canon);      // ← persist future auto-fix

    debouncedSaver(it.id)();
    syncRow(it);
    removeMissed(m.itemId, m.phrase);
    renderMissedOverlay();
  });
  actions.appendChild(quick);
}


    const dismiss = document.createElement('button'); dismiss.className='btn small';
    dismiss.textContent='Dismiss';
    dismiss.addEventListener('click', ()=>{ removeMissed(m.itemId, m.phrase); renderMissedOverlay(); });
    actions.appendChild(dismiss);

    row.append(meta, actions);
    missedListEl.appendChild(row);
  }
  openMissed();
}

/* ---------------- Master unassigned log (localStorage) ---------------- */
const LOG_KEY = 'speech_unassigned_log_v1';
function readLog(){ try{ return JSON.parse(localStorage.getItem(LOG_KEY)||'[]'); }catch{return[];} }
function writeLog(arr){ localStorage.setItem(LOG_KEY, JSON.stringify(arr)); }
function logUnassigned(phrase){
  const p = phrase.toLowerCase();
  const arr = readLog();
  const idx = arr.findIndex(x=>x.phrase===p);
  if (idx>=0){ arr[idx].count += 1; arr[idx].last = Date.now(); }
  else { arr.push({ phrase:p, count:1, last:Date.now() }); }
  writeLog(arr);
}
function clearLog(){ writeLog([]); }
function renderLog(){
  const listEl = document.getElementById('logList');
  listEl.innerHTML='';
  const arr = readLog().sort((a,b)=>b.count-a.count);
  if (!arr.length){
    const empty = document.createElement('div'); empty.className='hint'; empty.textContent='No data yet.';
    listEl.appendChild(empty); return;
  }
  arr.forEach(x=>{
    const row = document.createElement('div'); row.className='log-item';
    const left = document.createElement('div'); left.innerHTML = `<strong>${x.phrase}</strong>`;
    const right = document.createElement('div'); right.innerHTML = `<span class="count">${x.count}</span>`;
    row.append(left, right); listEl.appendChild(row);
  });
}

document.getElementById('viewLogBtn').addEventListener('click', ()=>{
  renderLog();
  document.documentElement.classList.add('overlay-open');
  logOverlay.classList.add('open');
});
document.getElementById('logClose').addEventListener('click', ()=>{
  logOverlay.classList.remove('open');
  if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
});

const logOverlay = document.getElementById('logOverlay');

/* ---------------- Clear all ---------------- */
document.getElementById('clearBtn').addEventListener('click',()=>{
  items.forEach(it=>{
    it.flags = {};
    it.score = 0;
    syncRow(it);
    debouncedSaver(it.id)();          // persist resets per item
  });
  missedItems.length = 0;
  renderMissedOverlay();
  renderStage();
  refreshStage();
  setStatus('cleared');
});

</script>
<div id="toasts" class="toasts" aria-live="polite" aria-atomic="true"></div>

</body>
</html>

