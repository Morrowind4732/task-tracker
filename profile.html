<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scoring</title>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
  :root { --gap:12px; --border:#ddd; --chip-bg:#f7f7f7; --accent:#0b74ff; }
  body { font-family: system-ui, sans-serif; margin: 16px; background:#f5f5f5; }
  .title-row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .mini-link { font-size:12px; color:var(--accent); text-decoration:underline; }
  .mini-link:visited { color:var(--accent); }
  .muted { color:#666; font-size:12px; }

  .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .btn.primary { background:var(--accent); border-color:var(--accent); color:#fff; }
  .btn.ghost { background:#fff; border-color:#ccc; }

  .section { border:1px solid var(--border); border-radius:12px; padding:12px; margin-top:14px; background:#fff; }

  /* Trainer picker overlay */
  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; align-items:center; justify-content:center; z-index:99999; }
  .overlay.open { display:flex; }
  .overlay-card { background:#fff; padding:18px; border-radius:12px; min-width:280px; border:1px solid #e5e5e5; box-shadow:0 10px 30px rgba(0,0,0,.2); }
  .overlay-card h3 { margin:0 0 10px; }
  .overlay-actions { display:flex; gap:10px; margin-top:12px; justify-content:space-between; }

  /* Tabs (setups + rerun tabs) */
  .tabs-bar { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .tabs { display:flex; align-items:flex-end; gap:6px; flex-wrap:wrap; }
  .tab { position:relative; padding:8px 12px; border:1px solid var(--border); border-bottom:none; border-top-left-radius:10px; border-top-right-radius:10px; background:#f6f6f6; cursor:pointer; font-weight:600; color:#444; }
  .tab.active { background:#fff; color:#111; box-shadow:0 -1px 0 #fff inset; }
  .tab.rerun { font-style:italic; }
  .tab:hover { background:#fdfdfd; }

  /* Mini pane tabs (Marks/Blinds) */
  .mini-tabs { display:flex; gap:6px; align-items:center; }
  .mini-tab { padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#f7f7f7; font-weight:600; cursor:pointer; }
  .mini-tab.active { background:#fff; border-color:#bbb; box-shadow:0 1px 0 rgba(0,0,0,.05); }

  /* Hero / dog card */
  .hero { display:grid; grid-template-columns: 120px 1fr; gap: 12px; align-items:center; }
  .hero img { width:120px; height:120px; object-fit:cover; border-radius:10px; border:1px solid #ccc; background:#fafafa; }

  /* Scoring list */
  .score-list { display:flex; flex-direction:column; gap:12px; }
  .score-card {
    border:1px solid #e2e2e2; border-radius:10px; padding:10px; background:#fafafa;
    display:grid; gap:8px; grid-template-columns: 1fr;
  }
  .score-header { display:flex; justify-content:space-between; align-items:center; gap:10px; }
  .score-title { font-weight:700; }
  .slider-row { display:flex; align-items:center; gap:10px; }
  .slider-row input[type="range"] { flex:1; }
  .slider-val { width:48px; text-align:right; font-variant-numeric: tabular-nums; }

  .flags { display:flex; flex-wrap:wrap; gap:8px; }
  .flag { display:flex; align-items:center; gap:6px; border:1px solid #ddd; background:#fff; padding:6px 8px; border-radius:999px; font-size:13px; }

  .actions { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .divider { height:1px; background:#eee; margin:12px 0; }
  .board-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  /* Scores header layout */
  .score-head{
    display:grid;
    grid-template-columns: 1fr auto; /* title left, rerun right */
    align-items:center;
    row-gap:8px;
  }
  .score-head #scoresTitle { grid-column: 1 / 2; }
  .score-head #rerunBtn    { grid-column: 2 / 3; justify-self:end; }
  .score-head .mini-tabs   { grid-column: 1 / -1; justify-content:flex-start; }

  /* Charts */
  .chart-head { display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
  .chart-range { display:flex; gap:12px; align-items:center; }
  
  /* --- Radial kennel navigator --- */
.k-fab {
  position: fixed; right:16px; bottom:16px;
  width:56px; height:56px; border-radius:50%;
  background: var(--accent); color:#fff; border:none;
  box-shadow:0 8px 20px rgba(0,0,0,.25); font-size:22px;
  cursor:pointer; z-index: 9998;
}
.k-overlay { position:fixed; inset:0; background:rgba(0,0,0,.25);
  display:none; align-items:center; justify-content:center; z-index:9999; }
.k-overlay.open { display:flex; }
.k-wheel {
  position: relative; width: 280px; height:280px; border-radius:50%;
  background:#fff; border:1px solid var(--border);
  box-shadow:0 12px 30px rgba(0,0,0,.25);
}
.k-center { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center; }
.k-center h4 { margin:0 0 4px; font-size:14px; }
.k-center .muted { font-size:12px; color:#666; }

.k-item {
  position:absolute; width:130px; height:84px; border-radius:12px;
  background:#fff; border:1px solid #ddd;
  box-shadow:0 10px 18px rgba(0,0,0,.12);
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:4px; text-align:center; padding:8px; cursor:pointer;
}
.k-item b { font-size:13px; max-width:120px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.k-item small { color:#666; font-size:11px; }
.k-item:hover { border-color:#bbb; }


/* extra space below the Marks/Blinds buttons */
.score-head { 
  margin-bottom: 12px;   /* tweak to taste */
}


</style>
</head>
<body>
  <div class="title-row">
    <h1>Scoring</h1>
    <a id="changeUserLink" class="mini-link" href="https://morrowind4732.github.io/task-tracker/scoring.html">change user</a>
  </div>
  <div class="muted" id="ctx">Loadingâ€¦</div>

  <!-- Trainer chooser overlay -->
  <div class="overlay" id="trainerOverlay">
    <div class="overlay-card">
      <h3>Who are you?</h3>
      <div class="overlay-actions">
        <button class="btn primary" data-trainer="Scott">Scott</button>
        <button class="btn primary" data-trainer="Cody">Cody</button>
        <button class="btn primary" data-trainer="Brian">Brian</button>
      </div>
    </div>
  </div>

  <!-- Tabs / day -->
  <div class="section">
    <div class="tabs-bar">
      <div class="board-controls" style="margin-right:auto;">
        <label>Day: <input type="date" id="dayPicker"></label>
        <button class="btn ghost" id="todayBtn">Today</button>
      </div>
      <div class="tabs" id="tabs"></div>
    </div>
  </div>
  
  
  <button id="kennelFab" class="k-fab" title="Open kennel navigator">â‡„</button>
<div id="kennelOverlay" class="k-overlay" aria-hidden="true">
  <div class="k-wheel">
    <div class="k-center">
      <h4 id="kCurName">â€”</h4>
      <div class="muted" id="kCurSlot">R?C?</div>
    </div>
    <!-- items get injected by JS -->
  </div>
</div>

  <!-- Dog hero -->
  <div class="section" id="dogCard">Loading dogâ€¦</div>
  
  



  <!-- Scores -->
  <div class="section" id="scoresSection">
    <div class="score-head">
      <strong id="scoresTitle"></strong>
      <button class="btn ghost" id="rerunBtn">Add Rerun</button>

      <div class="mini-tabs" id="paneTabs">
        <button class="mini-tab active" data-pane="marks">Marks</button>
        <button class="mini-tab" data-pane="blinds">Blinds</button>
      </div>
    </div>

    <div class="score-list" id="scoreList"></div>
    <div class="divider"></div>
    <div class="actions">
      <button class="btn primary" id="saveCameraBtn">ðŸ’¾ Save & Camera</button>
      <a class="btn" id="cameraOnlyBtn" href="https://morrowind4732.github.io/task-tracker/Camera.html">ðŸ“· Camera (no save)</a>
      <span class="muted" id="saveStatus"></span>
    </div>
  </div>

  <!-- Charts -->
  <div class="section">
    <div class="chart-head">
      <strong>Negatives over time</strong>
      <div class="chart-range">
        <label><input type="radio" name="negRange" value="7" checked> 7 Days</label>
        <label><input type="radio" name="negRange" value="30"> 1 Month</label>
      </div>
    </div>
    <div class="muted" id="chartSubtitle" style="margin:6px 0 10px">Shows % of items where each negative occurred (marks + blinds).</div>
    <canvas id="negativesChart" height="200"></canvas>
    <div class="muted" id="chartMeta" style="margin-top:8px"></div>
  </div>

  <!-- Firebase (v10 modules) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, onSnapshot, serverTimestamp,
      collection, query, orderBy, deleteDoc,
      collectionGroup, where, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    /* ---------------- Firebase init ---------------- */
    const firebaseConfig = {
      apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
      authDomain: "task-tracker-73b77.firebaseapp.com",
      projectId: "task-tracker-73b77",
      storageBucket: "task-tracker-73b77.firebasestorage.app",
      messagingSenderId: "795274673000",
      appId: "1:795274673000:web:0ea07130e45c72384134dd",
      measurementId: "G-VLW5KLY4FF"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    /* ---------------- Utilities ---------------- */
    const ctxEl = document.getElementById('ctx');
    function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
    function slug(s){
      return String(s||"").toLowerCase().trim()
        .replace(/[\s_]+/g,'-').replace(/[^a-z0-9-]/g,'')
        .replace(/-{2,}/g,'-').replace(/^-+|-+$/g,'');
    }
    function daysBackKey(n){ const d=new Date(); d.setDate(d.getDate()-n); return ymd(d); }
    const SAVE_DEBOUNCE_MS = 400;

    /* ---------------- Flags ---------------- */
    const FLAG_DEFS_MARKS = [
      { key:'headswing',       label:'Headswing' },
      { key:'shortCheckDown',  label:'Short Check Down' },
      { key:'overran',         label:'Overran' },
      { key:'bigHunt',         label:'Big Hunt' },
      { key:'handled',         label:'Handled' },
      { key:'castRefusal',     label:'Cast Refusal' },
      { key:'sitOnWhistle',    label:'Sit On Whistle' },
      { key:'backSideOfGun',   label:'Back Side of Gun' },
      { key:'break',           label:'Break' },
      { key:'skipped',         label:'Skipped' },
    ];
    const FLAG_DEFS_BLINDS = [
      { key:'poorInitial',     label:'Poor Initial' },
      { key:'scallop',         label:'Scallop' },
      { key:'castRefusal',     label:'Cast Refusal' },
      { key:'pickedUpPoison',  label:'Picked Up Poison' },
      { key:'hunted',          label:'Hunted' },
      { key:'ignoredWhistle',  label:'Ignored Whistle' },
      { key:'failedDiversion', label:'Failed Diversion' },
      { key:'skipped',         label:'Skipped' },
    ];

    // Unified map of flag -> label (marks labels take precedence where duplicated)
    const FLAG_LABELS = (() => {
      const map = {};
      [...FLAG_DEFS_MARKS, ...FLAG_DEFS_BLINDS].forEach(f => { if (!map[f.key]) map[f.key] = f.label; });
      return map;
    })();
    const ALL_FLAG_KEYS = Object.keys(FLAG_LABELS);

    /* ---------------- URL params (QR compatible) ---------------- */
    const params  = new URL(location.href).searchParams;
    const trailer = (params.get('trailer')||'').trim();
    const sex     = (params.get('sex')||'').trim();
    const slotNum = (params.get('slot')||'').trim();
    const trailerNorm = trailer.toLowerCase();
    const sexNorm     = sex.toLowerCase();
    const trailerCollection = `${trailerNorm}-${sexNorm}`;
    const trailerPrefix = trailerNorm.charAt(0).toUpperCase();
    const sexPrefix     = sexNorm.charAt(0).toUpperCase();
    const slotId        = `${trailerPrefix}_${sexPrefix}_${slotNum}`;
    if (!trailer || !sex || !slotNum) {
      document.getElementById('dogCard').textContent = "Missing trailer, sex, or slot in URL.";
      throw new Error("Missing QR params");
    }

    /* ---------------- Trainer picker ---------------- */
    const overlay = document.getElementById('trainerOverlay');
    const changeUserLink = document.getElementById('changeUserLink');
    changeUserLink.addEventListener('click', (e) => {
      e.preventDefault();
      const url = new URL(location.href);
      url.searchParams.delete('trainer');
      history.replaceState(null, '', url.toString());
      showTrainerPrompt();
    });

    function showTrainerPrompt(){
      overlay.classList.add('open');
      overlay.querySelectorAll('button[data-trainer]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          overlay.classList.remove('open');
          setTrainer(btn.dataset.trainer);
        }, {once:true});
      });
    }

    let trainerId = (new URL(location.href)).searchParams.get('trainer') || '';
    function setTrainer(name){
      trainerId = name;
      const url = new URL(location.href);
      url.searchParams.set('trainer', trainerId);
      history.replaceState(null, '', url.toString());
      ctxEl.textContent = `Trainer: ${trainerId}`;
      boot();
    }
    if (trainerId) ctxEl.textContent = `Trainer: ${trainerId}`;

    /* ---------------- Day + tabs (setups) ---------------- */
    const dayPicker = document.getElementById('dayPicker');
    const todayBtn  = document.getElementById('todayBtn');
    dayPicker.value = ymd(new Date());
    todayBtn.addEventListener('click', ()=>{ dayPicker.value = ymd(new Date()); switchDay(dayPicker.value); });
    dayPicker.addEventListener('change', ()=>switchDay(dayPicker.value));

    const tabsEl = document.getElementById('tabs');

    let currentDateKey = dayPicker.value;
    let setupsMeta = [];       // [{id,name,order}]
    let activeSetupId = null;  // setup doc id
    let activeRunId   = 'base';// 'base' or 'rerun'
    let rerunExists   = false; // rerun presence for active setup
    let activePane    = 'marks'; // 'marks' | 'blinds'

    // current dog
    let dog = { id:null, name:null, profile:null, photo:null };

    // listeners
    let unsubSetups = null;
    let unsubSetupDoc = null;
    let unsubScoreDocBase = null;
    let unsubScoreDocRerun = null;

    // items to render
    let setupItemsMarks = [];
    let setupItemsBlinds = [];

    // score state
    let scores = { marks:{}, blinds:{} };

    // Debounced save
    let saveTimer = null;
    function scheduleSave(){ clearTimeout(saveTimer); saveTimer = setTimeout(saveNow, SAVE_DEBOUNCE_MS); }

    /* ---------------- Firestore paths ---------------- */
    const dayDocPath = () => doc(db, "setups", trainerId, "days", currentDateKey);
    const setupsColl = () => collection(dayDocPath(), "setups");
    const setupDoc   = () => (activeSetupId ? doc(setupsColl(), activeSetupId) : null);

    // Kennel slot â†’ dog lookup
    const slotRef = doc(db, "trailerLayouts", `${trailerNorm}-${sexNorm}`, "slots", slotId);

    // Dog-centric runs
    const ratingsDayDoc = () => doc(db, "ratings", dog.id, "days", currentDateKey);
    const dogRunDoc = () => doc(db, "ratings", dog.id, "days", currentDateKey, "setups", activeSetupId, "runs", activeRunId);

    // Mirrors under setups
    const mirrorRunDoc = () => doc(db, "setups", trainerId, "days", currentDateKey, "setups", activeSetupId, "scores", dog.id, "runs", activeRunId);

    /* ---------------- Dog hero rendering ---------------- */
    const dogCard = document.getElementById('dogCard');
    function renderDogCard(){
      dogCard.innerHTML = `
        <div class="hero">
          <img src="${dog.photo||''}" alt="">
          <div>
            <h2 style="margin:0 0 4px">${dog.name || 'Unassigned'}</h2>
            <div class="muted">Trailer: ${trailer} Â· Sex: ${sex} Â· Slot: ${slotId}</div>
          </div>
        </div>
      `;
    }

    /* ---------------- Setup tabs ---------------- */
    function renderTabs(){
      tabsEl.innerHTML = '';
      setupsMeta.sort((a,b)=>(a.order??0)-(b.order??0)).forEach((m, idx)=>{
        const b = document.createElement('button');
        b.className = 'tab' + (m.id===activeSetupId && activeRunId==='base' ? ' active' : '');
        b.textContent = m.name || `Setup ${idx+1}`;
        b.addEventListener('click', ()=>setActiveSetup(m.id, 'base'));
        tabsEl.appendChild(b);

        if (m.id === activeSetupId && (rerunExists || activeRunId==='rerun')) {
          const r = document.createElement('button');
          r.className = 'tab rerun' + (activeRunId==='rerun' ? ' active':'');
          r.textContent = `Rerun ${m.name || `Setup ${idx+1}`}`;
          r.addEventListener('click', ()=>setActiveSetup(m.id, 'rerun'));
          tabsEl.appendChild(r);
        }
      });
    }

    /* ---------------- Pane tabs (Marks/Blinds) ---------------- */
    const paneTabs = document.getElementById('paneTabs');
    paneTabs.addEventListener('click', (e)=>{
      const btn = e.target.closest('.mini-tab'); if (!btn) return;
      const pane = btn.dataset.pane;
      if (pane && pane !== activePane) {
        activePane = pane;
        paneTabs.querySelectorAll('.mini-tab').forEach(b => b.classList.toggle('active', b.dataset.pane===activePane));
        renderScoresUIFromCurrentItems();
      }
    });

    /* ---------------- Scores UI ---------------- */
    const scoreList = document.getElementById('scoreList');
    const scoresTitle = document.getElementById('scoresTitle');
    const rerunBtn = document.getElementById('rerunBtn');
    const saveStatus = document.getElementById('saveStatus');

    function markLabel(item, idx){
      const n = (idx+1);
      const dist = typeof item.dist==='number' ? item.dist : 0;
      return `#${n} - ${dist} yards`;
    }
    function blindLabel(item, idx){
      const n = (idx+1);
      const dist = typeof item.dist==='number' ? item.dist : 0;
      return `#${n} - ${dist} yards`;
    }

    function renderScoresUI(items){
      scoreList.innerHTML = '';
      const paneName = activePane==='marks' ? 'Marks' : 'Blinds';
      const runName  = activeRunId==='base' ? 'Base' : 'Rerun';
      const setupName = (setupsMeta.find(s=>s.id===activeSetupId)?.name)||'Setup';
      scoresTitle.textContent = `${paneName} â€¢ ${runName} (${setupName})`;

      const defs = activePane==='marks' ? FLAG_DEFS_MARKS : FLAG_DEFS_BLINDS;
      const bucket = activePane==='marks' ? (scores.marks ||= {}) : (scores.blinds ||= {});

      items.forEach((item, idx)=>{
        const card = document.createElement('div');
        card.className = 'score-card';

        const head = document.createElement('div');
        head.className = 'score-header';

        const title = document.createElement('div');
        title.className = 'score-title';
        title.textContent = activePane==='marks' ? markLabel(item, idx) : blindLabel(item, idx);

        const sliderRow = document.createElement('div');
        sliderRow.className = 'slider-row';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0'; slider.max = '10'; slider.step = '0.5';
        const cur = bucket[item.id]?.score ?? 0;
        slider.value = String(cur);

        const out = document.createElement('div');
        out.className = 'slider-val';
        out.textContent = Number(cur).toFixed(1);

        slider.addEventListener('input', ()=>{
          const val = Number(slider.value);
          out.textContent = val.toFixed(1);
          (bucket[item.id] ||= { score:0, flags:{} }).score = val;
          scheduleSave();
        });

        sliderRow.append(slider, out);

        const flagsWrap = document.createElement('div');
        flagsWrap.className = 'flags';
        const flagsState = (bucket[item.id]?.flags) || {};
        defs.forEach(fd=>{
          const tag = document.createElement('label');
          tag.className = 'flag';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !!flagsState[fd.key];
          cb.addEventListener('change', ()=>{
            (bucket[item.id] ||= { score:0, flags:{} });
            bucket[item.id].flags[fd.key] = cb.checked;
            scheduleSave();
          });
          const span = document.createElement('span'); span.textContent = fd.label;
          tag.append(cb, span);
          flagsWrap.appendChild(tag);
        });

        head.append(title);
        card.append(head, sliderRow, flagsWrap);
        scoreList.appendChild(card);
      });

      rerunBtn.textContent = activeRunId==='rerun' ? 'Remove Rerun' : 'Add Rerun';
    }

    function renderScoresUIFromCurrentItems(){
      const items = activePane==='marks' ? setupItemsMarks : setupItemsBlinds;
      renderScoresUI(items);
    }

    /* ---------------- Rerun add/remove ---------------- */
    rerunBtn.addEventListener('click', async ()=>{
      if (!dog.id || !activeSetupId) return;
      if (activeRunId === 'rerun') {
        await Promise.allSettled([ deleteDoc(dogRunDoc()), deleteDoc(mirrorRunDoc()) ]);
        activeRunId = 'base';
        rerunExists = false;
        renderTabs();
        attachRunListeners();
      } else {
        const payload = {
          scores: { marks:{}, blinds:{} },
          trainer: trainerId, setupId: activeSetupId, runId: 'rerun',
          dogId: dog.id, dogName: dog.name || null, dateKey: currentDateKey,
          trailer: trailer, sex: sex, slotId,
          updatedAt: serverTimestamp()
        };
        await Promise.allSettled([
          setDoc(dogRunDoc(), payload, {merge:true}),
          setDoc(mirrorRunDoc(), payload, {merge:true})
        ]);
        activeRunId = 'rerun';
        rerunExists = true;
        renderTabs();
        attachRunListeners();
      }
    });

    /* ---------------- Saving ---------------- */
    async function saveNow(){
      if (!dog.id || !activeSetupId) return;
      saveStatus.textContent = 'Savingâ€¦';

      const setupName = (setupsMeta.find(s=>s.id===activeSetupId)?.name) || null;
      const payload = {
        scores,
        trainer: trainerId, setupId: activeSetupId, setupName,
        dogId: dog.id, dogName: dog.name || null,
        runId: activeRunId,
        dateKey: currentDateKey,
        trailer: trailer, sex: sex, slotId,
        updatedAt: serverTimestamp()
      };
      try {
        await Promise.all([
          setDoc(dogRunDoc(), payload, { merge:true }),
          setDoc(mirrorRunDoc(), payload, { merge:true }),
          setDoc(ratingsDayDoc(), { date: currentDateKey, trailer, sex, slotId, lastScoredAt: serverTimestamp(), trainer: trainerId }, { merge:true })
        ]);
        saveStatus.textContent = 'Saved.';
        setTimeout(()=>saveStatus.textContent='', 800);
      } catch (e) {
        console.error(e);
        saveStatus.textContent = 'Save failed.';
      }
    }

    document.getElementById('saveCameraBtn').addEventListener('click', async ()=>{
      await saveNow();
      location.href = "https://morrowind4732.github.io/task-tracker/Camera.html";
    });

    /* ---------------- Listeners: dog, setups, runs ---------------- */
    async function attachDogListener(){
      onSnapshot(slotRef, async (snap)=>{
        let profileData = null;
        dog = { id:null, name:null, profile:null, photo:null };
        if (snap.exists()) {
          const data = snap.data();
          dog.name = data.dogName || null;
          if (dog.name) {
            dog.id = slug(dog.name);
            const pSnap = await getDoc( doc(db, "profiles", dog.id) );
            if (pSnap.exists()) {
              profileData = pSnap.data();
              dog.profile = profileData;
              dog.photo = profileData.photo || null;
            }
          }
        }
        renderDogCard();
        if (trainerId) attachSetupsListener();
        // Refresh chart (if dog changed)
        updateNegativesChart(getRangeDays());
      });
    }

    async function attachSetupsListener(){
      if (!trainerId) return;
      if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups = null; }
      const qy = query(setupsColl(), orderBy('order'));
      unsubSetups = onSnapshot(qy, async (snap)=>{
        const arr = [];
        snap.forEach(d=>{
          const data = d.data()||{};
          arr.push({ id:d.id, name:data.name||'Setup', order: typeof data.order==='number'?data.order:9999 });
        });
        setupsMeta = arr;
        if (!activeSetupId && setupsMeta.length) activeSetupId = setupsMeta[0].id;
        renderTabs();
        attachSetupDocListener();
        attachRunListeners();
      });
    }

    function attachSetupDocListener(){
      if (!activeSetupId) return;
      if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc = null; }
      const ref = setupDoc();
      unsubSetupDoc = onSnapshot(ref, (snap)=>{
        const data = snap.data()||{};
        setupItemsMarks = Array.isArray(data.items)? data.items.map(it=>({ id: it.id, dist: typeof it.dist==='number' ? it.dist : 0 })) : [];
        setupItemsBlinds = Array.isArray(data.blinds)? data.blinds.map(it=>({ id: it.id, dist: typeof it.dist==='number' ? it.dist : 0 })) : [];
        renderScoresUIFromCurrentItems();
      });
    }

    function normalizeScoresShape(data){
      let out = { marks:{}, blinds:{} };
      if (data && data.scores) {
        const s = data.scores;
        if ('marks' in s || 'blinds' in s) {
          out.marks  = s.marks  || {};
          out.blinds = s.blinds || {};
        } else {
          out.marks = s || {};
          out.blinds = {};
        }
      }
      return out;
    }

    function attachRunListeners(){
      if (!dog.id || !activeSetupId) return;

      if (unsubScoreDocBase) { try{unsubScoreDocBase();}catch{} unsubScoreDocBase = null; }
      unsubScoreDocBase = onSnapshot( doc(db, "ratings", dog.id, "days", currentDateKey, "setups", activeSetupId, "runs", "base"), (snap)=>{
        if (activeRunId==='base') {
          scores = normalizeScoresShape(snap.data());
          renderScoresUIFromCurrentItems();
        }
      });

      if (unsubScoreDocRerun) { try{unsubScoreDocRerun();}catch{} unsubScoreDocRerun = null; }
      unsubScoreDocRerun = onSnapshot( doc(db, "ratings", dog.id, "days", currentDateKey, "setups", activeSetupId, "runs", "rerun"), (snap)=>{
        rerunExists = snap.exists();
        if (activeRunId==='rerun') {
          scores = normalizeScoresShape(snap.data());
        }
        renderTabs();
        renderScoresUIFromCurrentItems();
      });
    }

    async function setActiveSetup(id, runId){
      activeSetupId = id;
      activeRunId = runId || 'base';
      renderTabs();
      attachSetupDocListener();
      attachRunListeners();
      const snap = await getDoc(dogRunDoc());
      scores = normalizeScoresShape(snap.exists() ? snap.data() : null);
      renderScoresUIFromCurrentItems();
    }

    async function switchDay(key){
      currentDateKey = key;
      if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups=null; }
      if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc=null; }
      if (unsubScoreDocBase) { try{unsubScoreDocBase();}catch{} unsubScoreDocBase=null; }
      if (unsubScoreDocRerun) { try{unsubScoreDocRerun();}catch{} unsubScoreDocRerun=null; }

      setupsMeta = [];
      activeSetupId = null;
      activeRunId = 'base';
      rerunExists = false;
      scores = { marks:{}, blinds:{} };
      setupItemsMarks = [];
      setupItemsBlinds = [];
      renderTabs();
      renderScoresUI([]);

      if (trainerId) attachSetupsListener();
      updateNegativesChart(getRangeDays()); // keep charts in sync with date changes
    }

    /* ---------------- Charts: Negatives % ---------------- */
    const negativesCanvas = document.getElementById('negativesChart');
    const chartMeta = document.getElementById('chartMeta');
    let negativesChart = null;

    function getRangeDays(){
      const checked = document.querySelector('input[name="negRange"]:checked')?.value || '7';
      return checked === '30' ? 30 : 7;
    }
    document.querySelectorAll('input[name="negRange"]').forEach(r =>
      r.addEventListener('change', ()=> updateNegativesChart(getRangeDays()))
    );

    async function fetchRunsInRange(days){
      if (!dog.id) return [];
      const startKey = daysBackKey(days - 1);
      const endKey   = ymd(new Date());

      // Prefer an indexed collectionGroup query; fall back to client-side filter if needed
      try {
        const q = query(
          collectionGroup(db, 'runs'),
          where('dogId','==', dog.id),
          where('dateKey','>=', startKey),
          where('dateKey','<=', endKey)
        );
        const snap = await getDocs(q);
        return snap.docs.map(d => d.data() || {});
      } catch (e) {
        console.warn('Indexed query failed (likely missing composite index). Falling back to broader fetch+filter.', e);
        const q = query(collectionGroup(db, 'runs'), where('dogId','==', dog.id));
        const snap = await getDocs(q);
        return snap.docs.map(d => d.data() || {}).filter(r => r.dateKey >= startKey && r.dateKey <= endKey);
      }
    }

    function aggregateNegatives(runDocs){
      const counts = {};
      ALL_FLAG_KEYS.forEach(k => counts[k] = 0);
      let totalItems = 0;

      for (const r of runDocs) {
        const s = r.scores || {};
        const buckets = [s.marks || {}, s.blinds || {}];
        for (const bucket of buckets) {
          for (const entry of Object.values(bucket)) {
            totalItems += 1;
            const flags = entry?.flags || {};
            for (const key of ALL_FLAG_KEYS) {
              if (flags[key]) counts[key] += 1;
            }
          }
        }
      }
      return { counts, totalItems };
    }

    function renderNegativesChart(agg){
      const keys = ALL_FLAG_KEYS;
      const labels = keys.map(k => FLAG_LABELS[k]);
      const total = agg.totalItems || 0;
      const percents = keys.map(k => total ? +( (agg.counts[k] * 100) / total ).toFixed(1) : 0);

      if (negativesChart) negativesChart.destroy();
      negativesChart = new Chart(negativesCanvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: '% of items with issue',
              data: percents
            }
          ]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                label: (ctx) => `${ctx.parsed.x}%`
              }
            },
            legend: { display: false }
          },
          scales: {
            x: { min: 0, max: 100, ticks: { callback: v => v + '%' } },
            y: { ticks: { autoSkip: false } }
          }
        }
      });

      chartMeta.textContent =
        total
          ? `Based on ${total} item${total===1?'':'s'} (marks + blinds) in the selected window.`
          : 'No runs in the selected window yet.';
    }

    async function updateNegativesChart(days){
      const runs = await fetchRunsInRange(days);
      const agg = aggregateNegatives(runs);
      renderNegativesChart(agg);
    }

    /* ---------------- Boot ---------------- */
    async function boot(){
      if (!trainerId) return showTrainerPrompt();
      ctxEl.textContent = `Trainer: ${trainerId}`;
      await switchDay(ymd(new Date()));
      attachDogListener();
      updateNegativesChart(getRangeDays());
    }
	
	/* ========= Radial kennel navigator ========= */

/** Parse "R2C3" or "R2C3H" -> { r:2, c:3, half:true? } */
function parseRC(rc) {
  const m = /^R(\d+)C(\d+)(H)?$/i.exec(rc||'');
  return m ? { r:+m[1], c:+m[2], half: !!m[3] } : { r:NaN, c:NaN, half:false };
}
/** Format -> "R2C3" (+ 'H' if half true) */
function fmtRC(r,c,half=false){ return `R${r}C${c}${half?'H':''}`; }
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

/** Read trailerLayouts/<trailer>-<sex>/slots and build a map of id->dogName (keeps H docs too) */
async function fetchSlotsMap(sexNorm) {
  const key = `${trailerNorm}-${sexNorm}`;
  const snaps = await getDocs(collection(db, "trailerLayouts", key, "slots"));
  const map = {};
  snaps.forEach(d => {
    // ids look like S_M_R1C1 or S_M_R1C1H; keep last part exactly as-is
    const rc = d.id.split("_").slice(2).join("_"); // "R1C1" or "R1C1H"
    map[rc] = (d.data() || {}).dogName || "";
  });
  return map;
}

/** Discover max rows/cols present in a slots map (ignores H) */
function boundsFromMap(map){
  let maxR = 1, maxC = 1;
  Object.keys(map||{}).forEach(k=>{
    const m = /^R(\d+)C(\d+)/i.exec(k);
    if (m){ maxR = Math.max(maxR, +m[1]); maxC = Math.max(maxC, +m[2]); }
  });
  return { maxR, maxC };
}

const overlayEl = document.getElementById('kennelOverlay');
const wheelEl   = overlayEl.querySelector('.k-wheel');
const fabEl     = document.getElementById('kennelFab');
const kCurNameEl= document.getElementById('kCurName');
const kCurSlotEl= document.getElementById('kCurSlot');

let slotsMale=null, slotsFemale=null;
let maleBounds={maxR:2,maxC:8}, femaleBounds={maxR:2,maxC:8}; // safe defaults
let longPressTimer=null;

/** Ensure both sides are loaded and bounds computed */
async function ensureLayouts() {
  if (!slotsMale)   { slotsMale   = await fetchSlotsMap('male');   maleBounds   = boundsFromMap(slotsMale); }
  if (!slotsFemale) { slotsFemale = await fetchSlotsMap('female'); femaleBounds = boundsFromMap(slotsFemale); }
}

/** Look up the display name, trying rc first then rcH. Returns {name, rcUsed} */
function lookupName(rc, sexN){
  const map = (sexN==='male') ? slotsMale : slotsFemale;
  const first = map?.[rc] || "";
  if (first) return { name:first, rcUsed:rc };
  const rcH = rc.endsWith('H') ? rc : (rc + 'H');
  const second = map?.[rcH] || "";
  return { name: (second || 'â€” Empty â€”'), rcUsed: (second ? rcH : rc) };
}

/** Mirror columns when swapping sex, using the TARGET side's maxC */
function mirrorRC(rc, toSex){
  const { r, c } = parseRC(rc);
  const b = (toSex==='female') ? femaleBounds : maleBounds;
  const mc = b.maxC || 1;
  const mirroredC = clamp(mc - c + 1, 1, mc);
  return fmtRC(clamp(r,1,b.maxR||1), mirroredC);
}

/** Compute neighbor targets around current {rc, sex} */
function neighbors(rc, sexN) {
  const { r, c } = parseRC(rc);
  const sameBounds = (sexN==='male') ? maleBounds : femaleBounds;
  const opp = (sexN==='male') ? 'female' : 'male';

  const leftC  = clamp(c-1, 1, sameBounds.maxC);
  const rightC = clamp(c+1, 1, sameBounds.maxC);
  const upR    = clamp(r-1, 1, sameBounds.maxR);

  return [
    { key:'left',  label:'Left',   rc: fmtRC(r, leftC),  sex:sexN },
    { key:'right', label:'Right',  rc: fmtRC(r, rightC), sex:sexN },
    { key:'up',    label:'Up',     rc: fmtRC(upR, c),    sex:sexN },
    // swap to opposite sex with mirrored column
    { key:'swap',  label:(opp==='female'?'Female':'Male'), rc: mirrorRC(rc, opp), sex:opp }
  ];
}

/** Open wheel, place four items, each using rcH fallback if needed */
async function openWheel() {
  await ensureLayouts();

  // Use URL context
  const rc = slotNum;      // e.g. "R2C3" or "R2C3H"
  const sexN = sexNorm;    // 'male' | 'female'
  const curr = lookupName(rc, sexN);
  const curName = dog?.name || curr.name;

  kCurNameEl.textContent = curName || 'Unassigned';
  kCurSlotEl.textContent = curr.rcUsed;

  // clear prior items
  wheelEl.querySelectorAll('.k-item').forEach(n => n.remove());

  const items = neighbors(rc, sexN).map(n => {
    const info = lookupName(n.rc, n.sex);
    return { ...n, dogName: info.name, rcUsed: info.rcUsed };
  });

  function addItem(dx, dy, title, rcUsed, sex, displayName){
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'k-item';
    btn.style.left = '50%';
    btn.style.top  = '50%';
    btn.style.transform = `translate(-50%,-50%) translate(${dx}px, ${dy}px)`;
    btn.innerHTML = `<b>${displayName || 'â€”'}</b><small>${title} Â· ${sex==='female'?'â™€':'â™‚'} Â· ${rcUsed}</small>`;
    btn.addEventListener('click', ()=> {
      const url = new URL(location.href);
      url.searchParams.set('sex', sex);
      url.searchParams.set('slot', rcUsed);       // navigate to real slot, using H if thatâ€™s where the dog lives
      location.href = url.toString();
    });
    wheelEl.appendChild(btn);
  }

  const R = 100; // radius from center
  addItem(-R, 0,           'Left',   items[0].rcUsed, items[0].sex, items[0].dogName);
  addItem( R, 0,           'Right',  items[1].rcUsed, items[1].sex, items[1].dogName);
  addItem( 0, -R,          'Up',     items[2].rcUsed, items[2].sex, items[2].dogName);
  addItem( 0,  R,   items[3].label,  items[3].rcUsed, items[3].sex, items[3].dogName);

  overlayEl.classList.add('open');
  overlayEl.setAttribute('aria-hidden', 'false');
}

function closeWheel(){
  overlayEl.classList.remove('open');
  overlayEl.setAttribute('aria-hidden', 'true');
}

/* FAB open */
fabEl.addEventListener('click', openWheel);
/* Click outside to close */
overlayEl.addEventListener('click', (e)=> { if (e.target === overlayEl) closeWheel(); });
/* Long press on dog card to open (mobile) */
dogCard.addEventListener('pointerdown', () => { longPressTimer = setTimeout(openWheel, 450); });
['pointerup','pointerleave','pointercancel','dragstart'].forEach(ev=>{
  dogCard.addEventListener(ev, ()=>{ clearTimeout(longPressTimer); });
});
/* ========= /radial ========= */



    if (trainerId) boot(); else showTrainerPrompt();
  </script>
</body>
</html>
