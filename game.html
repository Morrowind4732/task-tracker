<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Deck Table ‚Äî Mobile (hand carousel + stacks + actions)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<link rel="stylesheet" href="mana-master/css/mana.css">

<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<style>
  :root{
    /* Theme + sizing tokens. Kept the same so existing styles/layout keep working. */
    --bg:#0e1015; --fg:#e7e9ee; --muted:#9aa3b2; --accent:#6aa9ff;
    --card-w:223px; --card-h:310px; --hint-w:320px; --inv-scale:1;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--fg); background:#0e1015;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    display:grid; grid-template-rows: 64px auto auto 1fr; grid-template-columns: 1fr;
  }

  /* Top bar */
  .topbar{
    display:flex; gap:10px; align-items:center; padding:10px 12px;
    border-bottom:1px solid #1f2738; background:linear-gradient(180deg,#10141b,#0c1117);
    position:sticky; top:0; z-index:5;
  }
  .hamb{
    width:42px; height:42px; border-radius:12px; border:1px solid #24324a; background:#111826;
    display:flex; align-items:center; justify-content:center; cursor:pointer;
  }
  .hamb span,.hamb span:before,.hamb span:after{
    content:""; display:block; width:18px; height:2px; background:#cfe1ff; position:relative;
  }
  .hamb span:before{position:absolute; top:-6px; content:"";}
  .hamb span:after{position:absolute; top:6px; content:"";}
  button{
    border:0; background:var(--accent); color:#091323; font-weight:700; padding:9px 14px;
    border-radius:12px; cursor:pointer; box-shadow:0 8px 20px rgba(106,169,255,.25);
  }
  .pill{background:#1b2a47; color:#d8e7ff}
  .count{margin-left:auto; color:#b9c7e8; font-weight:700}

  /* Drawer */
  .drawer-wrap{ overflow:hidden; transition:max-height .28s ease; border-bottom:1px solid #1f2738; }
  .drawer{ padding:10px 12px; background:#0b0f15; }
  .drawer-wrap.collapsed{ max-height:0; border-bottom-color:transparent; }
  .drawer-wrap.expanded{ max-height:320px; }
  textarea{
    width:100%; height:160px; resize:vertical; padding:10px;
    border-radius:12px; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee;
    font:14px/1.45 ui-monospace, Menlo, Consolas, monospace;
  }

  /* Table + world */
  .table{position:relative; overflow:hidden; background:linear-gradient(180deg,#0d3a1e,#0a2716 40%, #092113); touch-action:none;}
  .world{position:absolute; inset:0; transform-origin:0 0; touch-action:none;}
  .zone{
    position:absolute; border:2px dashed rgba(255,255,255,.18); border-radius:12px;
    background:rgba(0,0,0,.12); user-select:none; display:flex; align-items:center; justify-content:center;
  }
  .zone .label{ color:#c9cfdb; font-size:16px; transform:scale(var(--inv-scale)); transform-origin:center; pointer-events:none;}
  

  /* Hand zone anchored into the world with transform math */
  .handZone{ pointer-events:auto; }
  .handZone .label{ opacity:.75 }

  /* Cards */
  .card{position:absolute; width:var(--card-w); height:var(--card-h); border-radius:14px; user-select:none; touch-action:none; outline:none; pointer-events:none;}
  .card.selected .cardBody{ outline:3px solid #6aa9ff; outline-offset:2px; }
  .cardBody{position:absolute; inset:0; transform-origin:center; transition:transform .2s ease; box-shadow:0 10px 26px rgba(0,0,0,.5); cursor:grab; pointer-events:auto;}
  .card3d{position:absolute; inset:0; perspective:1000px}
  .inner{position:absolute; inset:0; transform-style:preserve-3d; transition:transform .6s cubic-bezier(.2,.6,.2,1)}
  .flipped .inner{transform:rotateY(180deg)}
  .face{position:absolute; inset:0; border-radius:14px; overflow:hidden; backface-visibility:hidden; background:#06080e}
  .face img{width:100%; height:100%; object-fit:cover; display:block; pointer-events:none; -webkit-user-drag:none}
  .back{transform:rotateY(180deg)}

  /* Floating actions (right side) */
  .actions{
  position:fixed; right:10px; top:50%;
  transform:translateY(-50%);
  display:flex; flex-direction:column; gap:8px;
  z-index: var(--z-controls); /* sits above #hint */
}

  .fab{width:52px; height:52px; border-radius:50%; background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63; display:flex; align-items:center; justify-content:center; font-weight:900; font-size:20px;}
  .fab.chat { font-size:18px; }

  /* Tooltip */
.hint{
  position:fixed;
  /* we now position this dynamically above the in-hand center card */
  width:var(--hint-w);
  background:rgba(10,14,22,.98);
  border:1px solid #24324a;
  border-radius:12px;
  padding:10px;
  box-shadow:0 12px 28px rgba(0,0,0,.6);
  display:none; 
  z-index: var(--z-tooltip);
}
.hint h3{margin:0 0 4px; font-size:14px; color:#dbe5ff}
.hint .meta{font-size:12px; color:#b9c3d9; margin-bottom:6px}
.hint .txt{font-size:12px; color:#cfdbf3; white-space:pre-wrap; max-height:160px; overflow:auto}


  /* Hand carousel visuals (slots) */
  .in-hand{ pointer-events:auto; }
  .hand-slot{ position:absolute; top:50%; transform:translate(-50%,-50%); }
  .hand-left { left:28%; }
  .hand-center{ left:50%; }
  .hand-right{ left:72%; }
  /* extra visible neighbors (as requested) */
  .hand-l2 { left:16%; }
  .hand-l3 { left:4%;  }
  .hand-r2 { left:84%; }
  .hand-r3 { left:96%; }

  .hand-small .cardBody{ transform:scale(.72); }
  .hand-center .cardBody{ transform:scale(1); }
  .hand-hidden{ opacity:0; pointer-events:none; }

  /* Make sure our in-hand card captures gestures (prevents table panning steals) */
  .in-hand .cardBody { touch-action: none; }

  /* Stack popout */
  .stack-wrapper { position: relative; }
  .stack-actions{
    position: absolute; right: 62px; top: 50%; transform: translateY(-50%);
    display: none; flex-direction: column; gap: 8px; z-index: 7;
  }
  .stack-wrapper.open .stack-actions{ display: flex; }

  .sbtn{
    width: 44px; height: 44px; border-radius: 12px; background:#1a2a45; color:#cfe1ff;
    border:1px solid #2b3f63; display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size:18px; cursor:pointer; box-shadow:0 8px 20px rgba(106,169,255,.18);
  }
  .sbtn.on{ outline:2px solid #6aa9ff; box-shadow:0 0 0 6px rgba(106,169,255,.18) inset; }

  .fab:active, .sbtn:active { transform: scale(0.98); }
  
  /* Creature P/T badge */
.pt-badge{
  position:absolute; right:6px; bottom:6px;
  transform:scale(var(--inv-scale)); transform-origin: bottom right;
  background:rgba(8,12,20,.85); border:1px solid #2b3f63; border-radius:10px;
  padding:3px 6px; font-weight:800; font-size:14px; color:#e7f0ff;
  text-shadow:0 1px 0 rgba(0,0,0,.4); pointer-events:none;
}
.in-hand .pt-badge{ display:none; } /* hide in hand */

  /* put this anywhere in your <style> block */
.hint .mana-line .ms{ 
  font-size:16px; 
  line-height:1; 
  vertical-align:-0.12em; 
  margin-right:2px;
}

/* put this in your <style> */
.hint .txt .ms{
  font-size:18px;         /* bump if you like it bigger on mobile */
  line-height:1;
  vertical-align:-0.14em; /* nudge baseline so they sit nicely in text */
  margin:0 1px;
}

/* === Player / Viewer popouts === */
.actions-top, .actions-bottom { z-index: var(--z-controls); }
.actions-top{ top:10px; }
.actions-bottom{ bottom:10px; }

.player-wrapper, .view-wrapper{ position:relative; }
.player-actions, .view-actions{
  position:absolute; right:62px; top:50%; transform:translateY(-50%);
  display:none; gap:8px; z-index: var(--z-controls);
}
.player-wrapper.open .player-actions,
.view-wrapper.open .view-actions{ display:flex; }

.pbtn{ /* little square ‚Äú1 2 3‚Äù chips */
  width:44px; height:44px; border-radius:12px; background:#1a2a45; color:#cfe1ff;
  border:1px solid #2b3f63; font-weight:900; font-size:16px; cursor:pointer;
  display:flex; align-items:center; justify-content:center; box-shadow:0 8px 20px rgba(106,169,255,.18);
}
.pbtn.on{ outline:2px solid #6aa9ff; box-shadow:0 0 0 6px rgba(106,169,255,.18) inset; }

.fab svg{ display:block }

/* Viewer mode: make table cards read-only so you can't edit other players */
body.viewer .card .cardBody {
  pointer-events: none !important;
  cursor: default !important;
}

/* Viewer mode: make table cards read-only so you can't edit other players */
body.viewer .card .cardBody {
  pointer-events: none !important;
  cursor: default !important;
}

/* === Chat overlay === */
.chatOverlay{
  position:fixed; inset:0; z-index:10000;
  background:rgba(6,10,16,.7);
  display:none;
}
.chatPanel{
  position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(720px, 94vw); height:min(540px, 80vh);
  display:flex; flex-direction:column;
  background:rgba(12,18,28,.98); border:1px solid #24324a; border-radius:14px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
}
.chatHeader{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 14px; border-bottom:1px solid #1f2738; color:#dbe5ff; font-weight:800;
}
.chatClose{ cursor:pointer; background:#1a2a45; border:1px solid #2b3f63; color:#cfe1ff; border-radius:10px; width:36px; height:32px; font-weight:900; }
.chatLog{
  flex:1; overflow:auto; padding:12px; gap:8px; display:flex; flex-direction:column;
}
.chatLine{
  display:grid; grid-template-columns:auto 1fr auto auto; gap:8px; align-items:center;
  font-size:14px; color:#cfdbf3; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:8px 10px;
}
.chatWho{ font-weight:800; color:#dbe5ff; }
.chatText{ white-space:pre-wrap; }
.chatTime{ opacity:.7; font-size:12px; }
.chatDel{
  width:28px; height:28px; border-radius:8px; background:#2a1a1a; color:#ffd1d1;
  border:1px solid #5a2e2e; font-weight:900; cursor:pointer;
}
.chatInputRow{
  display:flex; gap:8px; padding:10px; border-top:1px solid #1f2738;
}
#chatInput{
  flex:1; border-radius:12px; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee; padding:10px; font:14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
}
#chatSend{
  border:0; background:var(--accent); color:#091323; font-weight:800; padding:10px 14px; border-radius:12px; cursor:pointer; box-shadow:0 8px 20px rgba(106,169,255,.25);
}

/* === Toast for ‚Äúnew message‚Äù announce === */
.toast{
  position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
  background:rgba(14,20,32,.98); color:#e7f0ff;
  border:1px solid #2b3f63; border-radius:12px; padding:10px 14px;
  box-shadow:0 12px 28px rgba(0,0,0,.5); z-index:11000; display:none; max-width:90vw;
}

/* === Card gear + Edit overlay === */
.card .gear-btn{
  position:absolute; left:6px; bottom:6px;
  transform:scale(var(--inv-scale)); transform-origin: bottom left;
  width:28px; height:28px; border-radius:50%;
  border:1px solid #2b3f63; background:rgba(8,12,20,.85); color:#cfe1ff;
  display:flex; align-items:center; justify-content:center; font-size:16px;
  cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,.25);
}
.card .gear-btn:active{ transform:scale(calc(var(--inv-scale) * .96)); }

#editOverlay{
  position:fixed; inset:0; z-index:99999;
  display:none; align-items:center; justify-content:center;
  background:rgba(0,0,0,.60);
}
#editOverlay .panel{
  width:min(520px, 92vw);
  background:linear-gradient(180deg,#0d1118,#0a0f16);
  border:1px solid #24324a; border-radius:14px; padding:14px;
  color:#e7e9ee; box-shadow:0 24px 48px rgba(0,0,0,.5);
  max-height:80vh; overflow:auto; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
}
#editOverlay h3{ margin:0 0 8px; font-size:16px; }
#editOverlay .row{ display:grid; grid-template-columns: 140px 1fr; gap:10px; align-items:start; margin:8px 0; }
#editOverlay label{ color:#b9c3d9; font-size:12px; padding-top:8px; }
#editOverlay input[type="text"], #editOverlay textarea, #editOverlay input[type="number"]{
  width:100%; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee; border-radius:10px; padding:8px;
  font:13px/1.4 ui-monospace, Menlo, Consolas, monospace;
}
#editOverlay textarea{ min-height:72px; resize:vertical; }
#editOverlay .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
#editOverlay .btn{ border:0; border-radius:10px; padding:9px 12px; font-weight:700; cursor:pointer; }
#editOverlay .btn.save{ background:#6aa9ff; color:#091323; }
#editOverlay .btn.cancel{ background:#1b2a47; color:#d8e7ff; }


/* Only show the gear when JS toggles .show-gear on that specific card */
.card .gear-btn{ display:none; }
.card.show-gear .gear-btn{ display:flex; }

:root{
  /* ‚Ä¶your existing tokens‚Ä¶ */
  --z-tooltip: 7;
  --z-controls: 9999; /* above tooltip */
}

/* === Player-count (#) popout === */
.num-wrapper{ position:relative; }
.num-actions{
  position:absolute; right:62px; top:50%; transform:translateY(-50%);
  display:none; gap:8px; z-index: var(--z-controls);
}
.num-wrapper.open .num-actions{ display:flex; }

/* Life strip (under top bar) */
.life-strip{
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr; /* we hide the 3rd cell for 2 players */
  gap: 8px;
  padding: 6px 10px 8px;
}
.life-cell{
  background:#0f141c;
  border:1px solid #2b3344;
  border-radius:12px;
  padding:8px 10px;
  display:flex; align-items:center; justify-content:space-between;
  min-height:42px;
}
.life-cell .life-label{ opacity:.85; font-size:.9rem }
.life-cell .life-value{ font-weight:800; font-size:1.2rem }

/* Drawer tool row */
.drawer-tools{ display:flex; gap:8px; padding:6px 8px 4px }
.btn.sm{ padding:6px 10px; border-radius:10px; border:1px solid #2b3344; background:#141a24; font-weight:600 }
.btn.sm:active{ transform:translateY(1px) }


/* === Vertical zoom slider: forced rotate + fixed position === */
.zoomWrap{
  position: fixed;
  left: 12px;              /* nudge horizontally */
  bottom: 180px;           /* sit above your hand; tweak as needed */
  z-index: var(--z-controls);
  width: 32px;             /* visible column width */
  height: 260px;           /* visible column height (slider length) */
  pointer-events: auto;
}

/* Center the slider inside the column and rotate it so it's vertical */
#zoomSlider{
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%) rotate(-90deg);
  transform-origin: center;

  /* sizing AFTER rotation:
     width = visual length, height = visual thickness */
  width: 260px;            /* length of the vertical slider */
  height: 28px;            /* thickness of the control */

  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  outline: none;
  touch-action: none;      /* avoid page scroll while sliding */
}

/* Track */
#zoomSlider::-webkit-slider-runnable-track{
  height: 6px; border-radius: 4px; background:#23324d;
}
#zoomSlider::-moz-range-track{
  height: 6px; border-radius: 4px; background:#23324d;
}

/* Thumb */
#zoomSlider::-webkit-slider-thumb{
  -webkit-appearance: none;
  width: 16px; height: 16px; border-radius: 50%;
  background:#6aa9ff; border:2px solid #0a1426; cursor: pointer;
  /* slight vertical centering for rotated control */
  transform: translateY(-5px);
}
#zoomSlider::-moz-range-thumb{
  width: 16px; height: 16px; border-radius: 50%;
  background:#6aa9ff; border:2px solid #0a1426; cursor: pointer;
}

/* If you keep the +/‚àí marks, stack them beside the column */
.zoomMarks{
  position:absolute;
  left: -14px;                 /* position the marks just outside the column */
  top: 50%;
  transform: translateY(-50%);
  display:flex; flex-direction:column; gap:8px;
  user-select:none; font-weight:700;
}

/* Show the zoom slider only when the deck input drawer is hidden */
.zoomWrap { display: block; }                  /* default = visible */
.drawer-wrap.expanded ~ .zoomWrap { display: none; }  /* hide while drawer is open */

/* Life overlay controls */
.overlay .btn.sm{
  background:#1b2433;
  color:#dbe6ff;
  border:1px solid #2b3344;
  box-shadow:none;
  min-width:44px;        /* tight chip width */
  padding:8px 10px;
}
.overlay .btn.sm:hover{ background:#233049; }
.overlay input[type="number"]{ height:40px; }

/* ===== AUTHORITATIVE ZONE PLACEMENT ‚Äî no overlap ===== */
:root{
  /* Commander (already good) */
  --CMD_X:  60px;
  --CMD_Y:  80px;

  /* Graveyard pinned to bottom-left column */
  --GY_X:   520px;
  --GY_Y:    0px;   /* smaller = closer to bottom = bigger vertical gap */

  /* Exile pinned to top-left column (same X) */
  --EX_X:   520px;
  --EX_TOP:  -400px;   /* smaller = closer to top = bigger vertical gap */
}

/* Commander */
.commander{
  left: var(--CMD_X) !important;
  bottom: var(--CMD_Y) !important;
  top:auto !important; right:auto !important;
  width:170px; height:120px;
}

/* Graveyard ‚Äî bottom */
.graveyard{
  left: var(--GY_X) !important;
  bottom: var(--GY_Y) !important;
  top:auto !important; right:auto !important;
  width:220px; height:260px;
}

/* Exile ‚Äî top */
.exile{
  left: var(--EX_X) !important;
  top: var(--EX_TOP) !important;
  bottom:auto !important; right:auto !important;
  width:220px; height:260px;
}


  
</style>

  
</style>
</head>
<body>
  <!-- Top controls -->
  <div class="topbar">
    <div id="hamb" class="hamb" title="Show / hide deck input"><span></span></div>
    <button id="loadBtn">Load</button>
    <button class="pill" id="shuffleBtn">Shuffle</button>
    <button class="pill" id="draw7">Draw 7</button>
    <button class="pill" id="draw1">Draw 1</button>
    <div class="count">Deck: <span id="deckCount">0</span></div>
  </div>

  <!-- Collapsible deck input -->
  <!-- ===== Life strip (under top bar) ===== -->
  <div id="lifeStrip" class="life-strip">
    <div class="life-cell you">
      <div class="life-label">P1</div>
      <div class="life-value" id="lifeMe">20</div>
    </div>
    <div class="life-cell opp1">
      <div class="life-label" id="lifeP2Label">P2</div>
      <div class="life-value" id="lifeP2">20</div>
    </div>
    <div class="life-cell opp2" id="lifeP3Wrap" style="display:none">
      <div class="life-label">P3</div>
      <div class="life-value" id="lifeP3">20</div>
    </div>
  </div>
  
  <div id="drawerWrap" class="drawer-wrap expanded">
    <div class="drawer">
      <!-- Tool row -->
      <div class="drawer-tools" id="drawerTools">
        <button id="resetBtn" class="pill">Reset</button>
        <button id="lifeBtn"  class="pill">Life</button>
      </div>

      <textarea id="deckIn" placeholder="Paste your deck list here (e.g., `3 Lightning Bolt`)"></textarea>
    </div>
  </div>

  
    


  <!-- Table (world surface + zones) -->
  <main class="table" id="table">
    <div class="world" id="world">
      <div class="zone graveyard"><span class="label">Graveyard</span></div>
      <div class="zone exile"><span class="label">Exile</span></div>
      <div class="zone commander"><span class="label">Commander</span></div>

      <!-- Hand zone lives inside the world so we can ‚Äúpin‚Äù it with transform math -->
      <div class="zone handZone" id="zone-hand"><span class="label">Hand</span></div>
    </div>

    <!-- Tooltip -->
    <div class="hint" id="hint">
      <h3 id="hTitle"></h3>
      <div class="meta" id="hMeta"></div>
      <div class="txt" id="hTxt"></div>
    </div>

    <!-- Chat overlay -->
    <div id="chatOverlay" class="chatOverlay" aria-hidden="true">
      <div class="chatPanel" role="dialog" aria-label="Table Chat">
        <div class="chatHeader">
          <span>Table Chat</span>
          <button id="chatClose" class="chatClose" title="Close">‚úï</button>
        </div>
        <div id="chatLog" class="chatLog"></div>
        <div class="chatInputRow">
          <input id="chatInput" type="text" placeholder="Type a message‚Ä¶" autocomplete="off"/>
          <button id="chatSend">Send</button>
        </div>
      </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </main>

    <!-- Zoom slider (fixed, left side, above the hand) -->
  <div class="zoomWrap" id="zoomWrap" aria-label="Zoom control">
    <div class="zoomMarks">
      <span>+</span>
      <span>‚àí</span>
    </div>
    <input id="zoomSlider" type="range" min="35" max="200" step="1" value="100" />
  </div>


<div class="actions">
<!-- Players (#) -->
<div class="num-wrapper" id="numWrapper">
  <div class="num-actions" id="numActions">
    <button class="pbtn" data-n="1">1</button>
    <button class="pbtn" data-n="2">2</button>
    <button class="pbtn" data-n="3">3</button>
  </div>
  <button class="fab" id="numBtn" title="Players">#</button>
</div>


<!-- Battle (single sword) -->
<button class="fab" id="plusBtn" title="Battle" aria-label="Battle">
  <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
    <!-- Rotate the whole sword so it doesn't look like a plain | -->
    <g transform="rotate(-45 12 12)" fill="currentColor">
      <!-- blade -->
      <rect x="11" y="3" width="2" height="11" rx="1"/>
      <!-- tip -->
      <path d="M11 3 L12 2 L13 3 Z"/>
      <!-- cross-guard -->
      <rect x="9" y="13" width="6" height="2" rx="1"/>
      <!-- grip -->
      <rect x="11.25" y="15" width="1.5" height="4" rx="0.75"/>
      <!-- pommel -->
      <circle cx="12" cy="20" r="1.2"/>
    </g>
  </svg>
</button>

  <!-- Player selector (above compass) -->
  <div class="player-wrapper" id="playerWrapper">
    <div class="player-actions" id="playerActions">
      <button class="pbtn" data-player="1">1</button>
      <button class="pbtn" data-player="2">2</button>
      <button class="pbtn" data-player="3">3</button>
    </div>
    <button class="fab" id="playerBtn" title="Select Player" aria-label="Player">
      <!-- simple silhouette icon (SVG) -->
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z"></path>
        <path d="M4 20c0-3.31 2.69-6 6-6h4c3.31 0 6 2.69 6 6"></path>
      </svg>
    </button>
  </div>

  <!-- Compass / Home -->
  <button class="fab" id="homeBtn" title="Center & Zoom Out">üß≠</button>


  <!-- Tap / Flip -->
  <button class="fab" id="tapBtn">T</button>
  <button class="fab" id="flipBtn">F</button>

  <!-- Chat placeholder -->
  <button class="fab chat" id="chatBtn" title="Chat">üí¨</button>

  <!-- Stack button + popout (Up / Left / Right) -->
  <div class="stack-wrapper" id="stackWrap">
    <div class="stack-actions" id="stackActions">
      <button class="sbtn" id="stackUpBtn"    title="Stack above">‚Üë</button>
      <button class="sbtn" id="stackLeftBtn"  title="Place left (row)">‚Üê</button>
      <button class="sbtn" id="stackRightBtn" title="Place right (row)">‚Üí</button>
    </div>
    <button class="fab" id="stackBtn" title="Stack">
      <!-- Two ‚Äúcards‚Äù to read like a stack icon -->
      <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
        <rect x="6"  y="3"  width="10" height="6" rx="2" fill="currentColor" opacity="0.9"/>
        <rect x="8"  y="11" width="10" height="6" rx="2" fill="currentColor" opacity="0.6"/>
      </svg>
    </button>
  </div>

  <!-- Viewer (eye) under the stack button -->
  <div class="view-wrapper" id="viewWrapper">
    <div class="view-actions" id="viewActions">
      <button class="pbtn" data-player="1">1</button>
      <button class="pbtn" data-player="2">2</button>
      <button class="pbtn" data-player="3">3</button>
    </div>
    <button class="fab" id="viewBtn" title="View Player" aria-label="View">
      <!-- eye icon -->
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
        <path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z"></path>
        <circle cx="12" cy="12" r="3"></circle>
      </svg>
    </button>
  </div>
<!-- End Turn -->
<button class="fab" id="endBtn" title="End Turn">END</button>
</div> <!-- end .actions -->




<script>

/* ===== Life overlay + strip updater ===== */
(function lifeModule(){
  // Update numbers shown in the life strip (handles 2p vs 3p layout)
  function updateLifeStrip(lifeByPlayer={}, numPlayers=2){
    const me = Number(window.currentPlayer || 1);
    const strip  = document.getElementById('lifeStrip');
    if(!strip) return;

    const p3Wrap = document.getElementById('lifeP3Wrap');
    if (numPlayers === 3){
      p3Wrap.style.display = '';
      strip.style.gridTemplateColumns = '1fr 1fr 1fr';
    } else {
      p3Wrap.style.display = 'none';
      strip.style.gridTemplateColumns = '1fr 1fr';
    }

    const others = [1,2,3].filter(x=>x!==me).slice(0, Math.max(0, numPlayers-1));

    const meEl = document.getElementById('lifeMe');
    const p2El = document.getElementById('lifeP2');
    const p3El = document.getElementById('lifeP3');

    meEl.textContent = lifeByPlayer[me] ?? 20;
    p2El.textContent = lifeByPlayer[others[0]] ?? 20;
    if (numPlayers === 3) p3El.textContent = lifeByPlayer[others[1]] ?? 20;

    const p2Lab = document.getElementById('lifeP2Label');
    if (others[0]) p2Lab.textContent = `P${others[0]}`;
  }

  // Build + open the Life overlay
  async function openLifeOverlay() {
  await firebaseReady;

  // Read current values and how many players from Firestore
  const snap = await combatDoc().get();
  const data = snap.exists ? (snap.data() || {}) : {};
  const nPlayers = Math.max(1, Math.min(3, Number(data.numPlayers || 1)));
  const current = data.lifeByPlayer || {}; // {1: 20, 2: 20, 3: 20}

  // Build overlay lazily (one global element we reuse)
  let ov = document.getElementById('lifeOverlay');
  if (!ov) {
    ov = document.createElement('div');
    ov.id = 'lifeOverlay';
    ov.style.cssText = `
      position:fixed; inset:0; z-index:10000; display:flex; align-items:center; justify-content:center;
      background:rgba(6,10,16,.72);
    `;
    ov.innerHTML = `
      <div class="panel" style="
        width:min(560px,94vw); background:linear-gradient(180deg,#0d1118,#0a0f16);
        border:1px solid #24324a; border-radius:14px; padding:14px; color:#e7e9ee;
        box-shadow:0 24px 48px rgba(0,0,0,.5); max-height:80vh; overflow:auto;">
        <div style="font-weight:800; margin:0 0 10px; font-size:18px;">Life Totals</div>
        <div class="rows"></div>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:14px;">
          <button class="btn cancel" style="border:0;border-radius:10px;padding:9px 12px;background:#1b2a47;color:#d8e7ff;">Cancel</button>
          <button class="btn apply"  style="border:0;border-radius:10px;padding:9px 12px;background:#6aa9ff;color:#091323;font-weight:800;">Apply</button>
        </div>
      </div>
    `;
    document.body.appendChild(ov);
  }

  // Build rows
  const rows = ov.querySelector('.rows');
  rows.innerHTML = '';
  for (let p = 1; p <= nPlayers; p++) {
    const val = Number.isFinite(current[p]) ? current[p] : 20;
    const row = document.createElement('div');
    row.className = 'row';
    row.style.cssText = 'display:grid;grid-template-columns:60px 1fr auto;gap:10px;align-items:center;margin:8px 0;';
    row.dataset.player = String(p);
    row.innerHTML = `
      <div style="opacity:.9">P${p}</div>
      <input type="number" inputmode="numeric" value="${val}" style="
        width:100%; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee;
        border-radius:10px; padding:8px; font:13px/1.4 ui-monospace, Menlo, Consolas, monospace;">
      <div class="btns" style="display:grid;grid-auto-flow:column;gap:6px;">
        <button data-d="-5" style="border:1px solid #2b3344;background:#141a24;color:#d8e7ff;border-radius:10px;padding:6px 9px;">-5</button>
        <button data-d="-1" style="border:1px solid #2b3344;background:#141a24;color:#d8e7ff;border-radius:10px;padding:6px 9px;">-1</button>
        <button data-d="+1" style="border:1px solid #2b3344;background:#141a24;color:#d8e7ff;border-radius:10px;padding:6px 9px;">+1</button>
        <button data-d="+5" style="border:1px solid #2b3344;background:#141a24;color:#d8e7ff;border-radius:10px;padding:6px 9px;">+5</button>
      </div>
    `;
    rows.appendChild(row);
  }

  // Button wiring (event delegation)
  rows.onclick = (e) => {
    const b = e.target.closest('button[data-d]');
    if (!b) return;
    const row = e.target.closest('.row');
    const inp = row.querySelector('input[type="number"]');
    const delta = parseInt(b.dataset.d, 10);
    const now = parseInt(inp.value || '0', 10);
    inp.value = String(now + delta);
  };

  // Cancel / Apply
  ov.querySelector('.cancel').onclick = () => ov.style.display = 'none';

  ov.querySelector('.apply').onclick = async () => {
    // Gather new values
    const newLife = {};
    rows.querySelectorAll('.row').forEach(r => {
      const p = parseInt(r.dataset.player, 10);
      const v = parseInt(r.querySelector('input').value || '0', 10);
      newLife[p] = v;
    });

    try {
      await firebaseReady;
      await combatDoc().set({
        lifeByPlayer: newLife,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    } catch (e) {
      console.warn('[life] write failed:', e.message || e);
    }

    ov.style.display = 'none';
  };

  ov.style.display = 'flex';
}


// --- Reset helpers -----------------------------------------------------------
function defaultLifeMap(nPlayers){
  const m = {};
  for (let i = 1; i <= nPlayers; i++) m[i] = 40; // Commander default
  return m;
}

async function hardResetGame(){
  await firebaseReady;
  if (!db) { console.warn('[reset] no Firestore'); return; }

  const nPlayers = Number(window.NUM_PLAYERS || 2);
  const gameRef  = db.collection('games').doc(GAME_ID);
  const players  = gameRef.collection('players');

  const batch = db.batch();

  // Clear players/1..N
  for (let seat = 1; seat <= nPlayers; seat++){
    const pdoc = players.doc(String(seat));
    batch.set(pdoc, {
      Commander: [],
      Deck:      [],
      Exile:     [],
      Graveyard: [],
      Hand:      [],
      Table:     [],
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: false }); // hard reset of each doc
  }

  // Clear combat/current + set lifeByPlayer to 40
  const life = defaultLifeMap(nPlayers);
  batch.set(combatDoc(), { // games/{GAME_ID}/combat/current
    updatedAt:        firebase.firestore.FieldValue.serverTimestamp(),
    turnPlayer:       1,
    numPlayers:       nPlayers,
    lifeByPlayer:     life,
    attacksByPlayer:  {},
    blocksByDefender: {}
  }, { merge: false });

  await batch.commit();

  // --- Local UI cleanup
  try {
    // remove any cards currently on-screen
    document.querySelectorAll('.card').forEach(el => el.remove());
    // zero the deck counter if you show it
    const dc = document.getElementById('deckCount'); if (dc) dc.textContent = '0';
    // refresh the life strip
    if (typeof updateLifeStrip === 'function') updateLifeStrip(life, nPlayers);
    if (typeof showToast === 'function') showToast('Table reset. Life set to 40.');
  } catch(e){
    console.warn('[reset] UI refresh failed', e);
  }
}

// --- Reset button wiring (asks for confirmation) -----------------------------
document.getElementById('resetBtn')?.addEventListener('click', async () => {
  const ok = window.confirm(
    'Reset the table for a new game?\n\nThis clears Deck/Hand/Table for all players and sets life to 40.'
  );
  if (!ok) return;
  try { await hardResetGame(); }
  catch (e) {
    console.error('[reset] failure', e);
    if (typeof showToast === 'function') showToast('Reset failed ‚Äî see console.');
  }
});

    // Wire buttons + live updates once the page & firebase are ready
  function wireLifeUI(){
    document.getElementById('lifeBtn')?.addEventListener('click', openLifeOverlay);

    // Wait until firebase helpers exist, then wire snapshot once
    const tick = setInterval(async ()=>{
      try{
        if (!window.db || typeof combatDoc!=='function' || typeof readCombatFresh!=='function') return;
        clearInterval(tick);

        let handlingDefenseOutcome = false; // guard against re-entry

        console.log('[watch] wiring combat/current snapshot‚Ä¶');

        combatDoc().onSnapshot(async (snap)=>{
          const d  = snap.exists ? (snap.data()||{}) : {};
          const np = Number(d.numPlayers || window.NUM_PLAYERS || 2);

          // Keep existing life-strip update
          if (typeof updateLifeStrip === 'function') {
            updateLifeStrip(d.lifeByPlayer || {}, np);
          }

          // Read either spelling and normalize to a flag
          const flag = Number(d.defenseOutcome ?? d.defensiveOutcome ?? 0);
          console.log('[watch] snapshot received ‚Äî defenseOutcome:', d.defenseOutcome, 'defensiveOutcome:', d.defensiveOutcome, 'flag:', flag);

          if (flag === 1 && !handlingDefenseOutcome){
            console.log('[watch] defenseOutcome==1 ‚Äî starting cleanup‚Ä¶', new Date().toISOString(), d);
            handlingDefenseOutcome = true;
            try {
              await handleDefenseOutcomeCleanup(np);
              console.log('[watch] cleanup finished ‚Äî resetting flag(s) to 0');
              await combatDoc().set({
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                defenseOutcome: 0,      // reset both spellings
                defensiveOutcome: 0,
                outcomeHandledAt: firebase.firestore.FieldValue.serverTimestamp()
              }, { merge: true });
              console.log('[cleanup] defenseOutcome handled ‚Üí reset to 0');
            } catch (e) {
              console.warn('[cleanup] failed', e);
            } finally {
              handlingDefenseOutcome = false;
            }
          }
        });

        // initial paint
        const d = await readCombatFresh();
        updateLifeStrip(d.lifeByPlayer || {}, Number(d.numPlayers || window.NUM_PLAYERS || 2));
      }catch(e){ /* keep waiting until ready */ }
    }, 300);
  }

  window.addEventListener('load', wireLifeUI);
  

  // expose for troubleshooting if needed
  window.openLifeOverlay  = openLifeOverlay;
  window.updateLifeStrip  = updateLifeStrip;

})();

// Removes any on-table cards whose ids are now present in ANY player's Graveyard.
// Reads players/1..N docs directly so both phones stay in sync.
async function handleDefenseOutcomeCleanup(numPlayers){
  try{
    await firebaseReady; if (!db) return;
    const seats = Array.from({ length: Number(numPlayers)||2 }, (_,i)=> i+1);

    const idsToRemove = new Set();

    // Pull Graveyard arrays from each player and collect ids to remove from #world
    for (const seat of seats){
      const ref  = db.collection('games').doc(GAME_ID).collection('players').doc(String(seat));
      const snap = await ref.get();
      if (!snap.exists) continue;
      const data = snap.data() || {};
      const gy = Array.isArray(data.Graveyard) ? data.Graveyard : [];
      for (const c of gy){
        const cid = c && c.id ? String(c.id) : '';
        if (cid) idsToRemove.add(cid);
      }
    }

    // Remove any world card that matches those ids (ignore if already gone)
    let removed = 0;
    idsToRemove.forEach(cid=>{
      const el = document.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`);
      if (el && el.parentElement === world) {
        el.remove();
        removed++;
      }
    });

    console.log(`[cleanup] removed ${removed} world card(s) present in Graveyards across players`);
  } catch (e){
    console.warn('[cleanup] exception', e);
  }
}


// ------------------------------
// NEW: aggressive poller for defenseOutcome (100ms)
// ------------------------------
let __defOutcomePoller = null;
let __defOutcomePolling = false; // guard against re-entry

// REPLACE your entire startDefenseOutcomePoller with this
async function startDefenseOutcomePoller(intervalMs = 100){
  if (__defOutcomePoller) {
    clearInterval(__defOutcomePoller);
    __defOutcomePoller = null;
  }

  const gid  = String(window.GAME_ID || 'default-game');
  const path = `games/${gid}/combat/current`;
  console.log(`[poller] starting defenseOutcome poller @ ${intervalMs}ms  ‚Üí  path: ${path}`);

  let lastSkipLog = 0;

  __defOutcomePoller = setInterval(async () => {
    if (__defOutcomePolling) return;
    try{
      __defOutcomePolling = true;

      // Ensure Firebase is ready. If db isn't set yet, wait for it now.
      if (!window.db && typeof firebaseReady !== 'undefined') {
        try { await firebaseReady; } catch(e) {}
      }

      // Re-check after awaiting
      const hasDb   = !!window.db;
      const hasDoc  = typeof window.combatDoc === 'function';
      const hasRead = typeof window.readCombatFresh === 'function';

      if (!hasDb || !hasDoc || !hasRead) {
        const now = Date.now();
        if (now - lastSkipLog > 1000) {
          console.log(`[poller] skip ‚Äî ready? path: ${path}`, { hasDb, hasDoc, hasRead });
          lastSkipLog = now;
        }
        return;
      }

      let snap;
      try {
        snap = await window.combatDoc().get({ source: 'server' });
      } catch (err) {
        console.warn(`[poller] combatDoc.get() failed ‚Äî path: ${path}`, err && err.message ? err.message : err);
        return;
      }

      const d    = snap.exists ? (snap.data() || {}) : {};
      const flag = Number(d.defenseOutcome ?? d.defensiveOutcome ?? 0);
      const np   = Number(d.numPlayers || window.NUM_PLAYERS || 2);

      console.log(`[poller] snapshot (path: ${path}) ‚Üí`, { defenseOutcome: d.defenseOutcome, defensiveOutcome: d.defensiveOutcome, flag, numPlayers: np });

      if (flag === 1) {
        console.log(`[poller] detected defenseOutcome == 1 ‚Äî running cleanup (path: ${path})`, new Date().toISOString());

        try {
          await handleDefenseOutcomeCleanup(np);

          // extra visual pass (unchanged)
          try {
            const seats = Array.from({ length: Number(np)||2 }, (_,i)=> i+1);
            const collected = new Set();
            for (const seat of seats){
              try{
                const snapP = await db.collection('games').doc(gid).collection('players').doc(String(seat)).get();
                if (!snapP.exists) continue;
                const pdata = snapP.data() || {};
                const gy = Array.isArray(pdata.Graveyard) ? pdata.Graveyard : [];
                for (const c of gy){
                  const cid = c && c.id ? String(c.id) : '';
                  if (cid) collected.add(cid);
                }
              }catch(e){}
            }
            let removed = 0;
            collected.forEach(cid=>{
              const el = document.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`);
              if (el && el.parentElement === world) { el.remove(); removed++; }
            });
            console.log(`[poller] visual removal pass removed ${removed} world card(s) (path: ${path})`);
          }catch(e){
            console.warn(`[poller] visual removal extra pass failed (path: ${path})`, e);
          }

          try{
            await window.combatDoc().set({
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              defenseOutcome: 0,
              defensiveOutcome: 0,
              outcomeHandledAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
            console.log(`[poller] cleared defenseOutcome ‚Üí 0 (merge:true) (path: ${path})`);
          }catch(e){
            console.warn(`[poller] failed to reset flag (path: ${path})`, e);
          }

        } catch (errCleanup) {
          console.warn(`[poller] handleDefenseOutcomeCleanup failed (path: ${path})`, errCleanup);
        }
      }

    } catch (e) {
      console.warn('[poller] unexpected error', e);
    } finally {
      __defOutcomePolling = false;
    }
  }, intervalMs);
}


window.combatDoc = combatDoc;
window.readCombatFresh = readCombatFresh;



// Stop helper (optional, useful for debugging)
function stopDefenseOutcomePoller(){
  if (__defOutcomePoller) {
    clearInterval(__defOutcomePoller);
    __defOutcomePoller = null;
    console.log('[poller] stopped defenseOutcome poller');
  } else {
    console.log('[poller] poller was not running');
  }
}



/* =========================================================
   Refs & state
   ========================================================= */
const $ = s => document.querySelector(s);
const table=$('#table'), world=$('#world'), handZone=$('#zone-hand');
const hint=$('#hint'), hTitle=$('#hTitle'), hMeta=$('#hMeta'), hTxt=$('#hTxt');
let hintSuppressed = false;

let drawPile=[];            // parsed deck, top at end
let zCounter=10;            // z-index counter so newest drags float

const CARD_BACK='https://i.imgur.com/LdOBU1I.jpeg';
const cache=new Map(), imgOk=new Map();

// ========= NEW helpers to (re)build a board/hand/deck from Firestore =========
function clearHand(){
  handCards().forEach(c => c.remove());
  handZone.querySelector('.label').textContent = 'Hand';
}
function spawnCardToHandFromSaved(c){
  // simplified version of spawnCardFromSaved that appends to the hand zone
  const card = document.createElement('div');
  card.dataset.cid = c.id ? String(c.id) : (card.dataset.cid || String(Math.random()).slice(2));
  card.id = `card-${card.dataset.cid}`;

  card.className = 'card in-hand';
  card.setAttribute('data-name', c.name || '');
  card.style.zIndex = ++zCounter;

  const body = document.createElement('div'); body.className = 'cardBody';
  const c3 = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img');
  imgF.alt = c.name || ''; imgF.draggable = false; imgF.src = c.img || '';
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img');
  imgB.alt = 'Card back'; imgB.src = CARD_BACK; imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2); c3.appendChild(inner); body.appendChild(c3); card.appendChild(body);
  // no drag wiring needed; the hand carousel owns gesture capture
  handZone.appendChild(card);
  return card;
}

function renderFullState(data){
  // 1) Deck (draw pile)
  drawPile = (data?.Deck || []).map(d => d.name).reverse(); // top is at end
  $('#deckCount').textContent = drawPile.length;

  // 2) Table & zones
  renderSavedStateToWorld(data); // already clears the board & renders Table/Grave/Exile/Commander

  // 3) Hand
  clearHand();
  (data?.Hand || []).forEach(spawnCardToHandFromSaved);
  layoutHand();

  // 4) Make sure we are NOT in viewer mode when resuming a player
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';

  // 5) Camera
  goHome();
}

function scaleToSlider(s){
  const t = (s - SC_MAX) / (SC_MIN - SC_MAX);        // invert back to 0..1
  return Math.round(SL_MIN + t * (SL_MAX - SL_MIN));  // 35..200
}

// Get full Scryfall data for a card element by name and refresh its UI bits.
async function hydrateCardData(card){
  try{
    const name = card.getAttribute('data-name') || (card._data && card._data.name);
    if(!name) return;
    const d = await fetchCard(name);
    card._data = d;

    // If the front image was empty in the saved snapshot, fill it now
    const imgEl = card.querySelector('.face.front img');
    if(imgEl && (!imgEl.src || imgEl.src === window.location.href)) {
      const uris = candidateUris(d);
      await loadFirstWorking(imgEl, uris);
    }
    refreshPTForCard(card);
    if(selectedCard === card) updateHint();
  }catch(e){ /* ignore */ }
}



/* ========== Firebase init + helpers (uses your working project) ========== */
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.appspot.com",
  messagingSenderId: "795274673000",
  appId: "1:795274673000:web:0ea07130e45c72384134dd",
  measurementId: "G-VLW5KLY4FF"
};

let db;
let GAME_ID = 'default-game';   // change if you want per-table sessions

// Gate init so writes/reads wait for Firebase to be ready
let firebaseReady = (async () => {
  try {
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);

    // If your Firestore rules require auth, leave this in.
    // If your rules are public, you can delete this try/catch.
    try { await firebase.auth().signInAnonymously(); }
    catch (e) { console.warn('Anon auth failed (ok if your rules are public):', e.message); }

    db = firebase.firestore();
window.db = db;              // <-- make it global so poller & wireLifeUI see it
console.log('[firebase] ready');

    console.log('[firebase] ready');
  } catch (err) {
    console.warn('Firebase init error:', err);
    db = undefined;
  }
})();


/* Utility: Serialise one card DOM -> plain object for saving (with extras) */
function serializeCard(card){
  if(!card) return null;
  const rectLeft = parseFloat(card.style.left) || 0;
  const rectTop  = parseFloat(card.style.top)  || 0;

  const name = card.getAttribute('data-name') || (card._data && card._data.name) || '';

  // image url if loaded
  const imgEl = card.querySelector('.face.front img');
  const img = imgEl ? imgEl.src : '';

  const id = card.dataset.cid || (card.dataset.cid = String(Math.random()).slice(2));

  // tap/flip
  const c3 = card.querySelector('.card3d');
  const tapped  = !!(c3 && (c3.style.transform||'').includes('rotate(90deg)'));
  const flipped = card.classList.contains('flipped');

  // extras (manual edits + chosen/type/effect metadata)
  const ex = card._extras || {};
  const extras = {
    addTypes:   Array.from(ex.addTypes   || []),
    addEffects: Array.from(ex.addEffects || []),
    dp: Number.isFinite(ex.dp) ? ex.dp : 0,
    dt: Number.isFinite(ex.dt) ? ex.dt : 0,
    // optional ‚Äúchosen type‚Äù for cards like Metallic Mimic or ‚Äúchoose a creature type‚Äù
    chosenType: (ex.chosenType || '') + ''
  };

  return {
    id, name, img,
    x: rectLeft, y: rectTop,
    z: parseInt(card.style.zIndex||10, 10) || 10,
    tapped, flipped,
    extras,
    parent: card.parentElement && card.parentElement.id
      ? card.parentElement.id
      : (card.parentElement === handZone ? 'hand' : 'table')
  };
}


/* Apply saved extras back onto a DOM card (types/effects/manual P/T etc.) */
function applySavedCardExtras(card, saved){
  const ex = (saved && saved.extras) || {};
  const addTypes   = new Set(ex.addTypes || []);
  const addEffects = new Set(ex.addEffects || []);
  const dp = Number.isFinite(ex.dp) ? ex.dp : 0;
  const dt = Number.isFinite(ex.dt) ? ex.dt : 0;
  const chosenType = (ex.chosenType || '') + '';

  card._extras = { addTypes, addEffects, dp, dt, chosenType };

  // If we store a little badge line on the card later, we could render it here.
  // For now, just force a PT refresh (creatures) and update tooltip content if selected.
  refreshPTForCard(card);
  if (selectedCard === card) updateHint();
}

/* Convenience: attach a small gear button bottom-left on a table card */
function attachGearButton(card){
  if(card._gear) return;
  const btn = document.createElement('button');
  btn.className = 'gear-btn';
  btn.title = 'Edit card extras';
  btn.textContent = '‚öôÔ∏è';
  // visual styling (you can keep what you have)
  btn.style.position = 'absolute';
  btn.style.left = '6px';
  btn.style.bottom = '6px';
  btn.style.transform = 'scale(var(--inv-scale))';
  btn.style.transformOrigin = 'bottom left';
  btn.style.border = '1px solid #2b3f63';
  btn.style.background = '#1a2a45';
  btn.style.color = '#cfe1ff';
  btn.style.borderRadius = '10px';
  btn.style.width = '30px';
  btn.style.height = '28px';
  btn.style.fontSize = '14px';
  btn.style.cursor = 'pointer';
  btn.style.boxShadow = '0 8px 20px rgba(106,169,255,.18)';

  btn.addEventListener('click', (e)=>{
    e.stopPropagation();
    openCardEditor(card);
  });

  // ‚¨áÔ∏è KEY CHANGE: put it under .cardBody so it's clickable
  const body = card.querySelector('.cardBody') || card;
  body.appendChild(btn);

  card._gear = btn;
}

function hideAllGears(){
  document.querySelectorAll('.card.show-gear').forEach(c => c.classList.remove('show-gear'));
}
function showGearFor(card){
  if (!card) return;
  // Don‚Äôt show in hand
  if (card.parentElement && card.parentElement.id === 'zone-hand') return;
  card.classList.add('show-gear');
}




/* Build the player structure and save to Firestore */
async function savePlayerState(playerId){
  await firebaseReady;                 // ensure db is set
  if(!db) { console.warn('No Firestore (missing config)'); return; }
  try {
    const deck = Array.from(drawPile).slice().reverse().map(name => ({ name }));
    const hand = handCards().map(serializeCard);
    const tableCards = Array.from(world.querySelectorAll('.card'))
      .filter(c => c.parentElement === world)
      .map(serializeCard);

    // NOTE: these zones are currently empty unless you physically append cards into those zone elements
    const graveyard = Array.from(document.querySelectorAll('.graveyard .card')).map(serializeCard);
    const exile     = Array.from(document.querySelectorAll('.exile .card')).map(serializeCard);
    const commander = Array.from(document.querySelectorAll('.commander .card')).map(serializeCard);

    const docRef = db.collection('games').doc(GAME_ID).collection('players').doc(String(playerId));
    await docRef.set({
      Deck: deck,
      Hand: hand,
      Table: tableCards,
      Graveyard: graveyard,
      Exile: exile,
      Commander: commander,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });

    console.log('[save] player', playerId, 'ok');
  } catch(err){ console.error('savePlayerState err', err); }
}

async function loadPlayerState(playerId){
  await firebaseReady;
  if(!db) { console.warn('No Firestore (missing config)'); return null; }
  try {
    const snap = await db.collection('games').doc(GAME_ID).collection('players').doc(String(playerId)).get();
    if(!snap.exists){ console.log('[load] no doc for player', playerId); return null; }
    console.log('[load] player', playerId, 'ok');
    return snap.data();
  } catch(err){ console.error('loadPlayerState err', err); return null; }
}

/* ===== Viewer Mode ===== */
let viewerMode = false;
let viewerPlayer = null;
let localSnapshot = null;   // your table snapshot before entering viewer

function captureLocalSnapshot(){
  const toWorld = sel => Array.from(document.querySelectorAll(sel)).map(serializeCard);
  return {
    Table: toWorld('#world > .card'),
    Graveyard: toWorld('.graveyard .card'),
    Exile: toWorld('.exile .card'),
    Commander: toWorld('.commander .card')
    // (Hand intentionally ignored ‚Äì we never show it in viewer)
  };
}


// Generate/ensure a stable card id (cid) on a DOM element
function ensureCid(el){
  if (!el) return '';
  if (!el.dataset.cid) el.dataset.cid = String(Math.random()).slice(2);
  return el.dataset.cid;
}

/* Remove a card with id=cardId from a player's Table array in Firestore.
   Uses a transaction so we don't depend on exact object matching (arrayRemove). */
async function removeCardFromPlayerTable(playerSeat, cardId){
  await firebaseReady; if (!db) return;
  const seat = String(playerSeat);
  const docRef = db.collection('games').doc(GAME_ID).collection('players').doc(seat);
  const pathStr = `games/${GAME_ID}/players/${seat}`;

  return db.runTransaction(async (tx)=>{
    const snap = await tx.get(docRef);
    const data = snap.exists ? (snap.data() || {}) : {};
    const before = Array.isArray(data.Table) ? data.Table : [];
    const after  = before.filter(c => String(c?.id) !== String(cardId));

    console.log(`[table-remove] FROM ${pathStr}  id=${cardId}  before=${before.length} after=${after.length}`);
    tx.set(docRef, {
      Table: after,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge:true });
  });
}



/* Append a dying card to a player's zone list in Firestore (e.g., Graveyard)
   and drop a hidden DOM marker so future savePlayerState() won't wipe it.
   `role` is only for logging: 'attacker' | 'blocker' */
async function appendCardToPlayerZone(playerSeat, zoneKind /* 'Graveyard' | 'Exile' */, cardEl, role){
  try{
    await firebaseReady; if (!db) return;
    const seat = String(playerSeat);
    const pathStr = `games/${GAME_ID}/players/${seat}`;
    const docRef = db.collection('games').doc(GAME_ID).collection('players').doc(seat);

    const cid = ensureCid(cardEl);

    // Reuse your serializer so name/img/extras stay consistent
    const s = (typeof serializeCard === 'function') ? (serializeCard(cardEl) || {}) : {};

    const entry = {
      id: cid,
      name: s.name || cardEl.getAttribute('data-name') || '',
      img:  s.img  || (cardEl.querySelector('.face.front img')?.src || ''),
      extras: s.extras || cardEl._extras || undefined
    };
	
	// üîß Firestore-safe: no undefined fields
if (entry.extras === undefined) delete entry.extras;

    // Keep DOM in sync so a subsequent save won't wipe the zone write
    const zoneSel = (zoneKind === 'Graveyard') ? '.graveyard' : '.exile';
    const zoneDom = document.querySelector(zoneSel);
    if (zoneDom && !zoneDom.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`)){
      const stub = document.createElement('div');
      stub.className = 'card';
      stub.dataset.cid = cid;
      stub.style.cssText = 'display:none;left:0;top:0;';
      zoneDom.appendChild(stub);
    }

    console.log(`[graveyard][${role||'unknown'}] WRITE ‚Üí ${pathStr}  zone=${zoneKind}`, { id: entry.id, name: entry.name });
    await docRef.set({
      [zoneKind]: firebase.firestore.FieldValue.arrayUnion(entry),
      updatedAt:  firebase.firestore.FieldValue.serverTimestamp()
    }, { merge:true });
    console.log(`[graveyard][${role||'unknown'}] OK   ‚Üí ${pathStr}  zone=${zoneKind}  id=${entry.id}`);
  }catch(e){
    console.warn('[appendCardToPlayerZone] failed', e);
  }
}





function clearBoard(){
  // remove only table/zone cards (not the zones themselves)
  document.querySelectorAll('#world .card').forEach(el => el.remove());
}

function spawnCardToHandFromSaved(c){
  const card = document.createElement('div');
  card.className = 'card in-hand';
  card.setAttribute('data-name', c.name || '');
  card.style.zIndex = ++zCounter;

  const body  = document.createElement('div'); body.className = 'cardBody';
  const c3    = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img'); imgF.alt = c.name || ''; imgF.draggable = false; imgF.src = c.img || '';
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img'); imgB.alt = 'Card back'; imgB.src = CARD_BACK; imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2); c3.appendChild(inner); body.appendChild(c3); card.appendChild(body);
  handZone.appendChild(card);

  // hydrate so the tooltip shows full info when selected in-hand
  hydrateCardData(card);
  return card;
}


function renderSavedStateToWorld(data){
  clearBoard();

  // battlefield
  (data.Table || []).forEach(spawnCardFromSaved);


  (data.Commander || []).forEach(c => {
    const el = spawnCardFromSaved(c);
    document.querySelector('.commander').appendChild(el);
  });

  // one pass to apply global/static buffs after everything exists
  if (typeof recomputeContinuousEffects === 'function') recomputeContinuousEffects();
}


// ========= UPDATED viewer enter/exit so it never forces you back to P1 =========
async function enterViewer(playerId){
  // only snapshot *once* when entering viewer the first time
  if (!viewerMode) localSnapshot = captureLocalSnapshot();

  viewerMode = true;
  viewerPlayer = String(playerId);
  document.body.classList.add('viewer');
  handZone.style.display = 'none';   // hide hand while viewing others

  const data = await loadPlayerState(playerId);
  if (!data){ alert('No saved data for player ' + playerId); exitViewer(); return; }
  renderSavedStateToWorld(data);     // battlefield + zones only (no hand)
  goHome();
}

function exitViewer(){
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';

  if (localSnapshot){
    renderFullState(localSnapshot);  // puts you back *exactly* where you were
  } else {
    clearBoard(); goHome();
  }
}


let hoveredCard=null;       // drives tooltip content
let selectedCard=null;      // target for T/F
const state={ scale:1, tx:0, ty:0 }; // world transform

let selectedGroup = []; // currently highlighted cards (base..selected)

/* Return the slice of a stack from the base (index 0) up to and including `card`.
   If the card isn't stacked, returns [card]. */
function stackSliceFrom(card){
  const base = getStackBase(card);
  if(!base || !base._stack) return [card];
  const idx = base._stack.indexOf(card);
  if(idx < 0) return [card];
  return base._stack.slice(0, idx + 1);
}




/* Hand carousel center index */
let handIndex=0;

/* Stack UI: current mode = null | 'up' | 'left' | 'right'  */
let stackMode=null;

// Which player we are controlling / saving as
var currentPlayer = 1; // default to player 1 (1/2/3)
window.currentPlayer = currentPlayer;

/* Turn / player count state */
let NUM_PLAYERS = 2;   // default; change via the # popout
let turnPlayer  = 1;   // whose turn it is (1..NUM_PLAYERS)



// Add this helper near other helpers
function goHome(){
  const MIN_ZOOM = 0.35;
  const vw = table.clientWidth, vh = table.clientHeight;

  const worldCards = Array.from(world.querySelectorAll('.card'))
    .filter(c => c.parentElement === world);

  if (!worldCards.length) {
    state.scale = MIN_ZOOM;
    state.tx = vw / 2;
    state.ty = vh / 2;
    applyTransform();
    return;
  }

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  worldCards.forEach(c => {
    const x = parseFloat(c.style.left) || 0;
    const y = parseFloat(c.style.top)  || 0;
    const w = parseFloat(getComputedStyle(c).width)  || 223;
    const h = parseFloat(getComputedStyle(c).height) || 310;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  state.scale = MIN_ZOOM;
  state.tx = (vw / 2) - cx * state.scale;
  state.ty = (vh / 2) - cy * state.scale;
  applyTransform();
}


/* =========================================================
   World transform + anchored hand
   ========================================================= */


   
function applyTransform(){
  world.style.transform = `translate(${state.tx}px, ${state.ty}px) scale(${state.scale})`;
  document.documentElement.style.setProperty('--inv-scale', (1/state.scale).toString());
  positionHandZone();
  layoutHand();           // keep in-hand cards visually stable

  // keep the slider reflecting current zoom (wheel, pinch, home, etc.)
const zs = document.getElementById('zoomSlider');
if (zs) zs.value = scaleToSlider(state.scale); // inverted mapping
;
}


function positionHandZone(){
  // Visual target rect in screen px‚Ä¶
  const PX_W = Math.min(window.innerWidth*0.92, 980);
  const PX_H = 170;
  const PX_MARGIN_BOTTOM = 10;
  const leftPx = (window.innerWidth - PX_W)/2;
  const topPx  = window.innerHeight - PX_H - PX_MARGIN_BOTTOM;

  // ‚Ä¶converted to world coords by inverting current transform.
  handZone.style.width  = (PX_W / state.scale) + 'px';
  handZone.style.height = (PX_H / state.scale) + 'px';
  handZone.style.left   = ((leftPx - state.tx) / state.scale) + 'px';
  handZone.style.top    = ((topPx  - state.ty) / state.scale) + 'px';
}

function sizeHandCardForRole(card){
  // Constant on-screen sizes while in-hand
  const CENTER = {w:190, h:265};
  const SIDE   = {w:150, h:210};
  const isCenter = card.classList.contains('hand-center');
  const target = isCenter ? CENTER : SIDE;
  card.style.width  = (target.w / state.scale) + 'px';
  card.style.height = (target.h / state.scale) + 'px';
}
function restoreTableSize(card){
  // Reset to default table dimensions when leaving the hand
  card.style.width  = 'var(--card-w)';
  card.style.height = 'var(--card-h)';
}


/* =========================================================
   Mouse wheel zoom (desktop) ‚Äî zoom at cursor
   ========================================================= */
table.addEventListener('wheel', (e)=>{
  // Prevent page scroll; we control zoom here.
  e.preventDefault();

  // Ignore if user is scrolling inside the stack popout or hint.
  if (e.target.closest('#stackWrap .stack-actions') || e.target.closest('#hint')) return;

  // World point under the cursor BEFORE zoom
  const wp = worldPointAt(e.clientX, e.clientY);

  // Normalize delta across devices
  const deltaUnit = (e.deltaMode === 1 ? 15 : (e.deltaMode === 2 ? 120 : 1));
  const delta = e.deltaY * deltaUnit;

  // Trackpads often set ctrlKey during pinch ‚Äî make that a bit ‚Äústronger‚Äù
  const speed = e.ctrlKey ? 0.02 : 0.0015;

  // Exponential scale feels smooth and device-agnostic
  const factor = Math.exp(-delta * speed);
  const newScale = clamp(state.scale * factor, 0.35, 2.0);
  if (newScale === state.scale) return;

  state.scale = newScale;

  // Keep the world point under the cursor stationary after zoom
  const r = table.getBoundingClientRect();
  const px = e.clientX - r.left;
  const py = e.clientY - r.top;
  state.tx = px - wp.x * state.scale;
  state.ty = py - wp.y * state.scale;

  applyTransform();
}, { passive:false });

// === Zoom slider wiring (SMOOTH + focus-anchored) ===
// Slider range 35..200 == scale 0.35..2.00
(function attachZoomSlider(){
  const slider = document.getElementById('zoomSlider');
  // Inverted mapping: slider 35..200  ‚Üî  scale 2.00..0.35
const SL_MIN = 35,  SL_MAX = 200;
const SC_MIN = 0.35, SC_MAX = 2.0; // scale bounds

function sliderToScale(v){
  const t = (v - SL_MIN) / (SL_MAX - SL_MIN);        // 0 at min, 1 at max
  // lerp 2.0 -> 0.35 (inverted)
  return clamp(SC_MAX + t * (SC_MIN - SC_MAX), SC_MIN, SC_MAX);
}

function scaleToSlider(s){
  const t = (s - SC_MAX) / (SC_MIN - SC_MAX);        // invert back to 0..1
  return Math.round(SL_MIN + t * (SL_MAX - SL_MIN));  // 35..200
}

  if (!slider) return;

  // initialize to current scale
  slider.value = scaleToSlider(state.scale);


  // Find a good screen point to anchor (center of visible card cluster);
  // fallback to table center.
  function getFocusScreenPoint(){
    const rt = table.getBoundingClientRect();
    const all = Array.from(document.querySelectorAll('.card'));
    const vis = all.filter(el=>{
      const r = el.getBoundingClientRect();
      // "visible" if intersects viewport
      return r.right  > 0 &&
             r.bottom > 0 &&
             r.left   < window.innerWidth &&
             r.top    < window.innerHeight;
    });
    if (vis.length){
      let sx=0, sy=0, n=0;
      // sample up to 20 for speed
      for (let i=0; i<vis.length && i<20; i++){
        const r = vis[i].getBoundingClientRect();
        sx += (r.left + r.width/2);
        sy += (r.top  + r.height/2);
        n++;
      }
      return { x: sx/n, y: sy/n };
    }
    // fallback: table center in viewport coords
    return { x: rt.left + rt.width/2, y: rt.top + rt.height/2 };
  }

  let _zoomAnim = null;
  let _anchor   = null;  // { cx, cy, wp:{x,y} } in TABLE-local coords

  function captureAnchor(){
    const rt = table.getBoundingClientRect();
    const fp = getFocusScreenPoint();        // viewport coords
    // convert to table-local coords for worldPointAt
    const cx = clamp(fp.x, rt.left, rt.right)   - rt.left;
    const cy = clamp(fp.y, rt.top,  rt.bottom)  - rt.top;
    const wp = worldPointAt(cx, cy, { scale: state.scale, tx: state.tx, ty: state.ty });
    _anchor = { cx, cy, wp };
  }

  function animateZoomTo(targetScale){
    if (!_anchor) captureAnchor();
    const { cx, cy, wp } = _anchor;

    cancelAnimationFrame(_zoomAnim);
    const easing = 0.18;
    const eps    = 0.001;

    function step(){
      const diff = targetScale - state.scale;
      if (Math.abs(diff) < eps){
        state.scale = targetScale;
        state.tx = cx - wp.x * state.scale;
        state.ty = cy - wp.y * state.scale;
        applyTransform();
        return;
      }
      state.scale += diff * easing;
      state.tx = cx - wp.x * state.scale;
      state.ty = cy - wp.y * state.scale;
      applyTransform();
      _zoomAnim = requestAnimationFrame(step);
    }
    step();
  }

  // Anchor on first touch/press of the slider, and reset when done.
  slider.addEventListener('pointerdown', captureAnchor);
  slider.addEventListener('touchstart',  captureAnchor, { passive: true });
  slider.addEventListener('pointerup',   ()=>{ _anchor = null; });
  slider.addEventListener('touchend',    ()=>{ _anchor = null; });

  // If the browser fires input without pointerdown (rare), capture on first input.
  slider.addEventListener('input', (e)=>{
    if (!_anchor) captureAnchor();
    const target = sliderToScale(parseInt(e.target.value, 10));

    animateZoomTo(target);
  });
})();

// Inverted mapping: slider 35..200  ‚Üî  scale 2.00..0.35
const SL_MIN = 35,  SL_MAX = 200;
const SC_MIN = 0.35, SC_MAX = 2.0; // scale bounds

function sliderToScale(v){
  const t = (v - SL_MIN) / (SL_MAX - SL_MIN);        // 0 at min, 1 at max
  // lerp 2.0 -> 0.35 (inverted)
  return clamp(SC_MAX + t * (SC_MIN - SC_MAX), SC_MIN, SC_MAX);
}

function scaleToSlider(s){
  const t = (s - SC_MAX) / (SC_MIN - SC_MAX);        // invert back to 0..1
  return Math.round(SL_MIN + t * (SL_MAX - SL_MIN));  // 35..200
}


/* ========= Creature P/T badge helpers ========= */

function escapeHTML(s){
  return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
}

// Map a single symbol (no braces) to the mana.css class
function manaClassForSymbol(sym){
  const S = (sym||'').toUpperCase().trim();

  // numbers and single glyphs
  if (/^\d+$/.test(S)) return 'ms-' + S;          // 0..20 etc
  if (['W','U','B','R','G','C','S','X','Y','Z','E'].includes(S)) return 'ms-' + S.toLowerCase();
  if (S === 'T') return 'ms-tap';
  if (S === 'Q') return 'ms-untap';

  // hybrids / phyrexian / 2-color
  if (S.includes('/')){
    const parts = S.split('/');
    if (parts.includes('P')){                      // W/P ‚Üí ms-pw
      const c = (parts[0]==='P'?parts[1]:parts[0]).toLowerCase();
      return 'ms-p' + c;
    }
    if (parts.includes('2')){                      // 2/W ‚Üí ms-2w
      const c = (parts[0]==='2'?parts[1]:parts[0]).toLowerCase();
      return 'ms-2' + c;
    }
    return 'ms-' + parts.map(p=>p.toLowerCase()).join(''); // W/U ‚Üí ms-wu
  }
  return null;
}

// Turn a string containing {...} tokens into icon HTML (keeps everything else escaped)
function renderTextWithIcons(s, withRing=true){
  s = s || '';
  const re = /\{[^}]+\}/g;
  let out = '', i = 0, m;
  while ((m = re.exec(s))){
    out += escapeHTML(s.slice(i, m.index));                 // text before token
    const sym = m[0].slice(1, -1);                          // drop braces
    const cls = manaClassForSymbol(sym);
    out += cls ? `<i class="ms ${withRing?'ms-cost':''} ${cls}"></i>` : escapeHTML(m[0]);
    i = m.index + m[0].length;
  }
  out += escapeHTML(s.slice(i));                            // tail
  return out;                                               // preserves \n (pre-wrap will render them)
}



function isCreatureCard(card){
  const d = card?._data || {};
  const face = (d.card_faces && d.card_faces[0]) || null;
  const type = (d.type_line || face?.type_line || '') + '';
  return /Creature/i.test(type);
}

function basePT(card){
  const d = card?._data || {};
  const face = (d.card_faces && d.card_faces[0]) || null;
  const p = (d.power ?? face?.power);
  const t = (d.toughness ?? face?.toughness);
  const toNum = v => (v==null || v==='*' || isNaN(parseInt(v,10)) ? null : parseInt(v,10));
  return [toNum(p), toNum(t)];
}

function oracleText(card){
  const d = card?._data || {};
  if(d.oracle_text) return d.oracle_text;
  if(d.card_faces){
    return d.card_faces.map(f => [f.name, f.oracle_text].filter(Boolean).join('\n')).join('\n‚Äî\n');
  }
  return '';
}

/* Extract sum of +/-N/+/-M seen in lines that look like buffs to a creature.
   We only count lines that include 'gets', 'equipped creature', or 'enchanted creature'
   to avoid picking up random 1/1 token text etc. */
function extractPTDeltaFromText(txt){
  if(!txt) return {dp:0, dt:0, hits:[]};
  let dp=0, dt=0; const hits=[];
  const lines = txt.split(/\r?\n|(?<=\.)\s+/);
  const guard = /(equipped creature|enchanted creature|gets)/i;
  const re = /([+\-]?\d+)\s*\/\s*([+\-]?\d+)/g;
  for(const line of lines){
    if(!guard.test(line)) continue;
    let m; while((m = re.exec(line))){
      const p = parseInt(m[1],10), t = parseInt(m[2],10);
      if(!isNaN(p) && !isNaN(t)){
        dp += p; dt += t; hits.push(`${p>=0?'+':''}${p}/${t>=0?'+':''}${t}`);
      }
    }
  }
  return {dp, dt, hits};
}

function ensurePTBadge(card){
  if(card._ptBadge) return card._ptBadge;
  const el = document.createElement('div');
  el.className = 'pt-badge';
  el.textContent = ''; // filled in by update
  card.appendChild(el);
  card._ptBadge = el;
  return el;
}

function hidePTBadge(card){
  if(card._ptBadge) card._ptBadge.style.display='none';
}

function showPTBadge(card, text, title){
  const el = ensurePTBadge(card);
  el.textContent = text;
  if(title) el.title = title;
  el.style.display='block';
}

/* Recalculate and render the creature's current P/T.
   Looks through all cards stacked above this creature (base._stack[1..]) and
   sums any "+N/+M" buffs in their oracle text. */
function updateCreaturePT(card){
  if(!isCreatureCard(card)){ hidePTBadge(card); return; }

  const [bp, bt] = basePT(card);
  // If base P/T is unknown (e.g. * / *), just show '--/--'
  if(bp==null || bt==null){ showPTBadge(card, '--/--', 'Base P/T unknown'); return; }

  // Sum buffs from attachments in this stack (anything above the base)
  let sumP = 0, sumT = 0; const reasons = [];
  if(card._stack && card._stack.length > 1){
    for(let i=1;i<card._stack.length;i++){
      const att = card._stack[i];
      const {dp, dt, hits} = extractPTDeltaFromText(oracleText(att));
      if(dp || dt){
        sumP += dp; sumT += dt;
        if(hits.length){
          const n = att._data?.name || att.getAttribute('data-name') || 'Attachment';
          reasons.push(`${n}: ${hits.join(', ')}`);
        }
      }
    }
  }

  const finalP = bp + sumP;
  const finalT = bt + sumT;

  const title = reasons.length
    ? `Base ${bp}/${bt}\n` + reasons.join('\n')
    : `Base ${bp}/${bt}`;

  showPTBadge(card, `${finalP}/${finalT}`, title);
}

/* Convenience: when a stack changes or a card loads data, refresh the base creature P/T. */
/* Return the creature's current numeric P/T by summing base and attachment buffs.
   Mirrors updateCreaturePT but returns numbers instead of drawing a badge. */
function computeCurrentPTFromBase(base){
  const [bp, bt] = basePT(base);
  if(bp==null || bt==null) return {power:null, toughness:null};
  let sumP = 0, sumT = 0;
  if(base._stack && base._stack.length > 1){
    for(let i=1;i<base._stack.length;i++){
      const att = base._stack[i];
      const delta = extractPTDeltaFromText(oracleText(att));
      if(delta && (delta.dp || delta.dt)){
        sumP += delta.dp; sumT += delta.dt;
      }
    }
  }
  return {power: bp + sumP, toughness: bt + sumT};
}

function refreshPTForCard(card){
  const base = getStackBase(card) || card;
  updateCreaturePT(base);
}




/* =========================================================
   Drawer toggle
   ========================================================= */
$('#hamb').addEventListener('click', ()=>{
  const wrap = $('#drawerWrap');
  const collapsed = wrap.classList.contains('collapsed');
  wrap.classList.toggle('collapsed', !collapsed);
  wrap.classList.toggle('expanded', collapsed);
});


function collapseDrawer(){
  const wrap = $('#drawerWrap');
  wrap.classList.add('collapsed');
  wrap.classList.remove('expanded');
}


/* =========================================================
   Deck parsing + Scryfall fetch
   ========================================================= */
function parseDeck(text){
  // Accept "3 Name" / "Name x3" / "- Name" etc.
  var lines=(text||'').split(/\r?\n/), out=[];
  for (var i=0;i<lines.length;i++){
    var raw=lines[i]; if(!raw) continue;
    var l=raw.replace(/[-\u2022\u2023\u25E6\u2043\u2219*\t]+\s*/g,'').replace(/\s+/g,' ').trim();
    if(!l) continue; if(/^side\s*board\s*:?\s*$/i.test(l)) continue;
    var m, qty=1, name=l;
    if((m=/^(\d+)\s*[x√ó]?\s+(.+)$/.exec(l))){ qty=parseInt(m[1],10); name=m[2]; }
    else if((m=/^(.+?)\s+[x√ó]\s*(\d+)$/.exec(l))){ name=m[1]; qty=parseInt(m[2],10); }
    name=name.replace(/^[-‚Ä¢\s]+/,'').trim(); if(!name) continue;
    for(var k=0;k<Math.max(1,qty);k++) out.push(name);
  }
  return out;
}
async function fetchCard(name){
  const key=name.toLowerCase(); if(cache.has(key)) return cache.get(key);
  const url='https://api.scryfall.com/cards/named?'+new URLSearchParams({fuzzy:name});
  const r=await fetch(url,{mode:'cors'}); if(!r.ok) throw new Error('scryfall '+r.status);
  const d=await r.json(); cache.set(key,d); return d;
}
function candidateUris(card){
  const list=[]; function push(u){ if(!u) return; ['large','normal','png','border_crop','art_crop','small'].forEach(k=>u[k]&&list.push(u[k])); }
  if(card && card.image_uris) push(card.image_uris);
  if(card && card.card_faces && card.card_faces[0] && card.card_faces[0].image_uris) push(card.card_faces[0].image_uris);
  return Array.from(new Set(list));
}
function loadFirstWorking(img,uris){
  // Try URLs until one works; memoize failures to skip next time
  return new Promise(res=>{
    let i=0; (function step(){
      if(i>=uris.length){res(false);return;}
      const u=uris[i++]; if(imgOk.get(u)===false){step();return;}
      const t=new Image(); t.crossOrigin='anonymous';
      t.onload=()=>{imgOk.set(u,true); img.src=u; res(true);};
      t.onerror=()=>{imgOk.set(u,false); step();};
      t.src=u;
    })();
  });
}

/* =========================================================
   Tooltip helpers (now anchored above the in-hand center card)
   ========================================================= */

// NEW: parse what a card grants to an equipped/enchanted creature.
function parseGrantedInfoFromOracle(oracle){
  const text = (oracle || '').replace(/\s+/g, ' ').trim();
  const types = new Set();
  const effects = new Set();
  if(!text) return { types: [], effects: [] };

  // --- Additional types (handle ‚Äúgets ... and is a ... in addition to its other types‚Äù)
  // allow anything between "creature" and "is" (e.g., "gets +2/+2 and")
  let m;
  const typesRe = /\b(?:equipped|enchanted)\s+creature\b.*?\bis\s+(?:also\s+)?(?:a|an)?\s*([^.\n]+?)\s+in addition to (?:its|their) other types\b/gi;
  while((m = typesRe.exec(text))){
    let phrase = m[1].trim().replace(/^\s*(?:a|an)\s+/i,'').replace(/\s*\.$/,'');
    // split ‚ÄúSpider Hero and Warrior‚Äù, ‚ÄúZombie, Horror‚Äù, ‚ÄúMerfolk/Elf‚Äù
    phrase.split(/\s*,\s*|\s+and\s+|\/+/i).forEach(t=>{
      t = t.trim();
      if(t) types.add(t);
    });
  }
  // catch ‚Äúis every/all creature type(s)‚Äù
  if(/\b(?:equipped|enchanted)\s+creature\b.*?\bis\s+(?:also\s+)?(?:every|all)\s+creature\s+type[s]?\b/i.test(text)){
    types.add('every creature type');
  }

  // --- Additional effects (e.g. ‚Äúhas haste and shroud‚Äù, ‚Äúgains flying‚Äù, ‚Äúcan‚Äôt be blocked‚Äù)
  const hasRe   = /\b(?:equipped|enchanted)\s+creature\b.*?\bhas\s+([^.\n]+)/gi;
  const gainsRe = /\b(?:equipped|enchanted)\s+creature\b.*?\bgains\s+([^.\n]+)/gi;
  const cantRe  = /\b(?:equipped|enchanted)\s+creature\b.*?\b(can(?:'t|not)\s+[^.\n]+)/gi;

  function takeList(re){
    let mm;
    while((mm = re.exec(text))){
      // drop reminder text like ‚Äú(It can‚Äôt be ‚Ä¶)‚Äù
      let listStr = (mm[1] || '').replace(/\([^)]*\)/g,'').trim();
      listStr.split(/\s*,\s*|\s+and\s+|\s+or\s+/i).forEach(k=>{
        k = k.trim().replace(/^(?:have|has|gains)\s+/i,'');
        if(k) effects.add(k);
      });
    }
  }
  takeList(hasRe);
  takeList(gainsRe);
  let mc; while((mc = cantRe.exec(text))){ const clause=(mc[1]||'').trim(); if(clause) effects.add(clause); }

  // prune accidental P/T captures like ‚Äú+2/+2‚Äù
  for(const e of Array.from(effects)){
    if(/^[+\-]?\d+\s*\/\s*[+\-]?\d+$/.test(e)) effects.delete(e);
  }
  return { types: [...types], effects: [...effects] };
}

function grantedFromAttachments(base){
  const types = new Set();
  const effects = new Set();
  if(!base || !base._stack || base._stack.length < 2) return {types:[], effects:[]};

  for(let i=1;i<base._stack.length;i++){
    const att = base._stack[i];

    // 1) parse from the attachment‚Äôs oracle text (existing behavior)
    const g = parseGrantedInfoFromOracle( oracleText(att) );
    g.types.forEach(t => types.add(t));
    g.effects.forEach(e => effects.add(e));

    // 2) include manual extras saved via the editor
    if (att._extras){
      (att._extras.addTypes || []).forEach?.(t => types.add(t));
      (att._extras.addEffects || []).forEach?.(e => effects.add(e));
      // chosenType doesn‚Äôt auto-grant a *type* to the base creature by itself,
      // so we skip it here.
    }
    // Back-compat if something still writes to _meta
    if (att._meta){
      (att._meta.extraTypes || []).forEach(t => types.add(t));
      (att._meta.extraEffects || []).forEach(e => effects.add(e));
    }
  }
  return { types:[...types], effects:[...effects] };
}



/* ===== Mana ‚Üí icon HTML ===== */
function escapeHTML(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

function manaClassForSymbol(sym){
  // Normalize like {w/u}, {W/P}, {2/W}, {C}, {S}, numbers, X/Y/Z
  const S = sym.toUpperCase();

  // plain numbers and single symbols
  if (/^\d+$/.test(S)) return 'ms-' + S;
  if (['W','U','B','R','G','C','S','X','Y','Z'].includes(S)) return 'ms-' + S.toLowerCase();

  // hybrids & phyrexian: {W/U}, {2/W}, {W/P}
  if (S.includes('/')){
    const parts = S.split('/');
    // phyrexian (W/P or P/W)
    if (parts.includes('P')){
      const color = (parts[0]==='P' ? parts[1] : parts[0]).toLowerCase();
      return 'ms-p' + color; // e.g. ms-pw
    }
    // two-color hybrid, e.g. W/U ‚Üí ms-wu
    if (parts.length === 2 && parts[0] !== '2' && parts[1] !== '2'){
      return 'ms-' + parts.map(p=>p.toLowerCase()).join('');
    }
    // 2/color hybrid, e.g. 2/W ‚Üí ms-2w
    if (parts.includes('2')){
      const color = (parts[0]==='2' ? parts[1] : parts[0]).toLowerCase();
      return 'ms-2' + color;
    }
  }
  // Fallback if some odd symbol appears
  return null;
}

function renderManaCost(cost, withRing=true){
  if(!cost) return '';
  const tokens = cost.match(/\{[^}]+\}/g) || [];
  return tokens.map(tok=>{
    const cls = manaClassForSymbol(tok.slice(1,-1));
    return cls ? `<i class="ms ${withRing ? 'ms-cost' : ''} ${cls}"></i>` : escapeHTML(tok);
  }).join('');
}



// Only sets text; showing/positioning is handled by updateHint()
function fillHintContent(card){
  const d = card?._data || {};
  const face = (d?.card_faces && d.card_faces[0]) || null;

  const mana = (d?.mana_cost || face?.mana_cost || '') || '';
  const type = (d?.type_line  || face?.type_line  || '') || '';

  const p = (d?.power ?? face?.power);
  const t = (d?.toughness ?? face?.toughness);
  const pt = (p != null && t != null) ? `${p}/${t}` : '';
  const loyalty = (d?.loyalty ?? face?.loyalty) ? `Loyalty ${d?.loyalty ?? face?.loyalty}` : '';
  const defense = (d?.defense ?? face?.defense) ? `Defense ${d?.defense ?? face?.defense}` : '';

  hTitle.textContent = d?.name || card?.getAttribute('data-name') || '';
  const stat = pt || loyalty || defense;
  // Build the meta line with icons for the cost
  const manaHTML = renderManaCost(mana, true); // true = show cost ring style
  const parts = [];
  if (manaHTML) parts.push(`<span class="mana-line">${manaHTML}</span>`);
  if (type)     parts.push(escapeHTML(type));
  if (stat)     parts.push(escapeHTML(stat));
  hMeta.innerHTML = parts.join(' ‚Ä¢ ');

  // Base oracle (single- or multi-faced)
  let oracle = d?.oracle_text || '';
  if (!oracle && d?.card_faces){
    oracle = d.card_faces.map(f => (f.name||'') + "\n" + (f.oracle_text||'')).join("\n‚Äî\n");
  }

  // If the selected card itself grants to an equipped/enchanted creature, summarize it.
  let selfExtra = '';
  if(/\b(?:equipped|enchanted)\s+creature\b/i.test(oracle)){
    const g = parseGrantedInfoFromOracle(oracle);
    const lines = [];
    if(g.types.length)   lines.push('Additional Types: '   + g.types.join(', '));
    if(g.effects.length) lines.push('Additional Effects: ' + g.effects.join(', '));
    if(lines.length) selfExtra = '\n\n' + lines.join('\n');
  }

  // If this card is (or is part of) a stacked creature, aggregate what its attachments grant.
  let attachExtra = '';
  const base = getStackBase(card) || card;
  if (isCreatureCard(base) && base._stack && base._stack.length > 1) {
    const agg = grantedFromAttachments(base);
    // (Optionally subtract keywords already on base oracle to avoid dupes.)
    const lines = [];
    if(agg.types.length)   lines.push('Additional Types: '   + agg.types.join(', '));
    if(agg.effects.length) lines.push('Additional Effects: ' + agg.effects.join(', '));
    if(lines.length) attachExtra = '\n\n' + lines.join('\n');
  }

  // --- NEW: include the base creature's own manual extras (from overlay) ---
  let baseManual = '';
  if (base && (base._extras || base._meta)){
    const bTypes   = base._extras ? Array.from(base._extras.addTypes   || []) : (base._meta?.extraTypes   || []);
    const bEffects = base._extras ? Array.from(base._extras.addEffects || []) : (base._meta?.extraEffects || []);
    const blines = [];
    if (bTypes.length)   blines.push('Additional Types: '   + bTypes.join(', '));
    if (bEffects.length) blines.push('Additional Effects: ' + bEffects.join(', '));
    if (blines.length) baseManual = '\n\n' + blines.join('\n');
  }

  // Prefer attachment summary when you‚Äôre looking at the creature; otherwise the card‚Äôs own grant summary.
  // Also append the base creature's manual extras when viewing the base creature.
  const extra = (isCreatureCard(base) && base===card) ? (attachExtra + baseManual) : selfExtra;

  const bodyHTML  = renderTextWithIcons(oracle || '', true);  // true = ringed style; set false for flat
  const extraHTML = extra ? ('\n\n' + extra) : '';
  hTxt.innerHTML  = bodyHTML + escapeHTML(extraHTML).replace(/\n/g,'<br>');
}





// Position the tooltip centered above the *center in-hand card*.
// Hide it if no selection, or no in-hand center exists.
function updateHint(){
  if (hintSuppressed) {          // <-- added
    hint.style.display = 'none';
    return;
  }
  if(!selectedCard){
    hint.style.display='none';
    return;
  }
  const cards = handCards();
  if(!cards.length){
    hint.style.display='none';
    return;
  }
  const center = cards[handIndex];
  if(!center){
    hint.style.display='none';
    return;
  }

  // Ensure the content matches the *selected* card
  fillHintContent(selectedCard);

  // Compute position above the center hand card
  const r = center.getBoundingClientRect();
  const padY = 10; // gap above the card
  const hintW = parseFloat(getComputedStyle(hint).width) || 320;
  const left = Math.round(r.left + (r.width/2) - (hintW/2));
  // Render off-screen to measure height on first show
  hint.style.display='block';
  const hintH = hint.offsetHeight || 0;

  let top = Math.round(r.top - hintH - padY);
  let clampedLeft = Math.max(8, Math.min(left, window.innerWidth - hintW - 8));
  if(top < 8) top = 8;

  hint.style.left = clampedLeft + 'px';
  hint.style.top  = top + 'px';
}

// Back-compat name used by layoutHand(); just call updateHint()
function syncCenterTooltip(){ updateHint(); }


/* =========================================================
   Stacks ‚Äî data & layout (adapted from your test file)
   ========================================================= */
let nextStackId=1;

/* Returns the base (bottom) card of a stack for any member, or null. */
function getStackBase(card){
  if(card.dataset.stackBase==='1') return card;
  if(!card.dataset.stackId) return null;
  return document.querySelector(`.card[data-stack-id="${card.dataset.stackId}"][data-stack-base="1"]`);
}
/* Ensure a base has a stack id/array and return the id. */
function initStack(base){
  if(base.dataset.stackId) return base.dataset.stackId;
  const id=String(nextStackId++);
  base.dataset.stackId=id;
  base.dataset.stackBase='1';
  base._stack=[base];
  return id;
}
/* Couple card into base‚Äôs stack and lay it out. */
function addToStack(base,card){
  const id=initStack(base);
  card.dataset.stackId=id;
  card.dataset.stackBase='0';
  const arr=base._stack||(base._stack=[base]);
  if(!arr.includes(card)) arr.push(card);
  layoutStack(base);
  refreshPTForCard(base);
  if (selectedCard) updateHint();         
}



/* Decouple a member from a stack. */
function removeFromStack(base, card){
  const arr = base?._stack; if (!arr) return;
  const i = arr.indexOf(card);
  if (i > 0){
    arr.splice(i, 1);

    // If stack now only has the base, clear its stack markers
    if (arr.length === 1) {
      delete base.dataset.stackId;
      delete base.dataset.stackBase;
      delete base._stack;
    } else {
      // Otherwise, re-layout immediately so indices/z-order/positions update
      layoutStack(base);
    }

    // Clean the detached card‚Äôs markers
    delete card.dataset.stackId;
    delete card.dataset.stackBase;

    refreshPTForCard(base);
    refreshPTForCard(card);
    if (selectedCard) updateHint();
  }
}


/* Position all members relative to base (vertical ‚Äúpile‚Äù). */
function layoutStack(base){
  const arr=base._stack||[];
  const baseZ=parseInt(base.style.zIndex||10,10);
  const gapY=34; // vertical offset between stacked cards
  const x=parseFloat(base.style.left)||0, y=parseFloat(base.style.top)||0;
  arr.forEach((c,i)=>{
    c.style.left = x + 'px';
    c.style.top  = (i===0 ? y : (y - i*gapY)) + 'px';
    c.style.zIndex = (i===0 ? baseZ : (baseZ - i - 1));
  });
}

/* Simple overlap + ‚Äútop card at point‚Äù helper used on drop. */
function rectsOverlap(a,b){ return !(a.right<b.left || a.left>b.right || a.bottom<b.top || a.top>b.bottom); }
function topCardAtClient(x,y,exclude){
  const els=document.elementsFromPoint(x,y);
  for(const el of els){
    const c=el.closest && el.closest('.card');
    if(c && c!==exclude && c.parentElement===world) return c;
  }
  return null;
}

/* =========================================================
   Selection + table-card drags (now stack-aware)
   ========================================================= */

// Clear all selection outlines and state + hide tooltip
function clearSelection(){
hideAllGears();

  if(selectedGroup && selectedGroup.length){
    selectedGroup.forEach(c => c.classList.remove('selected'));
  }
  selectedGroup = [];
  selectedCard = null;
  hint.style.display='none';
}

// Select `card` and everything below it in its stack (base..card) + show tooltip.
// If the selected card isn't hydrated yet (no _data), fetch it first so the tooltip
// can render mana, type line, oracle text, etc.
function setSelectionFromCard(card){
  hint.style.display = 'none';
  clearSelection();
  selectedCard = card;
  hideAllGears();
showGearFor(selectedCard);

  selectedGroup = stackSliceFrom(card);
  selectedGroup.forEach(c => c.classList.add('selected'));

  // If this card (or the base) doesn‚Äôt have Scryfall data yet, hydrate it.
  const base = getStackBase(card) || card;
  const needsHydrate = !base._data || !card._data;

  if (needsHydrate && typeof hydrateCardData === 'function'){
    // Hydrate the specific card the user selected (and the base if different)
    const promises = [];
    if (!card._data) promises.push(hydrateCardData(card));
    if (base !== card && !base._data) promises.push(hydrateCardData(base));

    Promise.all(promises).finally(()=>{
      // Once data is in, refresh the tooltip with rich info
      updateHint();
      // Also refresh P/T badge if this selection affects it
      refreshPTForCard(base);
    });
  } else {
    updateHint();
  }
}


function makeDraggable(card){
  const body=card.querySelector('.cardBody');
  let dragging=false, offX=0, offY=0, draggingBase=null, draggingGroup=null;

  body.addEventListener('pointerdown', e=>{
    e.preventDefault();
    if(card.parentElement===handZone) return; // hand owns swipe/lift gestures

    // Select this card + all below it in its stack
    setSelectionFromCard(card);
hintSuppressed = true;           // <-- added
hint.style.display = 'none';
    // If the pressed card is the *base* of a stack, drag the whole group.
    const base = getStackBase(card) || card;
    if(base===card && base._stack && base._stack.length>1){
      draggingBase = base;
      draggingGroup = [...base._stack];
    }else{
      draggingBase = null;
      draggingGroup = null;
    }

    // Finger offset within the element we actually move
    const targetForOffset = draggingBase || card;
    const r=targetForOffset.getBoundingClientRect();
    offX=e.clientX-r.left; offY=e.clientY-r.top;

    dragging=true; (draggingBase||card).style.zIndex=++zCounter; body.setPointerCapture(e.pointerId);
  });

  body.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const rTable=table.getBoundingClientRect();
    const worldX=(e.clientX-rTable.left-state.tx)/state.scale;
    const worldY=(e.clientY-rTable.top -state.ty)/state.scale;

    if(draggingBase){
      // Move base, then re-layout the stack
      draggingBase.style.left=(worldX-offX/state.scale)+'px';
      draggingBase.style.top =(worldY-offY/state.scale)+'px';
      layoutStack(draggingBase);
    }else{
      // Move single card
      card.style.left=(worldX-offX/state.scale)+'px';
      card.style.top =(worldY-offY/state.scale)+'px';
    }
  });

function deleteCardVisual(card){
  if(!card) return;
  const cid = card.dataset && card.dataset.cid;
  if (cid) {
    document.querySelectorAll(`.card[data-cid="${cid}"]`).forEach(el => el.remove());
  } else {
    card.remove();
  }
}

// Move ‚Üí hide ‚Üí save (KEEP the DOM node so future saves see ALL zone cards)
async function transferToZoneThenSaveThenDelete(card, zoneEl, playerId){
  if (!card || !zoneEl) return;

  // stable id so multiple DOM copies won't confuse anything
  const cid = card.dataset.cid || (card.dataset.cid = String(Math.random()).slice(2));

  // 1) Reparent into the zone so serialize() will include it
  zoneEl.appendChild(card);
  restoreTableSize(card);
  card.style.left = '0px';
  card.style.top  = '0px';

  // 2) Hide so it disappears immediately from the table view and can't block clicks
  card.style.display = 'none';
  card.style.pointerEvents = 'none';
  card.dataset.inZone = '1';   // optional marker

  // 3) Save ‚Äî now the zone contains A, then A+B, then A+B+C, etc.
  try {
    if (typeof savePlayerState === 'function') {
      await savePlayerState(playerId);
    }
  } catch (e) {
    console.warn('[zone-save] failed:', e);
  }

  // IMPORTANT CHANGE: DO NOT REMOVE THE CARD FROM THE DOM.
  // Keeping it (hidden) means future saves will include ALL cards in the zone.
}




  function stop(e){
  if(!dragging) return;
  dragging = false;

  // helper so we don't forget to re-show it
  const showHintIfSelected = ()=>{
    hintSuppressed = false;
    updateHint();
  };

  // AABB overlap helper
  const rectsOverlap = (a,b) => !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);

  // current rects
  const cr = card.getBoundingClientRect();
  const hz = handZone.getBoundingClientRect();
  const gyEl = document.querySelector('.graveyard');
  const exEl = document.querySelector('.exile');
  const gy = gyEl ? gyEl.getBoundingClientRect() : null;
  const ex = exEl ? exEl.getBoundingClientRect() : null;

  // Hand overlap ‚Üí goes to hand (no hint wanted)
  if (rectsOverlap(cr, hz)){
    const base = getStackBase(card);
    if (base && base !== card) removeFromStack(base, card);
    moveToHand(card);
    clearSelection();
    // no hint here (hand behavior matched)
    return;
  }
  // Graveyard overlap
if (gy && rectsOverlap(cr, gy)){
  const base = getStackBase(card);
  if (base && base !== card) removeFromStack(base, card);
  // kick off move‚Üíhide‚Üísave‚Üídelete (no await; stop(e) stays sync)
  transferToZoneThenSaveThenDelete(card, gyEl, currentPlayer);
  return;
}

// Exile overlap
if (ex && rectsOverlap(cr, ex)){
  const base = getStackBase(card);
  if (base && base !== card) removeFromStack(base, card);
  transferToZoneThenSaveThenDelete(card, exEl, currentPlayer);
  return;
}



  // Stack modes (existing behavior preserved)
  if (stackMode){
    const target = topCardAtClient(e.clientX, e.clientY, card);
    if (target){
      if (stackMode === 'up'){
        const base = getStackBase(target) || target;
        if (card.parentElement !== world) world.appendChild(card);
        const oldBase = getStackBase(card);
        if (oldBase && oldBase !== base) removeFromStack(oldBase, card);
        addToStack(base, card);
        setSelectionFromCard(card);
        showHintIfSelected();
        recomputeContinuousEffects();
        if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);
        return;
      }

      // left / right row placement
      const tgt3d = target.querySelector('.card3d') || target.querySelector('.cardBody');
      const tapped = (tgt3d && (tgt3d.style.transform || '').includes('rotate(90deg)'));
      const w = parseFloat(getComputedStyle(target).width) || 0;
      const h = parseFloat(getComputedStyle(target).height) || 0;
      const pad = 12, delta = (tapped ? h : w) + pad;
      const baseX = parseFloat(target.style.left) || 0;
      const baseY = parseFloat(target.style.top) || 0;
      const newX = (stackMode === 'right') ? (baseX + delta) : (baseX - delta);

      const oldBase = getStackBase(card);
      if (oldBase) removeFromStack(oldBase, card);

      // ensure card is on world
      if (card.parentElement !== world) world.appendChild(card);

      card.style.left = newX + 'px';
      card.style.top  = baseY + 'px';

      setSelectionFromCard(card);
      refreshPTForCard(card);
      showHintIfSelected();
      recomputeContinuousEffects();
      if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);
      return;
    }
  }

  // detach-or-restack case‚Ä¶ (neighbor-based)
  const base = getStackBase(card);
  if (base && base !== card && Array.isArray(base._stack)){
    const arr = base._stack;
    const idx = arr.indexOf(card);
    if (idx > 0){
      const below = arr[idx - 1];
      const br = below.getBoundingClientRect();
      const mr = card.getBoundingClientRect();

      // If I'm no longer overlapping the card directly below me, detach.
      if (!rectsOverlap(mr, br)){
        removeFromStack(base, card);
      } else {
        // still overlapping -> snap back into vertical stack
        layoutStack(base);
        refreshPTForCard(base);
      }
    }
  }

  // final: keep selection on table drops so T/F works immediately
  setSelectionFromCard(card);
  showHintIfSelected();
  // refresh global static effects after moves/stacks
  recomputeContinuousEffects();
  // persist after drag/drop/stack operations
  if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);
}




  body.addEventListener('pointerup', stop);
  body.addEventListener('pointercancel', stop);

  // No hover tooltip anymore ‚Äî only show when selected
  body.addEventListener('mouseenter', ()=>{
    if(selectedCard===card) updateHint();
  });
  body.addEventListener('mouseleave', ()=>{ /* noop: selection drives tooltip */ });
}


function applyMetallicMimicETB(creatureCard){
  if(!isCreatureCard(creatureCard)) return;
  const myTypes = getEffectiveTypes(creatureCard).map(t=>t.toLowerCase());
  // find any Metallic Mimic with chosenType matching one of my types
  const mimics = Array.from(world.querySelectorAll('.card')).filter(c=>{
    const n = (c._data?.name || c.getAttribute('data-name') || '').toLowerCase();
    return c.parentElement===world && n==='metallic mimic' && (c._meta?.chosenType || '').trim();
  });
  let bonus = 0;
  mimics.forEach(mm=>{
    const chosen = (mm._meta?.chosenType || '').trim().toLowerCase().replace(/s$/,'');
    if(chosen && myTypes.some(t=>t.toLowerCase()===chosen)) bonus += 1;
  });
  if(bonus>0){
    const meta = creatureCard._meta || (creatureCard._meta = { extraTypes:[], extraEffects:[], ptMod:{dp:0,dt:0}, chosenType:'' });
    meta.ptMod.dp = Number(meta.ptMod.dp||0) + bonus;
    meta.ptMod.dt = Number(meta.ptMod.dt||0) + bonus;
    refreshPTForCard(creatureCard);
  }
}


/* Build the DOM for a new card, wire it, and fetch art/text. */
/* Build the DOM for a new card, wire it, fetch art/text, and add the ‚öôÔ∏è editor */
function spawnCard(name, x=300, y=150){
  const card=document.createElement('div'); 
  card.className='card'; 
  card.style.left=x+'px'; 
  card.style.top=y+'px'; 
  card.style.zIndex=++zCounter; 
  card.setAttribute('data-name',name);

  const body=document.createElement('div'); 
  body.className='cardBody';

  const c3=document.createElement('div'); 
  c3.className='card3d';

  const inner=document.createElement('div'); 
  inner.className='inner';

  const f1=document.createElement('div'); 
  f1.className='face front'; 
  const imgF=document.createElement('img'); 
  imgF.alt=name; 
  imgF.draggable=false; 
  f1.appendChild(imgF);

  const f2=document.createElement('div'); 
  f2.className='face back'; 
  const imgB=document.createElement('img'); 
  imgB.alt='Card back'; 
  imgB.src=CARD_BACK; 
  imgB.draggable=false; 
  f2.appendChild(imgB);

  inner.appendChild(f1); 
  inner.appendChild(f2); 
  c3.appendChild(inner); 
  body.appendChild(c3); 
  card.appendChild(body);

  // wire drag
  makeDraggable(card); 
  world.appendChild(card);

  // add the gear
  attachGearButton(card);

  // default extras container
  if (!card._extras) card._extras = { addTypes:new Set(), addEffects:new Set(), dp:0, dt:0, chosenType:'' };

  // fetch art + oracle text
  fetchCard(name).then(async d=>{
    card._data=d;
    const uris=candidateUris(d);
    await loadFirstWorking(imgF,uris);

    // P/T badge if creature
    refreshPTForCard(card);

    // Only update tooltip if this card is currently selected
    if(selectedCard===card) updateHint();

    // OPTIONAL one-liner: handle ETB choose-type prompts (e.g., Metallic Mimic)
    // If you don‚Äôt want this, comment the next call out.
    maybePromptChooseTypeOnETB(card);

  }).catch(()=>{});

  return card;
}


/* =========================
   Manual meta helpers + editor
   ========================= */

/* Apply saved meta fields to a card, then refresh visuals */
function applySavedMeta(card, saved){
  if(!card) return;
  const m = card._meta || (card._meta = { extraTypes:[], extraEffects:[], ptMod:{dp:0,dt:0}, chosenType:'' });
  if(saved){
    m.extraTypes   = Array.isArray(saved.extraTypes)   ? saved.extraTypes : (typeof saved.extraTypes==='string' ? saved.extraTypes.split(',').map(s=>s.trim()).filter(Boolean) : []);
    m.extraEffects = Array.isArray(saved.extraEffects) ? saved.extraEffects : (typeof saved.extraEffects==='string' ? saved.extraEffects.split(',').map(s=>s.trim()).filter(Boolean) : []);
    if(saved.ptMod && (typeof saved.ptMod.dp==='number' || typeof saved.ptMod.dt==='number')){
      m.ptMod = { dp: Number(saved.ptMod.dp||0), dt: Number(saved.ptMod.dt||0) };
    }
    if(typeof saved.chosenType === 'string') m.chosenType = saved.chosenType.trim();
  }
  // refresh P/T & tooltip
  refreshPTForCard(card);
  if(selectedCard===card) updateHint();
}

/* Return all effective creature types for a card: oracle types + manual extra types */
function getEffectiveTypes(card){
  const d = card?._data || {};
  const face = (d.card_faces && d.card_faces[0]) || null;
  const typeLine = (d.type_line || face?.type_line || '') + '';
  // very coarse extraction of types: split before "‚Äî" and take words
  const main = typeLine.split('‚Äî')[0] || '';
  const fromOracle = main.split(/\s+/).filter(Boolean); // includes super/sub types; OK for heuristics
  const extras = (card._meta?.extraTypes || []).slice();
  // Metallic Mimic style chosen type can be included as well
  if(card._meta?.chosenType) extras.push(card._meta.chosenType);
  // Unique, basic normalize (singularize naive: Zombies -> Zombie)
  const norm = t => t.replace(/s$/i,'');
  return Array.from(new Set(fromOracle.concat(extras).map(norm)));
}

/* Very small rule engine: anthem-like static buffs
   Looks for text like "Other Zombies you control get +1/+1". */
function recomputeContinuousEffects(){
  // 1) compute per-creature lord buffs
  const tableCreatures = Array.from(world.querySelectorAll('.card')).filter(c => c.parentElement===world && isCreatureCard(c));
  // Pre-parse possible lords
  const lords = Array.from(world.querySelectorAll('.card')).filter(c => c.parentElement===world);
  const lordSpecs = lords.map(c=>{
    const txt = oracleText(c);
    // match: Other X you control get +n/+m
    // X can be a single word like Zombies, Vampires, Goblins
    const re = /Other\s+([A-Za-z]+)s?\s+you\s+control\s+get\s*\+(\d+)\s*\/\s*\+(\d+)/ig;
    const hits = [];
    let m;
    while((m=re.exec(txt))){
      hits.push({ type: m[1].replace(/s$/i,''), dp: parseInt(m[2],10)||0, dt: parseInt(m[3],10)||0, source:c });
    }
    return { card:c, hits };
  });

  // 2) for each creature, sum buffs from all other lords that match type
  tableCreatures.forEach(crea=>{
    // base refresh (includes equipment parsing) first
    refreshPTForCard(crea);

    // manual pt mod
    const meta = crea._meta || { ptMod:{dp:0,dt:0} };
    const manualDP = Number(meta.ptMod?.dp||0);
    const manualDT = Number(meta.ptMod?.dt||0);

    // then anthem overlays
    const myTypes = getEffectiveTypes(crea);
    let sumDP = manualDP, sumDT = manualDT;

    lordSpecs.forEach(spec=>{
      if(!spec.hits.length) return;
      // "Other" means the lord should not buff itself even if it matches
      if(spec.card === crea) return;
      spec.hits.forEach(h=>{
        if(myTypes.some(t => t.toLowerCase() === h.type.toLowerCase())){
          sumDP += h.dp;
          sumDT += h.dt;
        }
      });
    });

    // show final overlay as base+equip already done by refreshPTForCard; we add manual+anthem on top visually
    // easiest: append text to the PT badge title and re-render with a synthetic add
    const base = getStackBase(crea) || crea;
    // We piggyback on updateCreaturePT output but we want to show final including manual + anthem.
    // Read the badge current text as final-from-equipment, add our sum on top:
    const el = base._ptBadge || ensurePTBadge(base);
    const curr = el.textContent || '';
    const mm = curr.match(/(\d+)\s*\/\s*(\d+)/);
    if(mm){
      const p = parseInt(mm[1],10)||0, t=parseInt(mm[2],10)||0;
      const fp = p + manualDP; 
      const ft = t + manualDT;
      el.textContent = `${fp}/${ft}`;
      let reasons = [`Manual ${manualDP>=0?'+':''}${manualDP}/${manualDT>=0?'+':''}${manualDT}`];
      // summarize anthem if any
      const anthemSum = (sumDP - manualDP) || (sumDT - manualDT);
      if(anthemSum){
        reasons.push(`Anthem ${ (sumDP-manualDP)>=0?'+':'' }${sumDP-manualDP}/${ (sumDT-manualDT)>=0?'+':'' }${sumDT-manualDT}`);
      }
      el.title = (el.title ? (el.title + '\n') : '') + reasons.join('\n');
      el.style.display='block';
    }
  });
}

/* Editor overlay for one card */
function openCardEditor(card){
  // remove any existing
  const old = document.getElementById('cardMetaEditor');
  if(old) old.remove();

  const overlay = document.createElement('div');
  overlay.id='cardMetaEditor';
  overlay.style.position='fixed';
  overlay.style.inset='0';
  overlay.style.background='rgba(0,0,0,.72)';
  overlay.style.zIndex='99999';
  overlay.style.display='flex';
  overlay.style.alignItems='center';
  overlay.style.justifyContent='center';
  overlay.addEventListener('pointerdown',(e)=>{ if(e.target===overlay) overlay.remove(); });

  const panel = document.createElement('div');
  panel.style.width='min(520px, 92vw)';
  panel.style.maxHeight='86vh';
  panel.style.overflow='auto';
  panel.style.background='#0b0f15';
  panel.style.border='1px solid #24324a';
  panel.style.borderRadius='14px';
  panel.style.padding='16px';
  panel.style.boxShadow='0 18px 48px rgba(0,0,0,.6)';
  panel.style.color='#e7e9ee';
  panel.addEventListener('pointerdown', e=>e.stopPropagation());

  const title = document.createElement('h3');
  title.textContent = (card._data?.name) || card.getAttribute('data-name') || 'Card';
  title.style.margin='0 0 8px';
  panel.appendChild(title);

  const row = (label, inputEl) => {
    const wrap = document.createElement('div');
    wrap.style.margin='10px 0';
    const lab = document.createElement('div');
    lab.textContent = label;
    lab.style.fontSize='12px';
    lab.style.opacity='0.85';
    lab.style.margin='0 0 4px';
    wrap.appendChild(lab);
    wrap.appendChild(inputEl);
    return wrap;
  };

  const mkInput = () => {
    const i = document.createElement('input');
    i.type='text';
    i.style.width='100%';
    i.style.border='1px solid #24324a';
    i.style.borderRadius='10px';
    i.style.background='#0a0f16';
    i.style.color='#e7e9ee';
    i.style.padding='10px';
    i.style.font='14px/1.4 ui-monospace, Menlo, Consolas, monospace';
    return i;
  };

  const iTypes = mkInput();
  iTypes.placeholder='Comma-separated (e.g., Zombie, Warrior)';
  iTypes.value = (card._meta?.extraTypes||[]).join(', ');

  const iEffects = mkInput();
  iEffects.placeholder='Comma-separated (e.g., menace, shroud)';
  iEffects.value = (card._meta?.extraEffects||[]).join(', ');

  const rowPT = document.createElement('div');
  rowPT.style.display='grid';
  rowPT.style.gridTemplateColumns='1fr 1fr';
  rowPT.style.gap='10px';
  const iP = mkInput(); iP.placeholder='+/- Power delta'; iP.value = String(card._meta?.ptMod?.dp||0);
  const iT = mkInput(); iT.placeholder='+/- Toughness delta'; iT.value = String(card._meta?.ptMod?.dt||0);
  rowPT.appendChild(iP); rowPT.appendChild(iT);

  const iChosen = mkInput();
  iChosen.placeholder='Chosen Type (for ‚Äúchoose a type‚Äù cards)';
  iChosen.value = card._meta?.chosenType || '';

  const btns = document.createElement('div');
  btns.style.display='flex';
  btns.style.gap='8px';
  btns.style.marginTop='12px';

  const save = document.createElement('button');
  save.textContent='Save';
  save.className='pill';
  save.style.cursor='pointer';
save.addEventListener('click', ()=>{
  // 1) Keep _meta (back-compat with older code)
  const meta = card._meta || (card._meta = { extraTypes:[], extraEffects:[], ptMod:{dp:0,dt:0}, chosenType:'' });
  meta.extraTypes  = iTypes.value.split(',').map(s=>s.trim()).filter(Boolean);
  meta.extraEffects= iEffects.value.split(',').map(s=>s.trim()).filter(Boolean);
  meta.ptMod       = { dp:Number(iP.value||0), dt:Number(iT.value||0) };
  meta.chosenType  = iChosen.value.trim();

  // 2) NEW: also mirror into _extras (this is what serializeCard persists)
  const ex = card._extras || (card._extras = { addTypes:new Set(), addEffects:new Set(), dp:0, dt:0, chosenType:'' });
  ex.addTypes   = new Set(meta.extraTypes);
  ex.addEffects = new Set(meta.extraEffects);
  ex.dp         = meta.ptMod.dp;
  ex.dt         = meta.ptMod.dt;
  ex.chosenType = meta.chosenType;

  // 3) Refresh visuals/tooltips and recompute buffs, then persist
  refreshPTForCard(card);
  recomputeContinuousEffects?.();
  if (selectedCard === card) updateHint();
  if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);

  overlay.remove();
});



  const close = document.createElement('button');
  close.textContent='Close';
  close.className='pill';
  close.style.cursor='pointer';
  close.addEventListener('click', ()=>overlay.remove());

  panel.appendChild(row('Additional Types', iTypes));
  panel.appendChild(row('Additional Effects', iEffects));
  panel.appendChild(rowPT);
  panel.appendChild(row('Chosen Type', iChosen));
  btns.appendChild(save);
  btns.appendChild(close);
  panel.appendChild(btns);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);
}



/* Build a table card from a saved snapshot object */
function spawnCardFromSaved(c){
  // build DOM
  const card = document.createElement('div');
  card.className = 'card';
    // ensure DOM id matches saved record so cleanup can find it
  card.dataset.cid = c.id ? String(c.id) : (card.dataset.cid || String(Math.random()).slice(2));
  card.id = `card-${card.dataset.cid}`;

  const isZone = (c.parent === 'hand' || c.parent === 'zone-hand' ||
                  c.parent === 'graveyard' || c.parent === 'exile' ||
                  c.parent === 'commander');
  if (isZone){
    card.style.left = '0px';
    card.style.top  = '0px';
    card.style.zIndex = (c.z || 10);
  } else {
    card.style.left   = (c.x || 0) + 'px';
    card.style.top    = (c.y || 0) + 'px';
    card.style.zIndex = (c.z || 10);
  }
  if (c.name) card.setAttribute('data-name', c.name);

  const body  = document.createElement('div'); body.className = 'cardBody';
  const c3    = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img');
  imgF.alt = c.name || '';
  imgF.draggable = false;
  if (c.img) imgF.src = c.img;   // fast path: use saved art if present
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img');
  imgB.alt = 'Card back';
  imgB.src = CARD_BACK;
  imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2);
  c3.appendChild(inner);
  body.appendChild(c3);
  card.appendChild(body);

  // restore flip/tap
  if (c.flipped) card.classList.add('flipped');
  if (c.tapped)  c3.style.transform = 'rotate(90deg)';

  // add to world first so sizing/transform math is valid
  world.appendChild(card);

  // gear button for the editor
  if (typeof attachGearButton === 'function') attachGearButton(card);

  // restore saved extras/meta (types/effects/ptMod/chosenType) if you updated serializeCard to store them
  if (typeof applySavedCardExtras === 'function') applySavedCardExtras(card, c);

  // wire dragging unless we‚Äôre explicitly in read-only viewer
  if (!viewerMode && typeof makeDraggable === 'function') makeDraggable(card);

  // Hydrate with Scryfall so tooltips/PT/oracle are correct (and art if none was saved)
  if (typeof hydrateCardData === 'function') {
    // after hydration, re-evaluate buffs if it‚Äôs a creature
    Promise.resolve(hydrateCardData(card)).then(()=>{
      if (typeof isCreatureCard === 'function' && typeof recomputeContinuousEffects === 'function'){
        if (isCreatureCard(card)) recomputeContinuousEffects();
      }
    });
  }

  return card;
}



/* =========================================================
   Hand zone (carousel + move in/out)
   ========================================================= */
function handCards(){ return Array.from(handZone.querySelectorAll('.card')); }

function moveToHand(card){
  // If card belongs to a stack, cleanly decouple
  const base=getStackBase(card);
  if(base && base!==card) removeFromStack(base,card);

  handZone.appendChild(card);
  card.classList.add('in-hand');
  card.classList.remove('hand-small','hand-left','hand-right','hand-center','hand-hidden','hand-l2','hand-l3','hand-r2','hand-r3','hand-slot');

  // Clear any absolute position (hand layout owns it)
  card.style.left=''; card.style.top=''; card.style.zIndex=++zCounter;

  // IMPORTANT: clear any inline transform on the interactive child so hand sizing works
  const body=card.querySelector('.cardBody'); if(body) body.style.transform='';
  const card3d=card.querySelector('.card3d'); // keep taps/rotations as-is ‚Äî hand scales the wrapper element

  layoutHand();
  if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);
}


function removeFromHand(card){
  if(card.parentElement!==handZone) return;
  card.classList.remove('in-hand','hand-small','hand-left','hand-right','hand-center','hand-hidden','hand-l2','hand-l3','hand-r2','hand-r3','hand-slot');
  restoreTableSize(card);
}

function layoutHand(){
  const cards = handCards();
  if(cards.length===0){ handZone.querySelector('.label').textContent='Hand'; return; }
  if(handIndex >= cards.length) handIndex = cards.length-1;
  if(handIndex < 0) handIndex = 0;
  handZone.querySelector('.label').textContent='';

  const n = cards.length;
  const norm = k => (k + n) % n;

  const l1 = norm(handIndex - 1), l2 = norm(handIndex - 2), l3 = norm(handIndex - 3);
  const r1 = norm(handIndex + 1), r2 = norm(handIndex + 2), r3 = norm(handIndex + 3);

  cards.forEach((c,i)=>{
    c.classList.remove('hand-small','hand-left','hand-right','hand-center','hand-hidden','hand-l2','hand-l3','hand-r2','hand-r3','hand-slot');
    c.classList.add('in-hand');

    if(i===handIndex){
      c.classList.add('hand-center','hand-slot');
      attachCenterHandDrag(c); // only center has swipe/lift
    }else if(i===l1){ c.classList.add('hand-left','hand-small','hand-slot'); }
    else if(i===r1){ c.classList.add('hand-right','hand-small','hand-slot'); }
    else if(i===l2){ c.classList.add('hand-l2','hand-small','hand-slot'); }
    else if(i===l3){ c.classList.add('hand-l3','hand-small','hand-slot'); }
    else if(i===r2){ c.classList.add('hand-r2','hand-small','hand-slot'); }
    else if(i===r3){ c.classList.add('hand-r3','hand-small','hand-slot'); }
    else { c.classList.add('hand-hidden'); }

    sizeHandCardForRole(c);
  });

  syncCenterTooltip();
}

function rotateHand(dir){
  const n = handCards().length; if(n<=1) return;
  handIndex = (handIndex + dir + n) % n;
  layoutHand();

  // NEW: when rotating, unselect any table selection and
  // select the current center hand card so its tooltip appears.
  const center = handCards()[handIndex];
  if(center){ setSelectionFromCard(center); }
  else { clearSelection(); }
}

/* Center-card swipe/lift (bind to .cardBody for reliable hits) */
function attachCenterHandDrag(card){
  if(card._handBound) return;

  const body = card.querySelector('.cardBody');
  let start=null, lifted=false;

  function down(e){
    if(card.parentElement!==handZone) return;
    e.preventDefault();
    start={x:e.clientX,y:e.clientY};
    lifted=false;
    body.setPointerCapture(e.pointerId);
  }
  function move(e){
    if(!start) return;
    if(card.parentElement!==handZone){ start=null; return; }

    const dx=e.clientX-start.x, dy=e.clientY-start.y;

    // Horizontal swipe ‚Üí rotate carousel
    if(!lifted && Math.abs(dx)>40 && Math.abs(dx)>Math.abs(dy)){
      // Clear any table selection immediately, then rotate (which selects center)
      clearSelection();
      rotateHand(dx<0 ? +1 : -1);
      start={x:e.clientX,y:e.clientY};
      return;
    }

    // Up swipe ‚Üí lift into world
    if(!lifted && dy<-30 && Math.abs(dy)>Math.abs(dx)){
      removeFromHand(card);
world.appendChild(card);

// Select card + everything below it in any stack (currently just itself)
setSelectionFromCard(card);

// re-run lords/anthems when a new permanent hits the table
recomputeContinuousEffects();


      // Place under finger (world coords)
      const r=table.getBoundingClientRect();
      const worldX=(e.clientX - r.left - state.tx)/state.scale;
      const worldY=(e.clientY - r.top  - state.ty)/state.scale;
      const defW=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))||223;
      const defH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))||310;
const LIFT_Y_OFFSET = 1000;
card.style.left = (worldX - defW/2) + 'px';
card.style.top  = (worldY - LIFT_Y_OFFSET - defH/2) + 'px';
      card.style.zIndex=++zCounter;

      lifted=true;
      layoutHand(); // also refreshes tooltip to new center
    }
  }
  function up(){ start=null; }

  card.addEventListener('pointerdown',down);
  card.addEventListener('pointermove',move);
  card.addEventListener('pointerup',up);
  card.addEventListener('pointercancel',up);
  card._handBound=true;
}



/* =========================================================
   Topbar (load/shuffle/draw)
   ========================================================= */
$('#loadBtn').addEventListener('click', ()=>{
  const names=parseDeck($('#deckIn').value);
  if(!names.length){ alert('No cards parsed. Paste your deck and tap Load again.'); return;}
  drawPile=names.reverse();
  $('#deckCount').textContent=drawPile.length;

  collapseDrawer();          // <-- hide the input
  // no alert anymore
});

$('#shuffleBtn').addEventListener('click', ()=>{
  for(let i=drawPile.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=drawPile[i]; drawPile[i]=drawPile[j]; drawPile[j]=t; }
  alert('Shuffled.');
});
function drawToHand(n){
  if(!drawPile.length) return;
  for(let i=0;i<n;i++){
    const name=drawPile.pop(); if(!name) break;
    $('#deckCount').textContent=drawPile.length;
    const c=spawnCard(name,0,0);
    moveToHand(c);
	    // persist after draw
    if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);

  }
}
$('#draw7').addEventListener('click', ()=>drawToHand(7));
$('#draw1').addEventListener('click', ()=>drawToHand(1));

/* =========================================================
   Tap / Flip  (T acts on base..selected slice)
   ========================================================= */

// Toggle tap state for a single card
function toggleTapOne(card){
  const t = card.querySelector('.card3d');
  const tapped = (t.style.transform || '').includes('rotate(90deg)');
  t.style.transform = tapped ? 'rotate(0deg)' : 'rotate(90deg)';
}

// Flip still acts on just the selected card
function toggleFlip(card){ card.classList.toggle('flipped'); }

// T: tap/untap the slice from stack base up through the selected card
$('#tapBtn').addEventListener('click', ()=>{
  if(!selectedCard) return;
  const group = stackSliceFrom(selectedCard);
  group.forEach(toggleTapOne);
});

// F: flip the selected card only (unchanged behavior)
$('#flipBtn').addEventListener('click', ()=>{
  if(selectedCard) toggleFlip(selectedCard);
});



/* =========================================================
   Chat + Stack UI + Compass (home) + Player + View
   ========================================================= */

/* ---------- minimal helpers so this block is drop-in ---------- */
function clearHand(){
  handCards().forEach(c => c.remove());
  handZone.querySelector('.label').textContent = 'Hand';
}
function spawnCardToHandFromSaved(c){
  const card = document.createElement('div');
  card.dataset.cid = c.id ? String(c.id) : (card.dataset.cid || String(Math.random()).slice(2));
  card.id = `card-${card.dataset.cid}`;

  card.className = 'card in-hand';
  card.setAttribute('data-name', c.name || '');
  card.style.zIndex = ++zCounter;

  const body = document.createElement('div'); body.className = 'cardBody';
  const c3 = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img'); imgF.alt = c.name || ''; imgF.draggable = false; imgF.src = c.img || '';
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img'); imgB.alt = 'Card back'; imgB.src = CARD_BACK; imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2); c3.appendChild(inner); body.appendChild(c3); card.appendChild(body);
  makeDraggable(card);  
  handZone.appendChild(card);
  return card;
}
function renderFullState(data){
  drawPile = (data?.Deck || []).map(d => d.name).reverse();
  $('#deckCount').textContent = drawPile.length;

  renderSavedStateToWorld(data);   // battlefield + zones
  clearHand();
  (data?.Hand || []).forEach(spawnCardToHandFromSaved);
  layoutHand();

  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';
  goHome();
}


function captureLocalSnapshot(){
  return {
    Deck: drawPile.slice().reverse().map(name => ({name})),
    Hand: handCards().map(serializeCard),
    Table: Array.from(world.querySelectorAll('.card')).filter(c => c.parentElement===world).map(serializeCard),
    Graveyard: Array.from(document.querySelectorAll('.graveyard .card')).map(serializeCard),
    Exile: Array.from(document.querySelectorAll('.exile .card')).map(serializeCard),
    Commander: Array.from(document.querySelectorAll('.commander .card')).map(serializeCard)
  };
}
async function enterViewer(playerId){
  if (!viewerMode) localSnapshot = captureLocalSnapshot();
  viewerMode = true;
  viewerPlayer = String(playerId);
  document.body.classList.add('viewer');
  handZone.style.display = 'none';

  const data = await loadPlayerState(playerId);
  if (!data){ alert('No saved data for player '+playerId); exitViewer(); return; }
  renderSavedStateToWorld(data); // no hand
  goHome();
}
function exitViewer(){
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';
  if (localSnapshot) renderFullState(localSnapshot); else { clearBoard(); clearHand(); drawPile=[]; $('#deckCount').textContent='0'; goHome(); }
}

// === helper: resume current player's saved state ===
async function resumeOrInitForPlayer(playerId){
  // leave viewer mode if active
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';

  const data = await loadPlayerState(String(playerId));
  if (data && ((data.Table?.length||0) + (data.Hand?.length||0) + (data.Deck?.length||0) > 0)) {
    renderFullState(data);   // rebuild Deck/Hand/Table + zones
  } else {
    // Fresh state: clear world + hand + deck count
    world.querySelectorAll('.card').forEach(el => el.remove());
    handCards().forEach(el => el.remove());
    drawPile = [];
    document.getElementById('deckCount').textContent = '0';
    layoutHand();
    goHome();
  }
}

// Boot: after Firebase is ready, resume the default currentPlayer
firebaseReady.then(()=> resumeOrInitForPlayer(currentPlayer));


/* ========== Player / Viewer button wiring ========== */
// (keep your existing consts that query the DOM for player/view controls)
const playerWrapper = document.getElementById('playerWrapper');
const playerBtn = document.getElementById('playerBtn');
const playerActions = document.getElementById('playerActions');
const playerActionButtons = Array.from(playerActions.querySelectorAll('.pbtn'));

const viewWrapper = document.getElementById('viewWrapper');
const viewBtn = document.getElementById('viewBtn');
const viewActions = document.getElementById('viewActions');
const viewActionButtons = Array.from(viewActions.querySelectorAll('.pbtn'));

// Toggle open/close for the pickers
playerBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  playerWrapper.classList.toggle('open');
});

viewBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  // If already in viewer mode, clicking the eye exits viewer‚Äîno auto-swap
  if (viewerMode){ exitViewer(); return; }
  viewWrapper.classList.toggle('open');
});

// Select player as "me" (load their saved state immediately)
playerActionButtons.forEach(b=>{
  b.addEventListener('click', async ()=>{
    const p = Number(b.getAttribute('data-player'));
    if (String(currentPlayer) === String(p)) {
      playerWrapper.classList.remove('open');
      return;
    }

    // If we were viewing someone else, exit viewer so zone overlays use me
    if (window.viewerMode) exitViewer();

    // highlight UI
    playerActionButtons.forEach(x=>x.classList.remove('on'));
    b.classList.add('on');

    currentPlayer = p;
window.currentPlayer = currentPlayer;
console.log('[player select] set currentPlayer =', currentPlayer);

// resume that player's saved state (deck/hand/table)
await resumeOrInitForPlayer(currentPlayer);


    playerWrapper.classList.remove('open');
  });
});


// Eye ‚Üí view another player's field (no hands, no auto swap back)
viewActionButtons.forEach(b=>{
  b.addEventListener('click', async ()=>{
    const p = b.getAttribute('data-player');
    viewActionButtons.forEach(x=>x.classList.remove('on'));
    b.classList.add('on');
    viewWrapper.classList.remove('open');
    await enterViewer(p);
  });
});


/* ========== Simple overlay viewer (shows saved zones for a player) ========== */
function showPlayerOverlay(data, playerId){
  const existing = document.getElementById('playerOverlay');
  if(existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'playerOverlay';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(2,6,10,0.85)';
  overlay.style.color = 'white';
  overlay.style.zIndex = 9999;
  overlay.style.padding = '22px';
  overlay.style.overflow = 'auto';
  overlay.style.fontFamily = 'system-ui, sans-serif';

  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.style.position = 'fixed';
  closeBtn.style.right = '18px';
  closeBtn.style.top = '18px';
  closeBtn.style.zIndex = 10001;
  closeBtn.className = 'pill';
  closeBtn.addEventListener('click', ()=>overlay.remove());
  overlay.appendChild(closeBtn);

  const title = document.createElement('h2');
  title.textContent = `Player ${playerId} ‚Äî Saved View`;
  overlay.appendChild(title);

  const deckCount = (data.Deck && data.Deck.length) || 0;
  const pDeck = document.createElement('div');
  pDeck.textContent = `Deck (${deckCount})`;
  pDeck.style.marginBottom = '8px';
  overlay.appendChild(pDeck);

  function appendZone(name, arr){
    const zoneWrap = document.createElement('div');
    zoneWrap.style.margin = '10px 0 20px 0';
    const h = document.createElement('h3');
    h.textContent = name + ` (${(arr && arr.length)||0})`;
    zoneWrap.appendChild(h);

    const grid = document.createElement('div');
    grid.style.display = 'flex';
    grid.style.flexWrap = 'wrap';
    grid.style.gap = '10px';
    grid.style.marginTop = '8px';

    (arr || []).forEach(card=>{
      const cardEl = document.createElement('div');
      cardEl.style.width = '120px';
      cardEl.style.border = '1px solid rgba(255,255,255,0.08)';
      cardEl.style.borderRadius = '8px';
      cardEl.style.padding = '6px';
      cardEl.style.background = 'rgba(255,255,255,0.02)';
      cardEl.style.fontSize = '12px';
      cardEl.style.boxSizing = 'border-box';

      const img = document.createElement('img');
      img.src = card.img || '';
      img.alt = card.name || '';
      img.style.width = '100%';
      img.style.height = '80px';
      img.style.objectFit = 'cover';
      img.style.borderRadius = '6px';
      img.loading = 'lazy';
      cardEl.appendChild(img);

      const nm = document.createElement('div');
      nm.textContent = card.name || '(unknown)';
      nm.style.marginTop = '6px';
      nm.style.whiteSpace = 'nowrap';
      nm.style.overflow = 'hidden';
      nm.style.textOverflow = 'ellipsis';
      cardEl.appendChild(nm);

      if(typeof card.x !== 'undefined' || typeof card.y !== 'undefined'){
        const meta = document.createElement('div');
        meta.textContent = `x:${Math.round(card.x||0)} y:${Math.round(card.y||0)}`;
        meta.style.fontSize = '11px';
        meta.style.opacity = '0.8';
        meta.style.marginTop = '4px';
        cardEl.appendChild(meta);
      }

      grid.appendChild(cardEl);
    });

    zoneWrap.appendChild(grid);
    overlay.appendChild(zoneWrap);
  }

  appendZone('Table', data.Table);
  appendZone('Hand', data.Hand);
  appendZone('Graveyard', data.Graveyard);
  appendZone('Exile', data.Exile);
  appendZone('Commander', data.Commander);

  document.body.appendChild(overlay);
}

/* Close overlays when pressing Escape */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){
    const el = document.getElementById('playerOverlay');
    if(el) el.remove();
    playerWrapper.classList.remove('open');
    viewWrapper.classList.remove('open');
  }
});

/* # and + buttons (placeholder) and END */
/* ===== Amount of players, Adding Tokens, and Ending Turns ===== */
// Toggle the # popout
document.getElementById('numBtn').addEventListener('click', ()=>{
  document.getElementById('numWrapper').classList.toggle('open');
});

// Pick 1/2/3 players, close, and reset turn to Player 1 (SERVER SOURCE OF TRUTH)
document.querySelectorAll('#numActions .pbtn').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const n = parseInt(btn.dataset.n, 10);
    NUM_PLAYERS = Math.max(1, Math.min(3, n));
    turnPlayer  = 1; // keep local in sync after we write

    document.getElementById('numWrapper').classList.remove('open');
    showToast(`Players: ${NUM_PLAYERS} ‚Ä¢ Turn: P${turnPlayer}`);

    // >>> write to Firestore so both phones agree
    try{
      await writeTurnToServer(turnPlayer, NUM_PLAYERS);
    }catch(e){ console.warn('[turn] write failed:', e); }
  });
});


// Sword Combat stub
// Sword button (Battle picker): read server turn first, THEN choose
document.getElementById('plusBtn')?.addEventListener('click', async ()=>{
  try{
    const data = await readCombatFresh(); // force server
    const serverTurn = Number(data.turnPlayer || turnPlayer);
    const serverN    = Number(data.numPlayers || NUM_PLAYERS);

    // keep locals in sync (no local-only truth)
    turnPlayer  = serverTurn;
    NUM_PLAYERS = serverN;

    console.log('[battle] server turn:', serverTurn, 'me:', Number(currentPlayer));
    if (serverTurn === Number(currentPlayer)){
      openAttackOverlay();
    } else {
      openDefenseOverlay();
    }
  }catch(e){
    console.warn('[battle] failed to read server turn, using local', e);
    if (Number(turnPlayer) === Number(currentPlayer)) openAttackOverlay();
    else openDefenseOverlay();
  }
});


// COMBAT HELPERS -----------
// --- Identity (use your data-cid consistently)
function ensureCid(card){
  if(!card.dataset.cid) card.dataset.cid = String(Math.random()).slice(2);
  return card.dataset.cid;
}
function cardFrontUrl(card){
  const img = card.querySelector('.face.front img');
  if (img && img.src) return img.src;
  return ''; // (hydration may fill later; we still store empty safely)
}
function cardName(card){
  return card.getAttribute('data-name') || card._data?.name || '(Unnamed)';
}

// --- Compute current P/T exactly like your badge math (base + attachments + manual extras)
function computeCurrentPT(base){
  const [bp, bt] = basePT(base);
  if (bp==null || bt==null) return ['--','--'];
  let sumP = 0, sumT = 0;
  if (base._stack && base._stack.length > 1){
    for (let i=1;i<base._stack.length;i++){
      const att = base._stack[i];
      const {dp, dt} = extractPTDeltaFromText(oracleText(att));
      sumP += dp; sumT += dt;
    }
  }
  // include manual dp/dt edits saved via the editor
  sumP += Number(base._extras?.dp || 0);
  sumT += Number(base._extras?.dt || 0);
  return [bp + sumP, bt + sumT];
}

// --- Ownership (your cards vs others). If no owner marker, we treat all as yours.
function isOwnedByMe(card){
  const owner = (getStackBase(card)||card).getAttribute('data-owner');
  return !owner || String(owner) === String(currentPlayer);
}
function myCreatureBases(){
  // Only battlefield cards: direct children of #world (not inside zones)
  const all = Array.from(document.querySelectorAll('#world > .card'));
  const seen = new Set();
  const out = [];
  for (const c of all){
    if (c.parentElement !== document.getElementById('world')) continue;
    const base = getStackBase(c) || c;
    if (!isCreatureCard(base)) continue;
    if (!isOwnedByMe(base)) continue;
    const id = ensureCid(base);
    if (seen.has(id)) continue;
    seen.add(id);
    out.push(base);
  }
  return out;
}


function combatDoc(){
  // games/{GAME_ID}/combat/current
  return db.collection('games').doc(GAME_ID).collection('combat').doc('current');
}

async function readCombatFresh(){
  await firebaseReady;
  if(!db) return {};
  // Force server so both phones see each other immediately
  const snap = await combatDoc().get({ source: 'server' });
  return snap.exists ? (snap.data() || {}) : {};
}

// NEW: expose to global so the poller can see them
window.combatDoc = combatDoc;
window.readCombatFresh = readCombatFresh;


async function readCombat(){
  await firebaseReady;
  if(!db) return {};
  // Force server so both phones see each other immediately
  const snap = await combatDoc().get({ source: 'server' });
  return snap.exists ? (snap.data() || {}) : {};
}



async function writeTurnToServer(nextTurn, nextNumPlayers){
  await firebaseReady; if(!db) return;
  await combatDoc().set({
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    turnPlayer: Number(nextTurn),
    numPlayers: Number(nextNumPlayers)
  }, { merge: true });
  console.log('[turn] wrote to server:', { turnPlayer: Number(nextTurn), numPlayers: Number(nextNumPlayers) });
}



async function saveAttacksForCurrentPlayer(attackMap){
  // attackMap: { attackerCid -> targetPlayer or null }
  await firebaseReady; if(!db) return;
  const list = [];
  for (const [cid, target] of Object.entries(attackMap)){
    const el = document.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`);
if(!el) continue;
const base = getStackBase(el) || el;
const pt   = computeCurrentPTFromBase(base);
list.push({
  attackerId: cid,
  name: cardName(el),
  url: cardFrontUrl(el),
  power: pt.power,
  toughness: pt.toughness,
  targetPlayer: target == null ? null : Number(target),
  seat: Number(currentPlayer)
});

  }
  const ref = combatDoc();
await ref.set({
  updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  turnPlayer: Number(turnPlayer),
  numPlayers: Number(NUM_PLAYERS),
  attacksByPlayer: {
    [String(currentPlayer)]: list
  }
}, { merge: true });

}

async function saveBlocksForDefender(defenderSeat, orderedMap){
  // orderedMap: { [attackerId]: [blockerCid, ...] }  (order = damage order)
  await firebaseReady; if(!db) return;
  const ref = combatDoc();
await ref.set({
  updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  turnPlayer: Number(turnPlayer),
  numPlayers: Number(NUM_PLAYERS),
  blocksByDefender: {
    [String(defenderSeat)]: orderedMap
  }
}, { merge: true });

}

async function clearCombatForNewTurn(){
  await firebaseReady; if(!db) return;
  await combatDoc().set({
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    turnPlayer: Number(turnPlayer),
    numPlayers: Number(NUM_PLAYERS),
    attacksByPlayer: {},
    blocksByDefender: {}
  }, { merge: false }); // replace entirely
}

function openAttackOverlay(){
  // preload existing choices (if you re-open)
  let currentChoices = {}; // { attackerCid: targetPlayer or null }
  readCombat().then(data=>{
    const mine = data?.attacksByPlayer?.[String(currentPlayer)] || [];
    for (const row of mine){
      currentChoices[row.attackerId] = row.targetPlayer;
    }
    render(currentChoices);
  });

  function render(choices){
    const bases = myCreatureBases();
    const oppSeats = Array.from({length:NUM_PLAYERS}, (_,i)=>i+1).filter(p => p !== Number(currentPlayer));

    const ov = document.createElement('div');
    ov.className = 'overlay battle-overlay';
    ov.style.cssText = `
      position:fixed; inset:0; background:rgba(5,7,12,.86); z-index:11000;
      display:flex; flex-direction:column; padding:14px; gap:10px;
    `;
    ov.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h2 style="margin:0;font:600 18px/1 ui-sans-serif,system-ui">Attacking ‚Äî Player ${currentPlayer}</h2>
        <button id="atkClose" class="btn" style="padding:6px 10px;border-radius:10px;background:#1b2a47;color:#d8e7ff">‚úï</button>
      </div>
      <div id="atkScroll" style="flex:1; overflow:auto; padding-right:6px;"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end">
        <button id="atkReset" class="btn" style="border-radius:10px;background:#1b2a47;color:#d8e7ff">Reset</button>
        <button id="atkConfirm" class="btn" style="border-radius:10px;background:#6aa9ff;color:#091323;font-weight:800">Confirm Attacks</button>
      </div>
    `;
    document.body.appendChild(ov);

    const list = ov.querySelector('#atkScroll');
    list.innerHTML = '';

    bases.forEach(base=>{
      const cid = ensureCid(base);
      const [p,t] = computeCurrentPT(base);
      const atts = (base._stack||[]).slice(1).map(a => cardName(a));
      const row = document.createElement('div');
      row.className = 'atk-row';
      row.dataset.cid = cid;
      row.style.cssText = `border:1px solid #2b3344;border-radius:10px;background:#141823;padding:10px;margin-bottom:10px;`;

      const oppButtons = oppSeats.map(seat=>{
        const on = choices[cid] === seat ? 'outline:2px solid #6aa9ff;box-shadow:0 0 0 6px rgba(106,169,255,.18) inset;' : '';
        return `<button class="pbtn choose" data-target="${seat}" style="${on}">${seat}</button>`;
      }).join('');

      const noneOn = (choices[cid] == null) ? 'outline:2px solid #6aa9ff;box-shadow:0 0 0 6px rgba(106,169,255,.18) inset;' : '';
      row.innerHTML = `
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
          <img src="${cardFrontUrl(base)}" alt="" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>
          <div style="flex:1;min-width:180px">
            <div style="font-weight:700">${escapeHTML(cardName(base))}</div>
            <div style="opacity:.8">P/T: ${p}/${t}</div>
            ${atts.length ? `<div style="opacity:.75;font-size:12px;margin-top:2px">Attachments: ${escapeHTML(atts.join(', '))}</div>`:''}
          </div>
          <div style="display:flex;gap:6px;flex-wrap:wrap">
            <button class="pbtn choose" data-target="" style="${noneOn}">‚Äî</button>
            ${oppButtons}
          </div>
        </div>
      `;
      row.addEventListener('click', (e)=>{
        const btn = e.target.closest('.choose');
        if(!btn) return;
        const target = btn.dataset.target === '' ? null : Number(btn.dataset.target);
        choices[cid] = target;
        // refresh selection styles quickly
        row.querySelectorAll('.choose').forEach(b=> b.style.outline='');
        row.querySelectorAll('.choose').forEach(b=> b.style.boxShadow='');
        btn.style.outline='2px solid #6aa9ff';
        btn.style.boxShadow='0 0 0 6px rgba(106,169,255,.18) inset';
      });
      list.appendChild(row);
    });

    ov.querySelector('#atkClose').onclick = ()=> ov.remove();
    ov.querySelector('#atkReset').onclick = ()=>{
      if(!confirm('Clear all your attack choices?')) return;
      choices = {};
      list.querySelectorAll('.atk-row').forEach(r=>{
        r.querySelectorAll('.choose').forEach(b=> {
          b.style.outline=''; b.style.boxShadow='';
          if (b.dataset.target===''){ b.style.outline='2px solid #6aa9ff'; b.style.boxShadow='0 0 0 6px rgba(106,169,255,.18) inset'; }
        });
      });
      showToast('Attacks reset');
    };
    ov.querySelector('#atkConfirm').onclick = async ()=>{
      await saveAttacksForCurrentPlayer(choices);
      showToast('Attacks set');
      ov.remove();
    };
  }
}


async function openDefenseOverlay(){
  try{
    // Force server so both phones agree immediately
    const data = await readCombatFresh();

    // Start with the normal nested map‚Ä¶
    let byPlayer = data?.attacksByPlayer || {};

    // Back-compat: if older writes created top-level fields like "attacksByPlayer.1",
    // fold those into a proper map so reads work.
    if (!Object.keys(byPlayer).length) {
      for (const [k, v] of Object.entries(data)) {
        if (k.startsWith('attacksByPlayer.')) {
          const seat = k.split('.')[1];
          byPlayer[seat] = Array.isArray(v) ? v : [];
        }
      }
    }

    const mySeat = Number(currentPlayer);

    // Flatten all attackers from everyone, then keep only those aimed at me
    const all = Object.values(byPlayer).flat();
    console.log('[DEF overlay] byPlayer keys=', Object.keys(byPlayer),
                'turnPlayer=', Number(data.turnPlayer),
                'numPlayers=', Number(data.numPlayers),
                'mySeat=', mySeat,
                'all attackers count=', all.length);


    // Log each row before filtering, so you can see raw target vs mySeat
    all.forEach((row, i)=>{
      console.log(`[DEF row ${i}] attackerId=${row?.attackerId} seat=${row?.seat} name="${row?.name}" targetPlayer(raw)=`, row?.targetPlayer, '‚Üí Number=', Number(row?.targetPlayer));
    });

    const vsMe = all.filter(a => Number(a?.targetPlayer) === mySeat);
    console.log('[DEF overlay] vsMe count=', vsMe.length);

    // === Overlay shell + rows ===
    const ov = document.createElement('div');
    ov.className = 'overlay battle-overlay';
    ov.style.cssText = 'position:fixed;inset:0;background:rgba(5,7,12,0.86);z-index:11000;display:flex;flex-direction:column;padding:14px;gap:10px;';
    ov.innerHTML =
      '<div style="display:flex;justify-content:space-between;align-items:center">' +
        '<h2 style="margin:0;font:600 18px/1 ui-sans-serif,system-ui">Defending ‚Äî Player ' + mySeat + '</h2>' +
        '<button id="boClose" class="btn" style="padding:6px 10px;border-radius:10px;background:#1b2a47;color:#d8e7ff">‚úï</button>' +
      '</div>' +
      '<div id="boScroll" style="flex:1; overflow:auto; padding-right:6px;"></div>' +
      '<div style="display:flex; gap:8px; justify-content:flex-end">' +
        '<button id="boReset" class="btn" style="border-radius:10px;background:#1b2a47;color:#d8e7ff">Reset</button>' +
        '<button id="boConfirm" class="btn" style="border-radius:10px;background:#6aa9ff;color:#091323;font-weight:800">Confirm Blocks</button>' +
      '</div>';
    document.body.appendChild(ov);

    const rows = ov.querySelector('#boScroll');
	function openBlockerPicker(atk){
  const seatKey = String(mySeat);
  const seatMap = (data.blocksByDefender && data.blocksByDefender[seatKey]) || {};
  const used = new Set();
  for(const arr of Object.values(seatMap)){ (arr||[]).forEach(id=>used.add(String(id))); }

  // All my creature BASE cards that aren't already committed to block something else
  const basesAll = myCreatureBases();
  const bases = basesAll.filter(b => !used.has(ensureCid(b)));
  const chosen = []; // ordered list of blocker CIDs

  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;background:rgba(5,7,12,0.9);z-index:12000;display:flex;flex-direction:column;padding:14px;gap:10px;';
  overlay.innerHTML =
    '<div style="display:flex;justify-content:space-between;align-items:center">' +
      `<h2 style="margin:0;font:600 18px/1 ui-sans-serif,system-ui">Blocker Order ‚Äî vs ${atk.name}</h2>` +
      '<button id="blkClose" class="btn" style="padding:6px 10px;border-radius:10px;background:#1b2a47;color:#d8e7ff">‚úï</button>' +
    '</div>' +
    '<div id="blkAvail" style="flex:1;overflow:auto;padding-right:6px;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px"></div>' +
    '<div id="blkChosen" style="min-height:32px;opacity:.9"></div>' +
    '<div style="display:flex; gap:8px; justify-content:flex-end">' +
      '<button id="blkReset" class="btn" style="border-radius:10px;background:#1b2a47;color:#d8e7ff">Reset</button>' +
      '<button id="blkSave" class="btn" style="border-radius:10px;background:#6aa9ff;color:#091323;font-weight:800">Save</button>' +
    '</div>';
  document.body.appendChild(overlay);

  const avail = overlay.querySelector('#blkAvail');
  const chosenDiv = overlay.querySelector('#blkChosen');

  function renderChosen(){
    const names = chosen.map((id,i)=>{
      const el = document.querySelector(`.card[data-cid="${CSS.escape(id)}"]`);
      return `${i+1}. ${el ? (typeof cardName==='function'? cardName(el) : id) : id}`;
    });
    chosenDiv.innerHTML = '<div><strong>Order:</strong> ' + (names.length? names.join(' ‚Üí ') : '(none)') + '</div>';
  }

  for (const base of bases) {
  const id = ensureCid(base);
  const pt = computeCurrentPTFromBase(base);
  const item = document.createElement('button');
  item.className = 'blk-item';
  // force light text on dark button + add a small image and layout
  item.style.cssText = 'text-align:left;border:1px solid #2b3344;border-radius:10px;background:#141823;color:#e7e9ee;padding:10px;display:flex;gap:10px;align-items:center;';
  item.innerHTML =
    (cardFrontUrl(base) ? `<img src="${cardFrontUrl(base)}" alt="" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>` : '') +
    `<div style="flex:1;min-width:180px">
       <div style="font-weight:700">${cardName(base)} <span style="opacity:.7">${(pt.power!=null&&pt.toughness!=null)?'('+pt.power+'/'+pt.toughness+')':''}</span></div>
       <div style="opacity:.8">Tap to add to block order</div>
     </div>`;
  item.addEventListener('click', ()=>{
    if (chosen.includes(id)) return;
    chosen.push(id);
    item.style.opacity = '.55';
    item.style.pointerEvents = 'none';
    renderChosen();
  });
  avail.appendChild(item);
}

  renderChosen();

  overlay.querySelector('#blkReset').onclick = ()=>{
    chosen.length = 0;
    for(const btn of avail.querySelectorAll('.blk-item')){
      btn.style.opacity='1'; btn.style.pointerEvents='auto';
    }
    renderChosen();
  };
  overlay.querySelector('#blkClose').onclick = ()=> overlay.remove();
  overlay.querySelector('#blkSave').onclick = async ()=>{
  try{
    // Merge with what‚Äôs already saved for my seat
    const seatKey = String(mySeat);
    const currentSeatMap = (data.blocksByDefender && data.blocksByDefender[seatKey]) || {};
    const nextSeatMap = { ...currentSeatMap, [atk.attackerId]: chosen };

    await saveBlocksForDefender(mySeat, nextSeatMap);

    overlay.remove();
    ov.remove();
    openDefenseOverlay(); // refresh list; chosen blockers will be filtered out
  }catch(e){
    console.warn('saveBlocks failed', e);
    overlay.remove();
  }
};

}

    if (!vsMe.length){
      rows.innerHTML = '<div style="opacity:.8">No creatures are attacking you.</div>';
    } else {
      rows.innerHTML = '';
      for (const atk of vsMe){
        const row = document.createElement('div');
        row.className = 'atk-row';
        row.dataset.attackerId = atk.attackerId;
        row.style.cssText = 'border:1px solid #2b3344;border-radius:10px;background:#141823;padding:10px;margin-bottom:10px;';
        row.innerHTML =
  '<div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; cursor:pointer">' +
    (atk.url ? `<img src="${atk.url}" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>` : '') +
    `<div style="flex:1;min-width:200px">
       <div style="font-weight:700">${(typeof escapeHTML==='function'?escapeHTML(atk.name):atk.name)}
         <span style="opacity:.7">(P${atk.seat}${(atk.power!=null&&atk.toughness!=null)?' ‚Ä¢ '+atk.power+'/'+atk.toughness:''})</span></div>
       <div style="opacity:.8">Tap to assign blockers (order matters).</div>
     </div>` +
  '</div>';
row.addEventListener('click', ()=> openBlockerPicker(atk));

        rows.appendChild(row);
      }
    }

    // Extra summary logs (keep for debugging)
    console.log('[DEF overlay] byPlayer keys=', Object.keys(byPlayer));
    for (const [k, arr] of Object.entries(byPlayer)) {
      console.log(' [DEF overlay] seat', k, 'rows=', Array.isArray(arr)?arr.length:0,
                  'first.targetPlayer=', arr?.[0]?.targetPlayer);
    }

    ov.querySelector('#boClose').onclick = ()=> ov.remove();
    ov.querySelector('#boReset').onclick  = ()=> (typeof showToast==='function' && showToast('Blocks reset'));
    ov.querySelector('#boConfirm').onclick = ()=> 
  openOutcomeOverlay({ data, vsMe, mySeat: Number(currentPlayer), ov });



  } catch (err){
    console.error('[defense overlay]', err);
  }
}

function openOutcomeOverlay(ctx){
  // pull everything from the context so we don't rely on outer scope
  const data   = (ctx && ctx.data)   || {};
  const vsMe   = (ctx && ctx.vsMe)   || [];
  const mySeat = (ctx && ctx.mySeat != null) ? Number(ctx.mySeat) : Number(currentPlayer);
  const ov     = (ctx && ctx.ov)     || null;

  const seatKey = String(mySeat);
  const seatMap = (data.blocksByDefender && data.blocksByDefender[seatKey]) || {};

  // helper: current P/T + element + name for a blocker by cid
  function ptForCid(cid){
    const el0 = document.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`);
    const base = el0 ? (getStackBase(el0) || el0) : null;
    const pt = base ? computeCurrentPTFromBase(base) : { power: 0, toughness: 999 }; // 999 = ‚Äúdon‚Äôt claim kill if unknown‚Äù
    return {
      cid,
      el: base,
      name: base ? cardName(base) : cid,
      power: Number(pt.power)||0,
      toughness: Number(pt.toughness)||0
    };
  }

    // === Ability helpers (read from card._extras.addEffects + attachments text if you later wire it) ===
  function effectsFor(el){
    // store effects in lowercase keys; your card editor already writes addEffects Set
    const set = new Set();
    const ex  = el? (el._extras || {}) : {};
    (ex.addEffects || []).forEach(e => set.add(String(e||'').trim().toLowerCase()));
    return set;
  }
  const has = (set, key) => set.has(String(key).toLowerCase());

  // true if this permanent ignores destroy-from-damage
  const isIndestructible = (fx) => has(fx,'indestructible');

  // does this source have first strike / double strike?
  const hasFirstStrike   = (fx) => has(fx,'first strike') || has(fx,'first-strike');
  const hasDoubleStrike  = (fx) => has(fx,'double strike') || has(fx,'double-strike');

  // combat damage deathtouch check (any amount ‚â•1 is lethal to creatures that aren't indestructible)
  const hasDeathtouch    = (fx) => has(fx,'deathtouch');

  // trampling over assigned blockers
  const hasTrample       = (fx) => has(fx,'trample');

  // lifelink life gain tally (we only compute; applying life total is optional and UI-level)
  const hasLifelink      = (fx) => has(fx,'lifelink');

  // ultra-generic ‚Äúprotection‚Äù toggle (since color/quality isn‚Äôt modeled yet)
  // if either party has 'protection', treat incoming damage from the other as prevented.
  const hasProtection    = (fx) => has(fx,'protection');

  // compute lethal assignment needed for a blocker, considering deathtouch
  function lethalNeededAgainst(sourceFx, blocker){
    if (hasDeathtouch(sourceFx) && !isIndestructible(effectsFor(blocker.el))) return 1;
    return Math.max(0, Number(blocker.toughness||0));
  }

  // assign damage from A (the attacker) into an ordered list of blockers, supporting trample + deathtouch
  function assignDamageFromAttacker(AP, aFx, blockers){
    let remaining = Number(AP||0);
    const assigns = [];

    for (const b of blockers){
      const bFx    = effectsFor(b.el);
      // if blocker has generic protection, it takes 0 from attacker
      if (hasProtection(bFx)) {
        assigns.push({ blocker:b, dmgToBlocker:0, blockerDies:false });
        continue;
      }

      // minimum lethal needed into this blocker (1 if attacker has deathtouch, unless the blocker is indestructible)
      const lethal = lethalNeededAgainst(aFx, b);
      const dmg    = Math.min(remaining, lethal);

      remaining -= dmg;

      const dies = !isIndestructible(bFx) && (dmg >= lethal && lethal > 0);
      assigns.push({ blocker:b, dmgToBlocker:dmg, blockerDies:dies });

      // if attacker doesn't have trample, it must assign all damage to blockers; but your UI already orders all blockers.
      // We'll keep walking; ‚Äúremaining‚Äù goes to next blocker; only with trample will anything spill to player after all blockers.
    }

    const trampleToPlayer = hasTrample(aFx) ? Math.max(0, remaining) : 0;
    return { assigns, trampleToPlayer };
  }

  // resolve one ‚Äúdamage step‚Äù (first strike or regular) and return casualties + life swing
  function resolveDamageStep(attacker, aFx, blockers, stepKind /* 'first' | 'regular' */){
    // Step rules:
    // - First strike step: only creatures with first strike (or double strike) assign/receive. Others don‚Äôt deal damage in this step.
    // - Regular step: creatures without first strike deal (plus double strike creatures deal again if still alive).
    const stepNeedsFS = (stepKind === 'first');

    // Who is active on this step?
    const atkActive = stepNeedsFS ? (hasFirstStrike(aFx) || hasDoubleStrike(aFx)) : (!hasFirstStrike(aFx) || hasDoubleStrike(aFx));
    const liveBlockers = blockers.filter(b => !b._dead); // carry-over flag between steps if you call twice

    let attackerDeals = 0, attackerLifelinkGain = 0, playerDamage = 0;
    const deadBlockers = new Set();

    // 1) Attacker assigns to blockers (if active)
    if (atkActive && liveBlockers.length){
      const { assigns, trampleToPlayer } = assignDamageFromAttacker(attacker.power, aFx, liveBlockers);
      playerDamage += trampleToPlayer;

      for (const a of assigns){
        attackerDeals += a.dmgToBlocker;
        if (a.blockerDies) deadBlockers.add(a.blocker.cid);
      }
      if (hasLifelink(aFx) && attackerDeals > 0) attackerLifelinkGain += attackerDeals;
    } else if (atkActive && !liveBlockers.length){
      // unblocked ‚Üí all damage to player
      playerDamage += Number(attacker.power||0);
      if (hasLifelink(aFx) && attacker.power>0) attackerLifelinkGain += Number(attacker.power||0);
    }

    // 2) Blockers hit attacker in this step if THEY are active this step
    let dmgToAttacker = 0;
    if (liveBlockers.length){
      for (const b of liveBlockers){
        const bFx  = effectsFor(b.el);
        const bFS  = hasFirstStrike(bFx) || hasDoubleStrike(bFx);
        const bActsNow = stepNeedsFS ? bFS : (!bFS || hasDoubleStrike(bFx));

        if (!bActsNow) continue;
        if (hasProtection(aFx)) continue; // attacker has generic protection ‚Üí prevent damage from blockers

        let dealt = Number(b.power||0);
        // deathtouch from blocker matters only for lethality check; that‚Äôs applied later when we mark deaths.
        dmgToAttacker += dealt;
      }
    }

    return { dmgToAttacker, deadBlockers, playerDamage, attackerLifelinkGain };
  }

  // Mark deaths after a step, considering indestructible & deathtouch that connected during this step.
  function computeCasualtiesAfterStep(attacker, aFx, blockers, stepResult){
    const { dmgToAttacker, deadBlockers } = stepResult;

    // Attacker death check:
    // - If any blocker with deathtouch dealt ‚â•1 to attacker this step and the attacker is not indestructible ‚Üí dies.
    // - Else normal toughness check.
    let attackerDies = false;
    if (!isIndestructible(aFx)){
      // Did any active blocker with deathtouch connect for ‚â•1 this step?
      let touched = false;
      for (const b of blockers){
        if (deadBlockers.has(b.cid)) { /* it still dealt damage in this step */ }
        // We can‚Äôt reconstruct per-blocker damage precisely without per-blocker tallies;
        // a simple robust rule: if b was alive for this step AND had deathtouch AND (b acted in this step) AND attacker took damage > 0 ‚Üí lethal.
        // We already know total damage to attacker; check whether any b had deathtouch and would act this step (mirrors resolveDamageStep).
        const bFx = effectsFor(b.el);
        if (hasDeathtouch(bFx)) touched = true;
      }
      if (touched && dmgToAttacker > 0) attackerDies = true;
      else attackerDies = (Number(attacker.toughness||0) <= Number(dmgToAttacker||0));
    }

    // Blocker deaths are already computed via deadBlockers (lethal assignment / deathtouch handling)
    return { attackerDies, deadBlockers };
  }

  // === Build recommended outcomes (with combat abilities) ===
  const outcomes = vsMe.map(atk=>{
    // Build blockers with reliable P/T: prefer saved row, fall back to live DOM
const blockerCids = (seatMap[atk.attackerId] || []);
const blockers = blockerCids.map(cid => {
  const el = document.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`);
  let name = '';
  let liveP = 0, liveT = 0;
  if (el) {
    try {
      name = (typeof cardName === 'function') ? cardName(el) : (el.getAttribute('data-name') || '');
      const base = (typeof getStackBase === 'function') ? (getStackBase(el) || el) : el;
      const cur  = (typeof computeCurrentPTFromBase === 'function') ? (computeCurrentPTFromBase(base) || null) : null;
      if (cur && Number.isFinite(cur.p) && Number.isFinite(cur.t)) {
        liveP = Number(cur.p) || 0;
        liveT = Number(cur.t) || 0;
      }
    } catch (e) {
      console.warn('[combat] live PT read failed for blocker', e);
    }
  }

  // Saved row (if any)
  const row = (typeof ptForCid === 'function') ? (ptForCid(cid) || {}) : {};
  const power     = (row.power     != null) ? Number(row.power)     : liveP;
  const toughness = (row.toughness != null) ? Number(row.toughness) : liveT;

  return { cid, el, name, power, toughness };
});
console.log('[combat] blockers live PT',
  blockers.map(b => ({ cid: b.cid, name: b.name, p: b.power, t: b.toughness }))
);


    // Attacker DOM + name
    const attEl   = document.querySelector(`.card[data-cid="${CSS.escape(atk.attackerId)}"]`);
    const attName = attEl ? cardName(attEl) : (atk.name || 'Attacker');

    // Attacker P/T ‚Äî prefer saved row, but FALL BACK to live DOM P/T if row is missing
let livePT = { p: 0, t: 0 };
if (attEl) {
  try {
    const base = getStackBase(attEl) || attEl;
    const cur  = (typeof computeCurrentPTFromBase === 'function')
      ? (computeCurrentPTFromBase(base) || null)
      : null;
    if (cur && Number.isFinite(cur.p) && Number.isFinite(cur.t)) {
      livePT = { p: Number(cur.p)||0, t: Number(cur.t)||0 };
    }
  } catch (e) {
    console.warn('[combat] live PT read failed for attacker', e);
  }
}

const attacker = {
  power: (atk.power     != null ? Number(atk.power)     : livePT.p) || 0,
  toughness: (atk.toughness != null ? Number(atk.toughness) : livePT.t) || 0
};

console.log('[combat] attacker PT source',
  {
    attackerId: atk.attackerId,
    seat: atk.seat,
    savedPower: atk.power, savedToughness: atk.toughness,
    livePower: livePT.p, liveToughness: livePT.t,
    used: { power: attacker.power, toughness: attacker.toughness }
  }
);

const aFx = effectsFor(attEl);


    // If there are no blockers, simplest case: all damage to player (with lifelink)
    if (!blockers.length){
      const playerDamage = attacker.power;
      const lifegain = hasLifelink(aFx) ? attacker.power : 0;
      return {
        atk, attEl, attName,
        assigns: [],                      // no per-blocker assigns
        attackerDies: false,
        playerDamage,
        lifegainAttacker: lifegain,
        notes: ['unblocked']
      };
    }

    // PHASE 1: First-strike step (only first/double strikers act)
    const firstRes  = resolveDamageStep(attacker, aFx, blockers, 'first');
    const firstCas  = computeCasualtiesAfterStep(attacker, aFx, blockers, firstRes);

    // Remove dead blockers before regular step
    const remainingBlockers = blockers.map(b => ({...b, _dead: firstCas.deadBlockers.has(b.cid)}))
                                      .filter(b => !b._dead);

    // If attacker died in first-strike step, regular step is skipped for it
    if (firstCas.attackerDies){
      return {
        atk, attEl, attName,
        assigns: [],   // we don‚Äôt show per-blocker assigns in first strike UI; you can expand if desired
        attackerDies: true,
        playerDamage: firstRes.playerDamage || 0,
        lifegainAttacker: firstRes.attackerLifelinkGain || 0,
        notes: ['first-strike: attacker died', ...Array.from(firstCas.deadBlockers).map(x=>'blocker died')]
      };
    }

    // PHASE 2: Regular damage step
    const regRes = resolveDamageStep(attacker, aFx, remainingBlockers, 'regular');
    const regCas = computeCasualtiesAfterStep(attacker, aFx, remainingBlockers, regRes);

    const attackerDies = regCas.attackerDies;
    const totalPlayerDmg = (firstRes.playerDamage||0) + (regRes.playerDamage||0);
    const totalLifeGain  = (firstRes.attackerLifelinkGain||0) + (regRes.attackerLifelinkGain||0);

    // For UI parity with your original, construct a compact ‚Äúassigns‚Äù list from the *regular* step‚Äôs attacker output.
    // (If you want, you can also surface a first-step ‚Äúassigns1‚Äù separately.)
    // We‚Äôll recompute the attacker‚Üíblocker distribution on the remaining blockers for display:
    const { assigns } = assignDamageFromAttacker(attacker.power, aFx, remainingBlockers);

    return {
      atk, attEl, attName,
      assigns,                    // who the attacker hit (regular step remaining)
      attackerDies,
      playerDamage: totalPlayerDmg,
      lifegainAttacker: totalLifeGain,
      notes: [
        firstRes.playerDamage ? `first-strike trample ${firstRes.playerDamage}` : '',
      ].filter(Boolean)
    };
  });


  // === Outcome overlay UI ===
  const ov2 = document.createElement('div');
  ov2.style.cssText = 'position:fixed;inset:0;background:rgba(5,7,12,0.9);z-index:12000;display:flex;flex-direction:column;padding:14px;gap:10px;';
  ov2.innerHTML =
    '<div style="display:flex;justify-content:space-between;align-items:center">' +
      `<h2 style="margin:0;font:600 18px/1 ui-sans-serif,system-ui">Combat Outcome ‚Äî Player ${mySeat}</h2>` +
      '<button id="outClose" class="btn" style="padding:6px 10px;border-radius:10px;background:#1b2a47;color:#d8e7ff">‚úï</button>' +
    '</div>' +
    '<div id="outScroll" style="flex:1;overflow:auto;padding-right:6px;"></div>' +
    '<div style="display:flex;gap:8px;justify-content:flex-end">' +
      '<button id="outApply" class="btn" style="border-radius:10px;background:#6aa9ff;color:#091323;font-weight:800">Apply</button>' +
    '</div>';
  document.body.appendChild(ov2);

  const list = ov2.querySelector('#outScroll');
  list.innerHTML = '';

  outcomes.forEach((o, idx)=>{
    const killedNames = o.assigns.filter(x=>x.blockerDies).map(x=> x.blocker.name);
    const lineText = (o.playerDamage > 0)
      ? `Unblocked ‚Äî recommend ${o.playerDamage} damage to Player ${mySeat}.`
      : `${o.attackerDies ? (o.atk.name || o.attName)+' dies' : (o.atk.name || o.attName)+' survives'}`
        + (killedNames.length ? `; your ${killedNames.join(', ')} die` : '');

    const row = document.createElement('label');
    row.style.cssText = 'display:block;border:1px solid #2b3344;border-radius:10px;background:#141823;padding:10px;margin-bottom:10px;';
    row.innerHTML =
      '<div style="display:flex;gap:10px;align-items:center">' +
        (o.atk.url ? `<img src="${o.atk.url}" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>` : '') +
        `<div style="flex:1">
           <div style="font-weight:700">${(typeof escapeHTML==='function'?escapeHTML(o.atk.name||o.attName):(o.atk.name||o.attName))}</div>
           <div style="opacity:.85">${lineText}</div>
         </div>` +
        `<input type="checkbox" class="outChk" data-i="${idx}" checked />` +
      '</div>';
    list.appendChild(row);
  });

  ov2.querySelector('#outClose').onclick = ()=> ov2.remove();

  // ===== Apply outcomes (defender) =====
ov2.querySelector('#outApply').onclick = async ()=>{
  try{
    const chks = Array.from(ov2.querySelectorAll('.outChk'));

    let totalDamageToMe = 0;

    // collect removals with ownership so we can route to correct graveyards
    const toRemoveAttackers = []; // { seat:number, el:HTMLElement, id?:string, name?:string }
    const toRemoveBlockers  = []; // { seat:number, el:HTMLElement }

    // helper to read a card name cleanly for logs
    const nameOf = (el)=> (el?.getAttribute?.('data-name')) || (el?._data?.name) || '';

    // Log each row and sum only the CHECKED ones
    chks.forEach(ch => {
      const idx = Number(ch.dataset.i);
      const o   = outcomes[idx];
      const checked = !!ch.checked;
      const dmg = Number(o?.playerDamage || 0);

      console.log(`[outcome][row ${idx}] checked=${checked} playerDamage=${dmg}`, {
        attacker: o?.atk?.name,
        attackerSeat: o?.atk?.seat,
        targetSeat: mySeat,
        assigns: (o?.assigns || []).map(a => ({
          blocker: a?.blocker?.name, blockerDies: a?.blockerDies
        }))
      });

      if (!checked) return;

      totalDamageToMe += dmg;

      // === attacker death queuing (ALWAYS use attackerSeat; DOM is optional) ===
      if (o?.attackerDies) {
        // seat: prefer row.atk.seat, then row.attackerSeat (fallback)
        const atkSeat = Number(o?.atk?.seat ?? o?.attackerSeat ?? 0);

        // id: prefer atk.attackerId, else atk.cid, else legacy attId
        const attackerId = String(o?.atk?.attackerId ?? o?.atk?.cid ?? o?.attId ?? '');

        // try to use the element we already had; otherwise reacquire by cid; if still none, proceed headless
        let aEl = o?.attEl || null;
        if (!aEl && attackerId) {
          aEl = document.querySelector(`.card[data-cid="${CSS.escape(attackerId)}"]`);
        }

        toRemoveAttackers.push({
          seat: atkSeat,
          el: aEl || null,
          id: attackerId,
          name: o?.atk?.name || o?.attacker || ''
        });

        console.log(aEl ? '[death][attacker] queued'
                        : '[death][attacker] queued (no DOM element; will write/remove by id)',
                    { seat: atkSeat, id: attackerId, name: (aEl?.getAttribute?.('data-name') || o?.atk?.name || '') });
      }

      // for each blocking assignment that dies, send to DEFENDER'S graveyard (mySeat)
      (o?.assigns || []).forEach(a => {
        if (a?.blockerDies && a?.blocker?.el) {
          toRemoveBlockers.push({ seat: Number(mySeat), el: a.blocker.el });
        }
      });
    });

    // ======= YOUR REQUESTED SUMMARY LINES (pre-writes) =======
    const atkNames = toRemoveAttackers.map(x => (nameOf(x.el) || x.name || '')).filter(Boolean);
    const blkNames = toRemoveBlockers.map(x => nameOf(x.el)).filter(Boolean);

    // attacker seat(s) ‚Äî prefer seats of attackers that died; fallback to seats from the checked rows
    const seatsFromDeaths  = toRemoveAttackers.map(x => Number(x.seat || 0)).filter(n => n > 0);

    // collect seats from checked rows directly (uses row.attackerSeat fallback)
    const seatsFromChecked = [];
    chks.forEach(ch => {
      const row = ch.closest('.row');
      if (!row) return;
      const obj = row._outcomeObj || row._o || null; // whichever you stored the outcome on
      if (!obj) return;
      if (ch.checked) seatsFromChecked.push(Number(obj?.atk?.seat ?? obj?.attackerSeat ?? 0));
    });

    const attackerSeats = Array.from(new Set((seatsFromDeaths.length ? seatsFromDeaths : seatsFromChecked).filter(n => n > 0)));
    const blockerSeat   = Number(mySeat || 0);

    // pretty strings
    const attackerSeatStr = attackerSeats.length ? attackerSeats.join(',') : '(unknown)';

    console.log(`Attackers Destroyed Creatures: ${atkNames.length ? atkNames.join(', ') : '(none)'}; Blockers Destroyed Creatures: ${blkNames.length ? blkNames.join(', ') : '(none)'};`);
    console.log(`Attacker Player:${attackerSeatStr}; Blocker Player:${blockerSeat}`);
    console.log(`THE EXACT FIREBASE DIRECTORY FOR ATTACKER THAT THE GRAVEYARD ADDING IS HAPPENING: ${attackerSeats.length ? `games/${GAME_ID}/players/${attackerSeats[0]}` : '(none)'}`);
    // =========================================================

    console.log(`[outcome][sum] defenderSeat=${mySeat} totalDamage=${totalDamageToMe}`);

    // === Atomic life write using nested FieldPath (unchanged) ===
    if (totalDamageToMe > 0) {
      await firebaseReady;

      if (typeof combatDoc !== 'function') {
        console.warn('[outcome] combatDoc() missing; cannot write life');
      } else {
        const ref = combatDoc();

        // Read once for BEFORE/AFTER + full map for a correct local UI nudge
        let before = 20, after = null, np = 2, lifeMapAtRead = {1:20,2:20,3:20};
        try{
          const snap = await ref.get();
          const d = snap.exists ? (snap.data() || {}) : {};
          const life = d.lifeByPlayer || {};
          lifeMapAtRead = {1:20,2:20,3:20, ...life};   // keep defaults for empty seats
          np = Number(d.numPlayers || window.NUM_PLAYERS || 2);
          before = Number(lifeMapAtRead[mySeat] ?? 20);
          after  = Math.max(0, before - totalDamageToMe);
        }catch(e){
          console.warn('[outcome] initial life read failed for logging', e);
        }

        console.log('[outcome][write] applying damage', {
          defenderSeat: mySeat,
          damage: totalDamageToMe,
          lifeBefore: before,
          lifeAfter: after
        });

        // lifeByPlayer.<mySeat> -= totalDamageToMe
        const path = new firebase.firestore.FieldPath('lifeByPlayer', String(mySeat));
        await ref.update(
          path, firebase.firestore.FieldValue.increment(-totalDamageToMe),
          'updatedAt', firebase.firestore.FieldValue.serverTimestamp()
        );

        // Local UI nudge ‚Äî use the FULL map so the strip layout doesn't shift
        if (after != null) {
          const fullLife = { ...lifeMapAtRead, [mySeat]: after };
          if (typeof renderLifeStrip === 'function') {
            renderLifeStrip({ lifeByPlayer: fullLife, numPlayers: np });
          } else if (typeof updateLifeStrip === 'function') {
            updateLifeStrip(fullLife, np);
          }
          console.log('[outcome][write] local strip updated (full map)');
        }

        console.log('[outcome][write] commit OK');
      }
    } else {
      console.log('[outcome] no player damage selected; skipping life write');
    }

    // ==== MOVE DEATHS TO GRAVEYARDS + REMOVE FROM TABLE (ATTACKERS first, then BLOCKERS) ====
    try {
      // helper to promise-ize per-card moves (works with or without a DOM element)
// ‚¨áÔ∏è DROP THIS WHOLE FUNCTION IN, replacing your current moveToGY
const moveToGY = async ({ seat, el, id, name }, role) => {
  const cid = el ? ensureCid(el) : String(id || '');
  if (!seat || seat <= 0) {
    console.warn(`[graveyard] SKIP ${role} seat invalid`, { seat, id: cid, name: el?.getAttribute?.('data-name') || name || '' });
    return;
  }
  const pathStr = `games/${GAME_ID}/players/${seat}`;
  console.log(`[graveyard] ${role} ‚Üí ${pathStr}/Graveyard  id=${cid}  name="${el?.getAttribute?.('data-name') || name || ''}"`);

  if (el) {
    // DOM path already serializes name/img/extras
    await appendCardToPlayerZone(seat, 'Graveyard', el, role);
  } else {
    // HEADLESS PATH: pull img/extras from the player's Table entry so the GY entry keeps artwork + metadata
    let img = '', extras;
    try {
      await firebaseReady;
      const docRef = db.collection('games').doc(GAME_ID).collection('players').doc(String(seat));
      const snap = await docRef.get();
      if (snap.exists) {
        const data = snap.data() || {};
        const tbl = Array.isArray(data.Table) ? data.Table : [];
        const hit = tbl.find(c => String(c?.id) === String(cid));
        if (hit) {
          img = String(hit.img || '');
          if (hit.extras !== undefined) extras = hit.extras;
        }
      }
    } catch (e) {
      console.warn('[moveToGY] headless lookup failed', e);
    }

    const entry = { id: cid, name: name || '' };
    if (img) entry.img = img;
    if (extras !== undefined) entry.extras = extras;

    await appendEntryToPlayerZone(seat, 'Graveyard', entry, role);
  }

  if (cid) await removeCardFromPlayerTable(seat, cid);
  if (el && el.remove) el.remove();
};


      // attackers (use ATTACKER‚ÄôS seat collected earlier)
      for (const item of toRemoveAttackers) {
        await moveToGY(item, 'attacker');
      }

      // blockers (always defender‚Äôs seat = mySeat; we already recorded that in toRemoveBlockers)
      for (const item of toRemoveBlockers) {
        await moveToGY(item, 'blocker');
      }

      console.log(`[graveyard][done] moved ${toRemoveAttackers.length} attacker(s) and ${toRemoveBlockers.length} blocker(s).`);
    } catch (e) {
      console.error('[graveyard] error while moving deaths', e);
    }
	
	    // Flip defenseOutcome ‚Üí 1 so both devices clean up their boards
    try{
      await firebaseReady; if (!db) throw new Error('no db');
      await combatDoc().set({
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        defenseOutcome: 1
      }, { merge: true });
      console.log('[outcome] defenseOutcome set ‚Üí 1');
    } catch(e){
      console.warn('[outcome] failed to set defenseOutcome', e);
    }


    // Close overlays
    ov2.remove();
    ov.remove();
  }catch(err){
    console.error('[outcome][apply] FAILED', err);
  }
};



// Write a saved entry directly to a player's zone (works without a DOM element)
async function appendEntryToPlayerZone(playerSeat, zoneKind, entry, role){
  await firebaseReady;
  if (!db) return;

  const seatStr = String(playerSeat);
  const docRef  = db.collection('games').doc(GAME_ID).collection('players').doc(seatStr);

  // Build a Firestore-safe object (NO undefined fields)
  const clean = {
    id:   String(entry?.id || ''),
    name: String(entry?.name || ''),
    img:  String(entry?.img  || '')
    // extras will be attached below only if defined
  };
  if (entry && entry.extras !== undefined) clean.extras = entry.extras;

  console.log(`[graveyard][${role||'unknown'}] WRITE (by id) ‚Üí games/${GAME_ID}/players/${seatStr}  zone=${zoneKind}`, clean);

  await docRef.set(
    {
      [zoneKind]: firebase.firestore.FieldValue.arrayUnion(clean),
      updatedAt:  firebase.firestore.FieldValue.serverTimestamp()
    },
    { merge:true }
  );

  console.log(`[graveyard][${role||'unknown'}] OK (by id) ‚Üí games/${GAME_ID}/players/${seatStr}  zone=${zoneKind}  id=${clean.id}`);
}



}


//---------------------------

// END turn with confirm; rotate 1..N (server source of truth)
document.getElementById('endBtn').addEventListener('click', async ()=>{
  const ok = confirm(`End Player ${turnPlayer}'s turn?`);
  if(!ok) return;

  const nextTurn = (Number(turnPlayer) % Number(NUM_PLAYERS)) + 1;
  turnPlayer = nextTurn; // keep local mirror

  showToast(`Turn: Player ${turnPlayer}`);

  try{
    // Clear combat rows and write new turn/players atomically
    await firebaseReady; if(!db) return;
    await combatDoc().set({
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      turnPlayer: Number(nextTurn),
      numPlayers: Number(NUM_PLAYERS),
      attacksByPlayer: {},
      blocksByDefender: {}
    }, { merge: false }); // replace
    console.log('[turn] advanced on server to P' + nextTurn);
  }catch(e){
    console.warn('[turn] end turn write failed:', e);
  }
});



// Optional: clicking outside closes the # popout (like others)
document.addEventListener('click', (e)=>{
  const w = document.getElementById('numWrapper');
  if (!w.contains(e.target)) w.classList.remove('open');
}, true);


/* Chat button (placeholder) */
/* ===== Chat overlay + Firestore-backed chat ===== */
const chatOverlay = $('#chatOverlay');
const chatPanel   = chatOverlay.querySelector('.chatPanel');
const chatLog     = $('#chatLog');
const chatInput   = $('#chatInput');
const chatSend    = $('#chatSend');
const chatClose   = $('#chatClose');
const toastEl     = $('#toast');

let chatUnsub = null;     // onSnapshot unsubscribe for chat list
let announceUnsub = null; // onSnapshot unsubscribe for announce doc
let chatOpen = false;

// Helper: tiny HTML escaper
function esc(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

// Helper: show toast
let toastTimer = null;
function showToast(msg){
  toastEl.textContent = msg;
  toastEl.style.display = 'block';
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>{ toastEl.style.display='none'; }, 2800);
}

// Render chat messages into the log
function renderChatSnap(snap){
  const me = (typeof currentPlayer === 'number' ? currentPlayer : 0);
  const frag = document.createDocumentFragment();

  // Clear and rebuild for simplicity (chat is small)
  chatLog.textContent = '';

  snap.forEach(doc=>{
    const d = doc.data() || {};
    const line = document.createElement('div');
    line.className = 'chatLine';
    line.dataset.mid = doc.id;

    const who  = document.createElement('div'); who.className = 'chatWho';  who.textContent = `P${d.playerId ?? 0}`;
    const text = document.createElement('div'); text.className = 'chatText'; text.textContent = d.text || '';
    const time = document.createElement('div'); time.className = 'chatTime';
    const ts   = d.ts && d.ts.toDate ? d.ts.toDate() : null;
    time.textContent = ts ? ts.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';

    const del  = document.createElement('button');
    del.className = 'chatDel';
    del.title = 'Delete message';
    del.textContent = '√ó';
    del.style.display = (Number(d.playerId) === Number(me)) ? 'inline-flex' : 'none';
    del.addEventListener('click', async (e)=>{
      e.stopPropagation();
      await firebaseReady;
      if(!db) return;
      try{
        await db.collection('games').doc(GAME_ID).collection('chat').doc(doc.id).delete();
      }catch(err){ console.warn('delete fail', err); }
    });

    line.appendChild(who);
    line.appendChild(text);
    line.appendChild(time);
    line.appendChild(del);
    frag.appendChild(line);
  });

  chatLog.appendChild(frag);
  chatLog.scrollTop = chatLog.scrollHeight;
}

// Open/close overlay
function openChat(){
  chatOverlay.style.display = 'block';
  chatOverlay.removeAttribute('aria-hidden');
  chatOpen = true;
  chatInput.focus();

  // Live chat stream
  (async ()=>{
    await firebaseReady; if(!db) return;
    if(!chatUnsub){
      chatUnsub = db.collection('games').doc(GAME_ID).collection('chat')
        .orderBy('ts','asc')
        .onSnapshot(renderChatSnap);
    }
    if(!announceUnsub){
      // Watch the announce doc to show toasts for messages not sent by me
      const aRef = db.collection('games').doc(GAME_ID).collection('meta').doc('chatAnnounce');
      announceUnsub = aRef.onSnapshot(s=>{
        if(!s.exists) return;
        const d = s.data() || {};
        const me = (typeof currentPlayer === 'number' ? currentPlayer : 0);
        if(d.hasAnnounced === 0 && Number(d.playerId) !== Number(me)){
          const preview = (d.text || '').slice(0, 120);
          showToast(`P${d.playerId}: ${preview}`);
          aRef.set({ hasAnnounced: 1 }, { merge:true }).catch(()=>{});
        }
      });
    }
  })();
}
function closeChat(){
  chatOverlay.style.display = 'none';
  chatOverlay.setAttribute('aria-hidden','true');
  chatOpen = false;
}

// Send message
async function sendChat(){
  const text = (chatInput.value || '').trim();
  if(!text) return;
  chatInput.value = '';

  await firebaseReady; if(!db) return;

  const me = (typeof currentPlayer === 'number' ? currentPlayer : 0);
  const ref = db.collection('games').doc(GAME_ID);
  const chatRef = ref.collection('chat');
  const metaRef = ref.collection('meta').doc('chatAnnounce');

  try{
    const docRef = await chatRef.add({
      text, playerId: me,
      ts: firebase.firestore.FieldValue.serverTimestamp()
    });
    // Flip announce flag to ‚Äúnew‚Äù so other clients toast it
    await metaRef.set({
      hasAnnounced: 0,
      playerId: me,
      text,
      mid: docRef.id,
      ts: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge:true });
  }catch(err){
    console.warn('sendChat fail', err);
  }
}

// Wire UI
$('#chatBtn').addEventListener('click', ()=>{
  if(chatOpen) closeChat(); else openChat();
});
chatClose.addEventListener('click', closeChat);
chatSend.addEventListener('click', sendChat);
chatInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendChat(); }
});

// Click-away: only close if the BACKDROP itself is tapped
chatOverlay.addEventListener('pointerdown', (e)=>{
  if (e.target === chatOverlay) closeChat();
});

// Shield interactions inside the panel so they never bubble to the backdrop
chatPanel.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });

// Global: clicking the table (outside overlay) still closes if open
table.addEventListener('pointerdown', ()=>{ if(chatOpen) closeChat(); });

// Esc closes
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && chatOpen) closeChat();
});

/* ===== end chat overlay ===== */

const stackWrap = $('#stackWrap');
const stackBtn  = $('#stackBtn');
const upBtn     = $('#stackUpBtn');
const leftBtn   = $('#stackLeftBtn');
const rightBtn  = $('#stackRightBtn');
const homeBtn   = $('#homeBtn');


stackBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  stackWrap.classList.toggle('open');
});
document.addEventListener('pointerdown', (e)=>{
  if (!stackWrap.contains(e.target) && !stackMode){
    stackWrap.classList.remove('open');
  }
});
function setStackMode(mode){
  stackMode = (stackMode===mode ? null : mode);
  [upBtn,leftBtn,rightBtn].forEach(b=>b.classList.remove('on'));
  if(stackMode==='up') upBtn.classList.add('on');
  if(stackMode==='left') leftBtn.classList.add('on');
  if(stackMode==='right') rightBtn.classList.add('on');
  if(stackMode){ stackWrap.classList.add('open'); } else { stackWrap.classList.remove('open'); }
}
upBtn.addEventListener('click',   (e)=>{ e.stopPropagation(); setStackMode('up');    });
leftBtn.addEventListener('click', (e)=>{ e.stopPropagation(); setStackMode('left');  });
rightBtn.addEventListener('click',(e)=>{ e.stopPropagation(); setStackMode('right'); });

// Compass: ALWAYS zoom out to min and center on table cards (or center origin if none)
homeBtn.addEventListener('click', goHome);


/* =========================================================
   Pan & pinch the table/world
   ========================================================= */
const pointers=new Map(); let mode=null; let panOffset={x:0,y:0};
let pinchStart={center:{x:0,y:0}, dist:1, scale:1, tx:0, ty:0};
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function centerOfPointers(){ let sx=0,sy=0,n=0; pointers.forEach(p=>{sx+=p.x; sy+=p.y; n++;}); return {x:sx/n,y:sy/n}; }
function worldPointAt(cx,cy,st){ const r=table.getBoundingClientRect(); const px=cx-r.left, py=cy-r.top; const sc=st?st.scale:state.scale, tx=st?st.tx:state.tx, ty=st?st.ty:state.ty; return {x:(px-tx)/sc,y:(py-ty)/sc}; }

table.addEventListener('pointerdown', e=>{
  // If press lands inside the hand's screen rect, do not start table pan.
  const hz = handZone.getBoundingClientRect();
  const inHand = (e.clientX>=hz.left && e.clientX<=hz.right && e.clientY>=hz.top && e.clientY<=hz.bottom);
  if (inHand) return;

  // If a card body is the target, let the card‚Äôs handler own it.
  if (e.target.closest('.cardBody')) return;

  clearSelection();

  table.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(pointers.size===1){ mode='pan'; panOffset.x=e.clientX-state.tx; panOffset.y=e.clientY-state.ty; }
  else if(pointers.size===2){
    mode='pinch';
    const c=centerOfPointers(); const arr=Array.from(pointers.values());
    pinchStart.center=c; pinchStart.dist=dist(arr[0],arr[1])||1;
    pinchStart.scale=state.scale; pinchStart.tx=state.tx; pinchStart.ty=state.ty;
  }
});
table.addEventListener('pointermove', e=>{
  if(!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(mode==='pan' && pointers.size===1){
    state.tx=e.clientX-panOffset.x; state.ty=e.clientY-panOffset.y; applyTransform();
  }
  if(mode==='pinch' && pointers.size>=2){
    const arr=Array.from(pointers.values());
    const cNow=centerOfPointers(); const dNow=dist(arr[0],arr[1])||1;
    const newScale=clamp(pinchStart.scale*(dNow/pinchStart.dist),0.35,2.0);
    const wp=worldPointAt(pinchStart.center.x,pinchStart.center.y,{scale:pinchStart.scale,tx:pinchStart.tx,ty:pinchStart.ty});
    const r=table.getBoundingClientRect(); const cx=cNow.x-r.left, cy=cNow.y-r.top;
    state.scale=newScale; state.tx=cx-wp.x*state.scale; state.ty=cy-wp.y*state.scale; applyTransform();
  }
});
function endPointer(e){
  if(!pointers.has(e.pointerId)) return;
  pointers.delete(e.pointerId);
  if(pointers.size===0){ mode=null; }
  else if(pointers.size===1){ const only=pointers.values().next().value; mode='pan'; panOffset.x=only.x-state.tx; panOffset.y=only.y-state.ty; }
  else if(pointers.size>=2){
    const arr=Array.from(pointers.values()); mode='pinch';
    pinchStart.center=centerOfPointers(); pinchStart.dist=dist(arr[0],arr[1])||1;
    pinchStart.scale=state.scale; pinchStart.tx=state.tx; pinchStart.ty=state.ty;
  }
}
table.addEventListener('pointerup', endPointer);
table.addEventListener('pointercancel', endPointer);
window.addEventListener('resize', applyTransform);

// ===== Life strip <-> Firestore wiring =====
function renderLifeStrip(data){
  const life = (data && data.lifeByPlayer) || {};
  const np   = Math.max(1, Math.min(3, Number((data && data.numPlayers) || 1)));

  const wrap3 = document.getElementById('lifeP3Wrap');
  const meEl  = document.getElementById('lifeMe');
  const p2El  = document.getElementById('lifeP2');
  const p2Lb  = document.getElementById('lifeP2Label');
  const p3El  = document.getElementById('lifeP3');

  if (!meEl || !p2El) return; // life strip not present; nothing to render

  // NOTE: we don‚Äôt depend on mySeat here; we just render P1/P2/P3.
  meEl.textContent = Number.isFinite(life[1]) ? life[1] : 20;
  p2El.textContent = Number.isFinite(life[2]) ? life[2] : 20;

  if (np === 3) {
    if (wrap3) wrap3.style.display = '';
    if (p2Lb) p2Lb.textContent = 'P2';
    if (p3El) p3El.textContent = Number.isFinite(life[3]) ? life[3] : 20;
  } else {
    if (wrap3) wrap3.style.display = 'none';
    if (p2Lb) p2Lb.textContent = 'P2';
  }
}

/* ===== Graveyard / Exile Overlays ===== */
async function openZoneOverlay(kind /* 'Graveyard' | 'Exile' */){
  try{
    await firebaseReady;
const pid = (window.viewerMode && window.viewerPlayer) ? window.viewerPlayer : window.currentPlayer || 1;
console.log(`[zone overlay] kind=${kind} viewerMode=${!!window.viewerMode} viewerPlayer=${window.viewerPlayer||'(none)'} currentPlayer=${window.currentPlayer} ‚Üí pid=${pid}`);
const data = await loadPlayerState(pid);

    const cards = (data && Array.isArray(data[kind])) ? data[kind] : [];

    // lazy-build or reuse one overlay node
    let ov = document.getElementById('zoneOverlay');
    if (!ov){
      ov = document.createElement('div');
      ov.id = 'zoneOverlay';
      ov.style.cssText = "position:fixed; inset:0; z-index:10000; display:none; align-items:center; justify-content:center; background:rgba(6,10,16,.72);";
      ov.innerHTML =
        '<div class="panel" style="width:min(680px,94vw); max-height:80vh; overflow:auto; background:linear-gradient(180deg,#0d1118,#0a0f16); border:1px solid #24324a; border-radius:14px; padding:14px; color:#e7e9ee; box-shadow:0 24px 48px rgba(0,0,0,.5)">'+
          '<div class="hdr" style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">'+
            '<div class="title" style="font-weight:800;font-size:18px;"></div>'+
            '<button class="close" style="border:1px solid #2b3f63; background:#1a2a45; color:#cfe1ff; border-radius:10px; padding:6px 10px; font-weight:700">‚úï</button>'+
          '</div>'+
          '<div class="content" style="display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:10px"></div>'+
        '</div>';
      document.body.appendChild(ov);
    }

    const title   = ov.querySelector('.title');
    const content = ov.querySelector('.content');
    title.textContent = `${kind} ‚Äî ${cards.length || 0} card${cards.length===1?'':'s'}`;

    // Render each saved card with its CID as a data attribute (so we can remove the exact DOM node from the zone)
    const rows = cards.map((c, i)=>{
      const cid = (c && c.id != null) ? String(c.id) : '';
      const nm  = (c && c.name) || 'Card';
      const img = (c && c.img)  || '';
      return (
        '<div class="zItem" data-idx="'+i+'" data-cid="'+cid+'" style="border:1px solid #2b3344; border-radius:10px; background:#141823; padding:10px; cursor:pointer;">'+
          '<div style="display:flex; gap:10px; align-items:center">'+
            '<img src="'+img+'" alt="" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>'+
            '<div style="flex:1;min-width:160px">'+
              '<div style="font-weight:700">'+escapeHTML(nm)+'</div>'+
              '<div style="opacity:.75;font-size:12px">Tap to return to battlefield</div>'+
            '</div>'+
          '</div>'+
        '</div>'
      );
    }).join('');
    content.innerHTML = rows;

    // Clicking a card: remove from zone ‚Üí spawn to table at screen center ‚Üí select ‚Üí recompute ‚Üí save ‚Üí refresh overlay
    content.querySelectorAll('.zItem').forEach(el=>{
      el.addEventListener('click', async ()=>{
        const cid = el.getAttribute('data-cid') || '';
        await playCardOutOfZone(kind, cid);
        // Re-render overlay list to reflect removal
        openZoneOverlay(kind);
      });
    });

    ov.style.display = 'flex';
    ov.querySelector('.close').onclick = ()=> { ov.style.display='none'; };

  } catch (err){
    console.error('[zone overlay]', err);
  }
}

async function playCardOutOfZone(kind, cid /* string id from saved zone card */){
  await firebaseReady;
  const pid = (window.viewerMode && window.viewerPlayer) ? window.viewerPlayer : window.currentPlayer || 1;
  const data = await loadPlayerState(pid);
  const list = (data && Array.isArray(data[kind])) ? data[kind] : [];

  // Find the saved card details (for name/img/extras), if available
  const saved = list.find(c => String(c?.id) === String(cid)) || null;
  const name  = saved?.name || '';
  const img   = saved?.img  || '';

  // Remove the matching DOM node inside the hidden zone container so savePlayerState won‚Äôt keep it there
  const zoneSelector = (kind === 'Graveyard') ? '.graveyard' : '.exile';
  if (cid) {
    const zoneDomCard = document.querySelector(`${zoneSelector} .card[data-cid="${CSS.escape(cid)}"]`);
    if (zoneDomCard) zoneDomCard.remove();
  }

  // Compute world coordinates at the screen center (same transform math you already use)
  const r  = table.getBoundingClientRect();
  const cx = r.left + r.width / 2;
  const cy = r.top  + r.height/ 2;
  const pt = worldPointAt(cx, cy, { scale: state.scale, tx: state.tx, ty: state.ty }); /* existing helper */

  // Spawn onto the battlefield, center the card visually, reapply extras, select, recompute
  const newCard = spawnCardFromSaved({ name, img, x: pt.x, y: pt.y, id: cid, extras: saved?.extras });
  // center the element on its own width/height
  newCard.style.left = (pt.x - newCard.offsetWidth  / 2) + 'px';
  newCard.style.top  = (pt.y - newCard.offsetHeight / 2) + 'px';

  if (saved && saved.extras) applySavedCardExtras(newCard, saved);   /* rehydrates P/T etc. */  // :contentReference[oaicite:3]{index=3}
  if (typeof attachGearButton === 'function') attachGearButton(newCard);                         // :contentReference[oaicite:4]{index=4}
  if (typeof setSelectionFromCard === 'function') setSelectionFromCard(newCard);
  if (typeof recomputeContinuousEffects === 'function') recomputeContinuousEffects();

  // Persist new world + zones snapshot (Table from #world, zones from .graveyard/.exile DOM)
  await savePlayerState(pid);  // :contentReference[oaicite:5]{index=5}
}


function openGraveyardOverlay(){ return openZoneOverlay('Graveyard'); }
function openExileOverlay(){ return openZoneOverlay('Exile'); }

function wireZoneOverlays(){
  // make the world zones clickable to open overlays
  document.querySelector('.zone.graveyard')
    ?.addEventListener('click', (e)=>{ e.stopPropagation(); openGraveyardOverlay(); });

  document.querySelector('.zone.exile')
    ?.addEventListener('click', (e)=>{ e.stopPropagation(); openExileOverlay(); });
}

// ensure it runs after the DOM is ready (you already do this for life)
window.addEventListener('load', wireZoneOverlays);


/* ===== Zone drop helpers (Graveyard/Exile) ===== */
function elRect(el){ return el.getBoundingClientRect(); }
function pointInRect(px, py, r){ return px >= r.left && px <= r.right && py >= r.top && py <= r.bottom; }

function cardCenterScreen(card){
  const r = card.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}

function isOverZone(card, zoneSel){
  const zone = document.querySelector(zoneSel);
  if (!zone) return false;
  const p = cardCenterScreen(card);
  const zr = elRect(zone);
  return pointInRect(p.x, p.y, zr);
}

let _zoneFan = { grave:0, exile:0 }; // simple vertical fan per zone this session

function clearDragTransform(card){
  const body = card.querySelector('.cardBody');
  if (!body) return;
  // Temporarily disable transition, clear transform, force reflow, restore transition
  const prev = body.style.transition;
  body.style.transition = 'none';
  body.style.transform  = '';
  // force reflow so the browser applies left/top again
  // eslint-disable-next-line no-unused-expressions
  body.offsetHeight;
  body.style.transition = prev || '';
}


async function moveCardToZoneAndSave(card, zoneSel, kind /* 'Graveyard' | 'Exile' */){
  try{
    const zone = document.querySelector(zoneSel);
    if (!zone) return;

    // Let your drag-end math finish committing for this frame
    await new Promise(r => requestAnimationFrame(r));

    // Kill any leftover drag translate() so left/top will take effect
    clearDragTransform(card);

    // Make sure it‚Äôs not in the hand
    if (card.parentElement === handZone) return;

    // Clean selection/gear halos
    card.classList.remove('selected', 'show-gear');

    // Reparent into the zone
    zone.appendChild(card);

    // Compact vertical fan inside the zone
    const idx = zone.querySelectorAll('.card').length - 1; // 0-based
    card.style.left = '6px';
    card.style.top  = (6 + idx * 24) + 'px';

    // Persist by re-serializing everything (uses your existing saver)
    await savePlayerState(window.currentPlayer || 1);

    if (typeof showToast === 'function') showToast(`${kind}: card moved.`);
  }catch(e){
    console.warn('[zone drop] save failed:', e);
  }
}


/* Called when a drag ends on a table card */
async function handleZoneDrop(card){
  if (window.viewerMode) return; // don‚Äôt mutate while viewing others
  // Only consider cards that live directly on the battlefield (#world children)
  if (card.parentElement !== world) return;

  if (isOverZone(card, '.zone.graveyard')){
    await moveCardToZoneAndSave(card, '.zone.graveyard', 'Graveyard');
  } else if (isOverZone(card, '.zone.exile')){
    await moveCardToZoneAndSave(card, '.zone.exile', 'Exile');
  }
}

function wireZoneDropWatcher(){
  document.addEventListener('pointerup', (e)=>{
    const body = e.target.closest('.card .cardBody');
    if (!body) return;

    const card = body.closest('.card');
    if (!card) return;

    // Ignore ‚Äúin-hand‚Äù cards ‚Äî only move battlefield cards to zones
    if (card.parentElement === handZone) return;

    // Defer slightly so any drag math in your handler settles
    setTimeout(()=> handleZoneDrop(card), 0);
  }, { passive:true });
}
window.addEventListener('load', wireZoneDropWatcher);



async function wireLifeRealtime(){
  await firebaseReady;
  try{
    combatDoc().onSnapshot(s => renderLifeStrip(s.exists ? s.data() : {}));
  }catch(e){
    console.warn('[life] snapshot error:', e.message || e);
  }
}
wireLifeRealtime();
window.addEventListener('load', async () => {
  try { await firebaseReady; } catch(e) {}
  startDefenseOutcomePoller(100);
});

/* =========================================================
   Seed deck + boot
   ========================================================= */
$('#deckIn').value=[
"1 Liliana's Reaver",
"1 Lord of the Accursed",
"1 Macabre Waltz",
"1 Metallic Mimic",
"1 Mikaeus, the Unhallowed",
"1 Mindleech Ghoul",
"1 Neheb, the Eternal",
"1 Phylactery Lich",
"1 Phyrexian Ghoul",
"1 Prized Amalgam"
].join('\n');

applyTransform();
requestAnimationFrame(goHome);
</script>
<!-- === Card Edit Overlay === -->
<div id="editOverlay" aria-hidden="true">
  <div class="panel">
    <h3 id="editTitle">Edit Card</h3>

    <div class="row">
      <label>Additional Types</label>
      <input id="editTypes" type="text" placeholder="Comma-separated (e.g., Zombie, Warrior)"/>
    </div>

    <div class="row">
      <label>Additional Effects</label>
      <textarea id="editEffects" placeholder="Comma-separated keywords/effects (e.g., menace, flying, shroud)"></textarea>
    </div>

    <div class="row">
      <label>P/T Modifier</label>
      <div style="display:flex; gap:8px;">
        <input id="editP" type="number" step="1" placeholder="+P (e.g., 1)"/>
        <input id="editT" type="number" step="1" placeholder="+T (e.g., 1)"/>
      </div>
    </div>

    <div class="row">
      <label>Chosen Type (for ‚Äúchoose a type‚Äù cards)</label>
      <input id="editChosenType" type="text" placeholder="e.g., Zombie"/>
    </div>

    <div class="actions">
      <button class="btn cancel" id="editCancel">Cancel</button>
      <button class="btn save"   id="editSave">Save</button>
    </div>
  </div>
</div>

</body>
</html>
