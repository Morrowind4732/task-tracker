<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Deck Table — Mobile (hand carousel + stacks + actions)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<link rel="stylesheet" href="mana-master/css/mana.css">

<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<style>
  :root{
    /* Theme + sizing tokens. Kept the same so existing styles/layout keep working. */
    --bg:#0e1015; --fg:#e7e9ee; --muted:#9aa3b2; --accent:#6aa9ff;
    --card-w:223px; --card-h:310px; --hint-w:320px; --inv-scale:1;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--fg); background:#0e1015;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    display:grid; grid-template-rows: 64px auto 1fr; grid-template-columns: 1fr;
  }

  /* Top bar */
  .topbar{
    display:flex; gap:10px; align-items:center; padding:10px 12px;
    border-bottom:1px solid #1f2738; background:linear-gradient(180deg,#10141b,#0c1117);
    position:sticky; top:0; z-index:5;
  }
  .hamb{
    width:42px; height:42px; border-radius:12px; border:1px solid #24324a; background:#111826;
    display:flex; align-items:center; justify-content:center; cursor:pointer;
  }
  .hamb span,.hamb span:before,.hamb span:after{
    content:""; display:block; width:18px; height:2px; background:#cfe1ff; position:relative;
  }
  .hamb span:before{position:absolute; top:-6px; content:"";}
  .hamb span:after{position:absolute; top:6px; content:"";}
  button{
    border:0; background:var(--accent); color:#091323; font-weight:700; padding:9px 14px;
    border-radius:12px; cursor:pointer; box-shadow:0 8px 20px rgba(106,169,255,.25);
  }
  .pill{background:#1b2a47; color:#d8e7ff}
  .count{margin-left:auto; color:#b9c7e8; font-weight:700}

  /* Drawer */
  .drawer-wrap{ overflow:hidden; transition:max-height .28s ease; border-bottom:1px solid #1f2738; }
  .drawer{ padding:10px 12px; background:#0b0f15; }
  .drawer-wrap.collapsed{ max-height:0; border-bottom-color:transparent; }
  .drawer-wrap.expanded{ max-height:320px; }
  textarea{
    width:100%; height:160px; resize:vertical; padding:10px;
    border-radius:12px; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee;
    font:14px/1.45 ui-monospace, Menlo, Consolas, monospace;
  }

  /* Table + world */
  .table{position:relative; overflow:hidden; background:linear-gradient(180deg,#0d3a1e,#0a2716 40%, #092113); touch-action:none;}
  .world{position:absolute; inset:0; transform-origin:0 0; touch-action:none;}
  .zone{
    position:absolute; border:2px dashed rgba(255,255,255,.18); border-radius:12px;
    background:rgba(0,0,0,.12); user-select:none; display:flex; align-items:center; justify-content:center;
  }
  .zone .label{ color:#c9cfdb; font-size:16px; transform:scale(var(--inv-scale)); transform-origin:center; pointer-events:none;}
  .graveyard{bottom:20px; right:20px; width:160px; height:210px}
  .exile{top:20px; right:20px; width:160px; height:210px}
  .commander{bottom:20px; left:20px; width:170px; height:120px}

  /* Hand zone anchored into the world with transform math */
  .handZone{ pointer-events:auto; }
  .handZone .label{ opacity:.75 }

  /* Cards */
  .card{position:absolute; width:var(--card-w); height:var(--card-h); border-radius:14px; user-select:none; touch-action:none; outline:none; pointer-events:none;}
  .card.selected .cardBody{ outline:3px solid #6aa9ff; outline-offset:2px; }
  .cardBody{position:absolute; inset:0; transform-origin:center; transition:transform .2s ease; box-shadow:0 10px 26px rgba(0,0,0,.5); cursor:grab; pointer-events:auto;}
  .card3d{position:absolute; inset:0; perspective:1000px}
  .inner{position:absolute; inset:0; transform-style:preserve-3d; transition:transform .6s cubic-bezier(.2,.6,.2,1)}
  .flipped .inner{transform:rotateY(180deg)}
  .face{position:absolute; inset:0; border-radius:14px; overflow:hidden; backface-visibility:hidden; background:#06080e}
  .face img{width:100%; height:100%; object-fit:cover; display:block; pointer-events:none; -webkit-user-drag:none}
  .back{transform:rotateY(180deg)}

  /* Floating actions (right side) */
  .actions{
  position:fixed; right:10px; top:50%;
  transform:translateY(-50%);
  display:flex; flex-direction:column; gap:8px;
  z-index: var(--z-controls); /* sits above #hint */
}

  .fab{width:52px; height:52px; border-radius:50%; background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63; display:flex; align-items:center; justify-content:center; font-weight:900; font-size:20px;}
  .fab.chat { font-size:18px; }

  /* Tooltip */
.hint{
  position:fixed;
  /* we now position this dynamically above the in-hand center card */
  width:var(--hint-w);
  background:rgba(10,14,22,.98);
  border:1px solid #24324a;
  border-radius:12px;
  padding:10px;
  box-shadow:0 12px 28px rgba(0,0,0,.6);
  display:none; 
  z-index: var(--z-tooltip);
}
.hint h3{margin:0 0 4px; font-size:14px; color:#dbe5ff}
.hint .meta{font-size:12px; color:#b9c3d9; margin-bottom:6px}
.hint .txt{font-size:12px; color:#cfdbf3; white-space:pre-wrap; max-height:160px; overflow:auto}


  /* Hand carousel visuals (slots) */
  .in-hand{ pointer-events:auto; }
  .hand-slot{ position:absolute; top:50%; transform:translate(-50%,-50%); }
  .hand-left { left:28%; }
  .hand-center{ left:50%; }
  .hand-right{ left:72%; }
  /* extra visible neighbors (as requested) */
  .hand-l2 { left:16%; }
  .hand-l3 { left:4%;  }
  .hand-r2 { left:84%; }
  .hand-r3 { left:96%; }

  .hand-small .cardBody{ transform:scale(.72); }
  .hand-center .cardBody{ transform:scale(1); }
  .hand-hidden{ opacity:0; pointer-events:none; }

  /* Make sure our in-hand card captures gestures (prevents table panning steals) */
  .in-hand .cardBody { touch-action: none; }

  /* Stack popout */
  .stack-wrapper { position: relative; }
  .stack-actions{
    position: absolute; right: 62px; top: 50%; transform: translateY(-50%);
    display: none; flex-direction: column; gap: 8px; z-index: 7;
  }
  .stack-wrapper.open .stack-actions{ display: flex; }

  .sbtn{
    width: 44px; height: 44px; border-radius: 12px; background:#1a2a45; color:#cfe1ff;
    border:1px solid #2b3f63; display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size:18px; cursor:pointer; box-shadow:0 8px 20px rgba(106,169,255,.18);
  }
  .sbtn.on{ outline:2px solid #6aa9ff; box-shadow:0 0 0 6px rgba(106,169,255,.18) inset; }

  .fab:active, .sbtn:active { transform: scale(0.98); }
  
  /* Creature P/T badge */
.pt-badge{
  position:absolute; right:6px; bottom:6px;
  transform:scale(var(--inv-scale)); transform-origin: bottom right;
  background:rgba(8,12,20,.85); border:1px solid #2b3f63; border-radius:10px;
  padding:3px 6px; font-weight:800; font-size:14px; color:#e7f0ff;
  text-shadow:0 1px 0 rgba(0,0,0,.4); pointer-events:none;
}
.in-hand .pt-badge{ display:none; } /* hide in hand */

  /* put this anywhere in your <style> block */
.hint .mana-line .ms{ 
  font-size:16px; 
  line-height:1; 
  vertical-align:-0.12em; 
  margin-right:2px;
}

/* put this in your <style> */
.hint .txt .ms{
  font-size:18px;         /* bump if you like it bigger on mobile */
  line-height:1;
  vertical-align:-0.14em; /* nudge baseline so they sit nicely in text */
  margin:0 1px;
}

/* === Player / Viewer popouts === */
.actions-top, .actions-bottom { z-index: var(--z-controls); }
.actions-top{ top:10px; }
.actions-bottom{ bottom:10px; }

.player-wrapper, .view-wrapper{ position:relative; }
.player-actions, .view-actions{
  position:absolute; right:62px; top:50%; transform:translateY(-50%);
  display:none; gap:8px; z-index: var(--z-controls);
}
.player-wrapper.open .player-actions,
.view-wrapper.open .view-actions{ display:flex; }

.pbtn{ /* little square “1 2 3” chips */
  width:44px; height:44px; border-radius:12px; background:#1a2a45; color:#cfe1ff;
  border:1px solid #2b3f63; font-weight:900; font-size:16px; cursor:pointer;
  display:flex; align-items:center; justify-content:center; box-shadow:0 8px 20px rgba(106,169,255,.18);
}
.pbtn.on{ outline:2px solid #6aa9ff; box-shadow:0 0 0 6px rgba(106,169,255,.18) inset; }

.fab svg{ display:block }

/* Viewer mode: make table cards read-only so you can't edit other players */
body.viewer .card .cardBody {
  pointer-events: none !important;
  cursor: default !important;
}

/* Viewer mode: make table cards read-only so you can't edit other players */
body.viewer .card .cardBody {
  pointer-events: none !important;
  cursor: default !important;
}

/* === Chat overlay === */
.chatOverlay{
  position:fixed; inset:0; z-index:10000;
  background:rgba(6,10,16,.7);
  display:none;
}
.chatPanel{
  position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(720px, 94vw); height:min(540px, 80vh);
  display:flex; flex-direction:column;
  background:rgba(12,18,28,.98); border:1px solid #24324a; border-radius:14px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
}
.chatHeader{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 14px; border-bottom:1px solid #1f2738; color:#dbe5ff; font-weight:800;
}
.chatClose{ cursor:pointer; background:#1a2a45; border:1px solid #2b3f63; color:#cfe1ff; border-radius:10px; width:36px; height:32px; font-weight:900; }
.chatLog{
  flex:1; overflow:auto; padding:12px; gap:8px; display:flex; flex-direction:column;
}
.chatLine{
  display:grid; grid-template-columns:auto 1fr auto auto; gap:8px; align-items:center;
  font-size:14px; color:#cfdbf3; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:8px 10px;
}
.chatWho{ font-weight:800; color:#dbe5ff; }
.chatText{ white-space:pre-wrap; }
.chatTime{ opacity:.7; font-size:12px; }
.chatDel{
  width:28px; height:28px; border-radius:8px; background:#2a1a1a; color:#ffd1d1;
  border:1px solid #5a2e2e; font-weight:900; cursor:pointer;
}
.chatInputRow{
  display:flex; gap:8px; padding:10px; border-top:1px solid #1f2738;
}
#chatInput{
  flex:1; border-radius:12px; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee; padding:10px; font:14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
}
#chatSend{
  border:0; background:var(--accent); color:#091323; font-weight:800; padding:10px 14px; border-radius:12px; cursor:pointer; box-shadow:0 8px 20px rgba(106,169,255,.25);
}

/* === Toast for “new message” announce === */
.toast{
  position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
  background:rgba(14,20,32,.98); color:#e7f0ff;
  border:1px solid #2b3f63; border-radius:12px; padding:10px 14px;
  box-shadow:0 12px 28px rgba(0,0,0,.5); z-index:11000; display:none; max-width:90vw;
}

/* === Card gear + Edit overlay === */
.card .gear-btn{
  position:absolute; left:6px; bottom:6px;
  transform:scale(var(--inv-scale)); transform-origin: bottom left;
  width:28px; height:28px; border-radius:50%;
  border:1px solid #2b3f63; background:rgba(8,12,20,.85); color:#cfe1ff;
  display:flex; align-items:center; justify-content:center; font-size:16px;
  cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,.25);
}
.card .gear-btn:active{ transform:scale(calc(var(--inv-scale) * .96)); }

#editOverlay{
  position:fixed; inset:0; z-index:99999;
  display:none; align-items:center; justify-content:center;
  background:rgba(0,0,0,.60);
}
#editOverlay .panel{
  width:min(520px, 92vw);
  background:linear-gradient(180deg,#0d1118,#0a0f16);
  border:1px solid #24324a; border-radius:14px; padding:14px;
  color:#e7e9ee; box-shadow:0 24px 48px rgba(0,0,0,.5);
  max-height:80vh; overflow:auto; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
}
#editOverlay h3{ margin:0 0 8px; font-size:16px; }
#editOverlay .row{ display:grid; grid-template-columns: 140px 1fr; gap:10px; align-items:start; margin:8px 0; }
#editOverlay label{ color:#b9c3d9; font-size:12px; padding-top:8px; }
#editOverlay input[type="text"], #editOverlay textarea, #editOverlay input[type="number"]{
  width:100%; border:1px solid #24304a; background:#0a0f16; color:#e7e9ee; border-radius:10px; padding:8px;
  font:13px/1.4 ui-monospace, Menlo, Consolas, monospace;
}
#editOverlay textarea{ min-height:72px; resize:vertical; }
#editOverlay .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
#editOverlay .btn{ border:0; border-radius:10px; padding:9px 12px; font-weight:700; cursor:pointer; }
#editOverlay .btn.save{ background:#6aa9ff; color:#091323; }
#editOverlay .btn.cancel{ background:#1b2a47; color:#d8e7ff; }


/* Only show the gear when JS toggles .show-gear on that specific card */
.card .gear-btn{ display:none; }
.card.show-gear .gear-btn{ display:flex; }

:root{
  /* …your existing tokens… */
  --z-tooltip: 7;
  --z-controls: 9999; /* above tooltip */
}

/* === Player-count (#) popout === */
.num-wrapper{ position:relative; }
.num-actions{
  position:absolute; right:62px; top:50%; transform:translateY(-50%);
  display:none; gap:8px; z-index: var(--z-controls);
}
.num-wrapper.open .num-actions{ display:flex; }


</style>

  
</style>
</head>
<body>
  <!-- Top controls -->
  <div class="topbar">
    <div id="hamb" class="hamb" title="Show / hide deck input"><span></span></div>
    <button id="loadBtn">Load</button>
    <button class="pill" id="shuffleBtn">Shuffle</button>
    <button class="pill" id="draw7">Draw 7</button>
    <button class="pill" id="draw1">Draw 1</button>
    <div class="count">Deck: <span id="deckCount">0</span></div>
  </div>

  <!-- Collapsible deck input -->
  <div id="drawerWrap" class="drawer-wrap expanded">
    <div class="drawer">
      <textarea id="deckIn" placeholder="Paste your deck list here (e.g., `3 Lightning Bolt`)"></textarea>
    </div>
  </div>

  <!-- Table (world surface + zones) -->
  <main class="table" id="table">
    <div class="world" id="world">
      <div class="zone graveyard"><span class="label">Graveyard</span></div>
      <div class="zone exile"><span class="label">Exile</span></div>
      <div class="zone commander"><span class="label">Commander</span></div>

      <!-- Hand zone lives inside the world so we can “pin” it with transform math -->
      <div class="zone handZone" id="zone-hand"><span class="label">Hand</span></div>
    </div>

    <!-- Tooltip -->
    <div class="hint" id="hint">
      <h3 id="hTitle"></h3>
      <div class="meta" id="hMeta"></div>
      <div class="txt" id="hTxt"></div>
    </div>

    <!-- Chat overlay -->
    <div id="chatOverlay" class="chatOverlay" aria-hidden="true">
      <div class="chatPanel" role="dialog" aria-label="Table Chat">
        <div class="chatHeader">
          <span>Table Chat</span>
          <button id="chatClose" class="chatClose" title="Close">✕</button>
        </div>
        <div id="chatLog" class="chatLog"></div>
        <div class="chatInputRow">
          <input id="chatInput" type="text" placeholder="Type a message…" autocomplete="off"/>
          <button id="chatSend">Send</button>
        </div>
      </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </main>


<div class="actions">
<!-- Players (#) -->
<div class="num-wrapper" id="numWrapper">
  <div class="num-actions" id="numActions">
    <button class="pbtn" data-n="1">1</button>
    <button class="pbtn" data-n="2">2</button>
    <button class="pbtn" data-n="3">3</button>
  </div>
  <button class="fab" id="numBtn" title="Players">#</button>
</div>


<!-- Battle (single sword) -->
<button class="fab" id="plusBtn" title="Battle" aria-label="Battle">
  <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
    <!-- Rotate the whole sword so it doesn't look like a plain | -->
    <g transform="rotate(-45 12 12)" fill="currentColor">
      <!-- blade -->
      <rect x="11" y="3" width="2" height="11" rx="1"/>
      <!-- tip -->
      <path d="M11 3 L12 2 L13 3 Z"/>
      <!-- cross-guard -->
      <rect x="9" y="13" width="6" height="2" rx="1"/>
      <!-- grip -->
      <rect x="11.25" y="15" width="1.5" height="4" rx="0.75"/>
      <!-- pommel -->
      <circle cx="12" cy="20" r="1.2"/>
    </g>
  </svg>
</button>

  <!-- Player selector (above compass) -->
  <div class="player-wrapper" id="playerWrapper">
    <div class="player-actions" id="playerActions">
      <button class="pbtn" data-player="1">1</button>
      <button class="pbtn" data-player="2">2</button>
      <button class="pbtn" data-player="3">3</button>
    </div>
    <button class="fab" id="playerBtn" title="Select Player" aria-label="Player">
      <!-- simple silhouette icon (SVG) -->
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z"></path>
        <path d="M4 20c0-3.31 2.69-6 6-6h4c3.31 0 6 2.69 6 6"></path>
      </svg>
    </button>
  </div>

  <!-- Compass / Home -->
  <button class="fab" id="homeBtn" title="Center & Zoom Out">🧭</button>


  <!-- Tap / Flip -->
  <button class="fab" id="tapBtn">T</button>
  <button class="fab" id="flipBtn">F</button>

  <!-- Chat placeholder -->
  <button class="fab chat" id="chatBtn" title="Chat">💬</button>

  <!-- Stack button + popout (Up / Left / Right) -->
  <div class="stack-wrapper" id="stackWrap">
    <div class="stack-actions" id="stackActions">
      <button class="sbtn" id="stackUpBtn"    title="Stack above">↑</button>
      <button class="sbtn" id="stackLeftBtn"  title="Place left (row)">←</button>
      <button class="sbtn" id="stackRightBtn" title="Place right (row)">→</button>
    </div>
    <button class="fab" id="stackBtn" title="Stack">
      <!-- Two “cards” to read like a stack icon -->
      <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
        <rect x="6"  y="3"  width="10" height="6" rx="2" fill="currentColor" opacity="0.9"/>
        <rect x="8"  y="11" width="10" height="6" rx="2" fill="currentColor" opacity="0.6"/>
      </svg>
    </button>
  </div>

  <!-- Viewer (eye) under the stack button -->
  <div class="view-wrapper" id="viewWrapper">
    <div class="view-actions" id="viewActions">
      <button class="pbtn" data-player="1">1</button>
      <button class="pbtn" data-player="2">2</button>
      <button class="pbtn" data-player="3">3</button>
    </div>
    <button class="fab" id="viewBtn" title="View Player" aria-label="View">
      <!-- eye icon -->
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
        <path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z"></path>
        <circle cx="12" cy="12" r="3"></circle>
      </svg>
    </button>
  </div>
<!-- End Turn -->
<button class="fab" id="endBtn" title="End Turn">END</button>
</div> <!-- end .actions -->




<script>
/* =========================================================
   Refs & state
   ========================================================= */
const $ = s => document.querySelector(s);
const table=$('#table'), world=$('#world'), handZone=$('#zone-hand');
const hint=$('#hint'), hTitle=$('#hTitle'), hMeta=$('#hMeta'), hTxt=$('#hTxt');
let hintSuppressed = false;

let drawPile=[];            // parsed deck, top at end
let zCounter=10;            // z-index counter so newest drags float

const CARD_BACK='https://i.imgur.com/LdOBU1I.jpeg';
const cache=new Map(), imgOk=new Map();

// ========= NEW helpers to (re)build a board/hand/deck from Firestore =========
function clearHand(){
  handCards().forEach(c => c.remove());
  handZone.querySelector('.label').textContent = 'Hand';
}
function spawnCardToHandFromSaved(c){
  // simplified version of spawnCardFromSaved that appends to the hand zone
  const card = document.createElement('div');
  card.className = 'card in-hand';
  card.setAttribute('data-name', c.name || '');
  card.style.zIndex = ++zCounter;

  const body = document.createElement('div'); body.className = 'cardBody';
  const c3 = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img');
  imgF.alt = c.name || ''; imgF.draggable = false; imgF.src = c.img || '';
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img');
  imgB.alt = 'Card back'; imgB.src = CARD_BACK; imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2); c3.appendChild(inner); body.appendChild(c3); card.appendChild(body);
  // no drag wiring needed; the hand carousel owns gesture capture
  handZone.appendChild(card);
  return card;
}

function renderFullState(data){
  // 1) Deck (draw pile)
  drawPile = (data?.Deck || []).map(d => d.name).reverse(); // top is at end
  $('#deckCount').textContent = drawPile.length;

  // 2) Table & zones
  renderSavedStateToWorld(data); // already clears the board & renders Table/Grave/Exile/Commander

  // 3) Hand
  clearHand();
  (data?.Hand || []).forEach(spawnCardToHandFromSaved);
  layoutHand();

  // 4) Make sure we are NOT in viewer mode when resuming a player
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';

  // 5) Camera
  goHome();
}


// Get full Scryfall data for a card element by name and refresh its UI bits.
async function hydrateCardData(card){
  try{
    const name = card.getAttribute('data-name') || (card._data && card._data.name);
    if(!name) return;
    const d = await fetchCard(name);
    card._data = d;

    // If the front image was empty in the saved snapshot, fill it now
    const imgEl = card.querySelector('.face.front img');
    if(imgEl && (!imgEl.src || imgEl.src === window.location.href)) {
      const uris = candidateUris(d);
      await loadFirstWorking(imgEl, uris);
    }
    refreshPTForCard(card);
    if(selectedCard === card) updateHint();
  }catch(e){ /* ignore */ }
}



/* ========== Firebase init + helpers (uses your working project) ========== */
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.appspot.com",
  messagingSenderId: "795274673000",
  appId: "1:795274673000:web:0ea07130e45c72384134dd",
  measurementId: "G-VLW5KLY4FF"
};

let db;
let GAME_ID = 'default-game';   // change if you want per-table sessions

// Gate init so writes/reads wait for Firebase to be ready
let firebaseReady = (async () => {
  try {
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);

    // If your Firestore rules require auth, leave this in.
    // If your rules are public, you can delete this try/catch.
    try { await firebase.auth().signInAnonymously(); }
    catch (e) { console.warn('Anon auth failed (ok if your rules are public):', e.message); }

    db = firebase.firestore();
    console.log('[firebase] ready');
  } catch (err) {
    console.warn('Firebase init error:', err);
    db = undefined;
  }
})();


/* Utility: Serialise one card DOM -> plain object for saving (with extras) */
function serializeCard(card){
  if(!card) return null;
  const rectLeft = parseFloat(card.style.left) || 0;
  const rectTop  = parseFloat(card.style.top)  || 0;

  const name = card.getAttribute('data-name') || (card._data && card._data.name) || '';

  // image url if loaded
  const imgEl = card.querySelector('.face.front img');
  const img = imgEl ? imgEl.src : '';

  const id = card.dataset.cid || (card.dataset.cid = String(Math.random()).slice(2));

  // tap/flip
  const c3 = card.querySelector('.card3d');
  const tapped  = !!(c3 && (c3.style.transform||'').includes('rotate(90deg)'));
  const flipped = card.classList.contains('flipped');

  // extras (manual edits + chosen/type/effect metadata)
  const ex = card._extras || {};
  const extras = {
    addTypes:   Array.from(ex.addTypes   || []),
    addEffects: Array.from(ex.addEffects || []),
    dp: Number.isFinite(ex.dp) ? ex.dp : 0,
    dt: Number.isFinite(ex.dt) ? ex.dt : 0,
    // optional “chosen type” for cards like Metallic Mimic or “choose a creature type”
    chosenType: (ex.chosenType || '') + ''
  };

  return {
    id, name, img,
    x: rectLeft, y: rectTop,
    z: parseInt(card.style.zIndex||10, 10) || 10,
    tapped, flipped,
    extras,
    parent: card.parentElement && card.parentElement.id
      ? card.parentElement.id
      : (card.parentElement === handZone ? 'hand' : 'table')
  };
}


/* Apply saved extras back onto a DOM card (types/effects/manual P/T etc.) */
function applySavedCardExtras(card, saved){
  const ex = (saved && saved.extras) || {};
  const addTypes   = new Set(ex.addTypes || []);
  const addEffects = new Set(ex.addEffects || []);
  const dp = Number.isFinite(ex.dp) ? ex.dp : 0;
  const dt = Number.isFinite(ex.dt) ? ex.dt : 0;
  const chosenType = (ex.chosenType || '') + '';

  card._extras = { addTypes, addEffects, dp, dt, chosenType };

  // If we store a little badge line on the card later, we could render it here.
  // For now, just force a PT refresh (creatures) and update tooltip content if selected.
  refreshPTForCard(card);
  if (selectedCard === card) updateHint();
}

/* Convenience: attach a small gear button bottom-left on a table card */
function attachGearButton(card){
  if(card._gear) return;
  const btn = document.createElement('button');
  btn.className = 'gear-btn';
  btn.title = 'Edit card extras';
  btn.textContent = '⚙️';
  // visual styling (you can keep what you have)
  btn.style.position = 'absolute';
  btn.style.left = '6px';
  btn.style.bottom = '6px';
  btn.style.transform = 'scale(var(--inv-scale))';
  btn.style.transformOrigin = 'bottom left';
  btn.style.border = '1px solid #2b3f63';
  btn.style.background = '#1a2a45';
  btn.style.color = '#cfe1ff';
  btn.style.borderRadius = '10px';
  btn.style.width = '30px';
  btn.style.height = '28px';
  btn.style.fontSize = '14px';
  btn.style.cursor = 'pointer';
  btn.style.boxShadow = '0 8px 20px rgba(106,169,255,.18)';

  btn.addEventListener('click', (e)=>{
    e.stopPropagation();
    openCardEditor(card);
  });

  // ⬇️ KEY CHANGE: put it under .cardBody so it's clickable
  const body = card.querySelector('.cardBody') || card;
  body.appendChild(btn);

  card._gear = btn;
}

function hideAllGears(){
  document.querySelectorAll('.card.show-gear').forEach(c => c.classList.remove('show-gear'));
}
function showGearFor(card){
  if (!card) return;
  // Don’t show in hand
  if (card.parentElement && card.parentElement.id === 'zone-hand') return;
  card.classList.add('show-gear');
}




/* Build the player structure and save to Firestore */
async function savePlayerState(playerId){
  await firebaseReady;                 // ensure db is set
  if(!db) { console.warn('No Firestore (missing config)'); return; }
  try {
    const deck = Array.from(drawPile).slice().reverse().map(name => ({ name }));
    const hand = handCards().map(serializeCard);
    const tableCards = Array.from(world.querySelectorAll('.card'))
      .filter(c => c.parentElement === world)
      .map(serializeCard);

    // NOTE: these zones are currently empty unless you physically append cards into those zone elements
    const graveyard = Array.from(document.querySelectorAll('.graveyard .card')).map(serializeCard);
    const exile     = Array.from(document.querySelectorAll('.exile .card')).map(serializeCard);
    const commander = Array.from(document.querySelectorAll('.commander .card')).map(serializeCard);

    const docRef = db.collection('games').doc(GAME_ID).collection('players').doc(String(playerId));
    await docRef.set({
      Deck: deck,
      Hand: hand,
      Table: tableCards,
      Graveyard: graveyard,
      Exile: exile,
      Commander: commander,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });

    console.log('[save] player', playerId, 'ok');
  } catch(err){ console.error('savePlayerState err', err); }
}

async function loadPlayerState(playerId){
  await firebaseReady;
  if(!db) { console.warn('No Firestore (missing config)'); return null; }
  try {
    const snap = await db.collection('games').doc(GAME_ID).collection('players').doc(String(playerId)).get();
    if(!snap.exists){ console.log('[load] no doc for player', playerId); return null; }
    console.log('[load] player', playerId, 'ok');
    return snap.data();
  } catch(err){ console.error('loadPlayerState err', err); return null; }
}

/* ===== Viewer Mode ===== */
let viewerMode = false;
let viewerPlayer = null;
let localSnapshot = null;   // your table snapshot before entering viewer

function captureLocalSnapshot(){
  const toWorld = sel => Array.from(document.querySelectorAll(sel)).map(serializeCard);
  return {
    Table: toWorld('#world > .card'),
    Graveyard: toWorld('.graveyard .card'),
    Exile: toWorld('.exile .card'),
    Commander: toWorld('.commander .card')
    // (Hand intentionally ignored – we never show it in viewer)
  };
}

function clearBoard(){
  // remove only table/zone cards (not the zones themselves)
  document.querySelectorAll('#world .card').forEach(el => el.remove());
}

function spawnCardToHandFromSaved(c){
  const card = document.createElement('div');
  card.className = 'card in-hand';
  card.setAttribute('data-name', c.name || '');
  card.style.zIndex = ++zCounter;

  const body  = document.createElement('div'); body.className = 'cardBody';
  const c3    = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img'); imgF.alt = c.name || ''; imgF.draggable = false; imgF.src = c.img || '';
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img'); imgB.alt = 'Card back'; imgB.src = CARD_BACK; imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2); c3.appendChild(inner); body.appendChild(c3); card.appendChild(body);
  handZone.appendChild(card);

  // hydrate so the tooltip shows full info when selected in-hand
  hydrateCardData(card);
  return card;
}


function renderSavedStateToWorld(data){
  clearBoard();

  // battlefield
  (data.Table || []).forEach(spawnCardFromSaved);

  // optional zones
  (data.Graveyard || []).forEach(c => {
    const el = spawnCardFromSaved(c);
    document.querySelector('.graveyard').appendChild(el);
  });
  (data.Exile || []).forEach(c => {
    const el = spawnCardFromSaved(c);
    document.querySelector('.exile').appendChild(el);
  });
  (data.Commander || []).forEach(c => {
    const el = spawnCardFromSaved(c);
    document.querySelector('.commander').appendChild(el);
  });

  // one pass to apply global/static buffs after everything exists
  if (typeof recomputeContinuousEffects === 'function') recomputeContinuousEffects();
}


// ========= UPDATED viewer enter/exit so it never forces you back to P1 =========
async function enterViewer(playerId){
  // only snapshot *once* when entering viewer the first time
  if (!viewerMode) localSnapshot = captureLocalSnapshot();

  viewerMode = true;
  viewerPlayer = String(playerId);
  document.body.classList.add('viewer');
  handZone.style.display = 'none';   // hide hand while viewing others

  const data = await loadPlayerState(playerId);
  if (!data){ alert('No saved data for player ' + playerId); exitViewer(); return; }
  renderSavedStateToWorld(data);     // battlefield + zones only (no hand)
  goHome();
}

function exitViewer(){
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';

  if (localSnapshot){
    renderFullState(localSnapshot);  // puts you back *exactly* where you were
  } else {
    clearBoard(); goHome();
  }
}


let hoveredCard=null;       // drives tooltip content
let selectedCard=null;      // target for T/F
const state={ scale:1, tx:0, ty:0 }; // world transform

let selectedGroup = []; // currently highlighted cards (base..selected)

/* Return the slice of a stack from the base (index 0) up to and including `card`.
   If the card isn't stacked, returns [card]. */
function stackSliceFrom(card){
  const base = getStackBase(card);
  if(!base || !base._stack) return [card];
  const idx = base._stack.indexOf(card);
  if(idx < 0) return [card];
  return base._stack.slice(0, idx + 1);
}




/* Hand carousel center index */
let handIndex=0;

/* Stack UI: current mode = null | 'up' | 'left' | 'right'  */
let stackMode=null;

// Which player we are controlling / saving as
let currentPlayer = 1; // default to player 1 (1/2/3)
/* Turn / player count state */
let NUM_PLAYERS = 2;   // default; change via the # popout
let turnPlayer  = 1;   // whose turn it is (1..NUM_PLAYERS)



// Add this helper near other helpers
function goHome(){
  const MIN_ZOOM = 0.35;
  const vw = table.clientWidth, vh = table.clientHeight;

  const worldCards = Array.from(world.querySelectorAll('.card'))
    .filter(c => c.parentElement === world);

  if (!worldCards.length) {
    state.scale = MIN_ZOOM;
    state.tx = vw / 2;
    state.ty = vh / 2;
    applyTransform();
    return;
  }

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  worldCards.forEach(c => {
    const x = parseFloat(c.style.left) || 0;
    const y = parseFloat(c.style.top)  || 0;
    const w = parseFloat(getComputedStyle(c).width)  || 223;
    const h = parseFloat(getComputedStyle(c).height) || 310;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  state.scale = MIN_ZOOM;
  state.tx = (vw / 2) - cx * state.scale;
  state.ty = (vh / 2) - cy * state.scale;
  applyTransform();
}


/* =========================================================
   World transform + anchored hand
   ========================================================= */


   
function applyTransform(){
  world.style.transform=`translate(${state.tx}px, ${state.ty}px) scale(${state.scale})`;
  document.documentElement.style.setProperty('--inv-scale',(1/state.scale).toString());
  positionHandZone();
  layoutHand();           // keep in-hand cards visually stable


}

function positionHandZone(){
  // Visual target rect in screen px…
  const PX_W = Math.min(window.innerWidth*0.92, 980);
  const PX_H = 170;
  const PX_MARGIN_BOTTOM = 10;
  const leftPx = (window.innerWidth - PX_W)/2;
  const topPx  = window.innerHeight - PX_H - PX_MARGIN_BOTTOM;

  // …converted to world coords by inverting current transform.
  handZone.style.width  = (PX_W / state.scale) + 'px';
  handZone.style.height = (PX_H / state.scale) + 'px';
  handZone.style.left   = ((leftPx - state.tx) / state.scale) + 'px';
  handZone.style.top    = ((topPx  - state.ty) / state.scale) + 'px';
}

function sizeHandCardForRole(card){
  // Constant on-screen sizes while in-hand
  const CENTER = {w:190, h:265};
  const SIDE   = {w:150, h:210};
  const isCenter = card.classList.contains('hand-center');
  const target = isCenter ? CENTER : SIDE;
  card.style.width  = (target.w / state.scale) + 'px';
  card.style.height = (target.h / state.scale) + 'px';
}
function restoreTableSize(card){
  // Reset to default table dimensions when leaving the hand
  card.style.width  = 'var(--card-w)';
  card.style.height = 'var(--card-h)';
}


/* =========================================================
   Mouse wheel zoom (desktop) — zoom at cursor
   ========================================================= */
table.addEventListener('wheel', (e)=>{
  // Prevent page scroll; we control zoom here.
  e.preventDefault();

  // Ignore if user is scrolling inside the stack popout or hint.
  if (e.target.closest('#stackWrap .stack-actions') || e.target.closest('#hint')) return;

  // World point under the cursor BEFORE zoom
  const wp = worldPointAt(e.clientX, e.clientY);

  // Normalize delta across devices
  const deltaUnit = (e.deltaMode === 1 ? 15 : (e.deltaMode === 2 ? 120 : 1));
  const delta = e.deltaY * deltaUnit;

  // Trackpads often set ctrlKey during pinch — make that a bit “stronger”
  const speed = e.ctrlKey ? 0.02 : 0.0015;

  // Exponential scale feels smooth and device-agnostic
  const factor = Math.exp(-delta * speed);
  const newScale = clamp(state.scale * factor, 0.35, 2.0);
  if (newScale === state.scale) return;

  state.scale = newScale;

  // Keep the world point under the cursor stationary after zoom
  const r = table.getBoundingClientRect();
  const px = e.clientX - r.left;
  const py = e.clientY - r.top;
  state.tx = px - wp.x * state.scale;
  state.ty = py - wp.y * state.scale;

  applyTransform();
}, { passive:false });


/* ========= Creature P/T badge helpers ========= */

function escapeHTML(s){
  return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
}

// Map a single symbol (no braces) to the mana.css class
function manaClassForSymbol(sym){
  const S = (sym||'').toUpperCase().trim();

  // numbers and single glyphs
  if (/^\d+$/.test(S)) return 'ms-' + S;          // 0..20 etc
  if (['W','U','B','R','G','C','S','X','Y','Z','E'].includes(S)) return 'ms-' + S.toLowerCase();
  if (S === 'T') return 'ms-tap';
  if (S === 'Q') return 'ms-untap';

  // hybrids / phyrexian / 2-color
  if (S.includes('/')){
    const parts = S.split('/');
    if (parts.includes('P')){                      // W/P → ms-pw
      const c = (parts[0]==='P'?parts[1]:parts[0]).toLowerCase();
      return 'ms-p' + c;
    }
    if (parts.includes('2')){                      // 2/W → ms-2w
      const c = (parts[0]==='2'?parts[1]:parts[0]).toLowerCase();
      return 'ms-2' + c;
    }
    return 'ms-' + parts.map(p=>p.toLowerCase()).join(''); // W/U → ms-wu
  }
  return null;
}

// Turn a string containing {...} tokens into icon HTML (keeps everything else escaped)
function renderTextWithIcons(s, withRing=true){
  s = s || '';
  const re = /\{[^}]+\}/g;
  let out = '', i = 0, m;
  while ((m = re.exec(s))){
    out += escapeHTML(s.slice(i, m.index));                 // text before token
    const sym = m[0].slice(1, -1);                          // drop braces
    const cls = manaClassForSymbol(sym);
    out += cls ? `<i class="ms ${withRing?'ms-cost':''} ${cls}"></i>` : escapeHTML(m[0]);
    i = m.index + m[0].length;
  }
  out += escapeHTML(s.slice(i));                            // tail
  return out;                                               // preserves \n (pre-wrap will render them)
}



function isCreatureCard(card){
  const d = card?._data || {};
  const face = (d.card_faces && d.card_faces[0]) || null;
  const type = (d.type_line || face?.type_line || '') + '';
  return /Creature/i.test(type);
}

function basePT(card){
  const d = card?._data || {};
  const face = (d.card_faces && d.card_faces[0]) || null;
  const p = (d.power ?? face?.power);
  const t = (d.toughness ?? face?.toughness);
  const toNum = v => (v==null || v==='*' || isNaN(parseInt(v,10)) ? null : parseInt(v,10));
  return [toNum(p), toNum(t)];
}

function oracleText(card){
  const d = card?._data || {};
  if(d.oracle_text) return d.oracle_text;
  if(d.card_faces){
    return d.card_faces.map(f => [f.name, f.oracle_text].filter(Boolean).join('\n')).join('\n—\n');
  }
  return '';
}

/* Extract sum of +/-N/+/-M seen in lines that look like buffs to a creature.
   We only count lines that include 'gets', 'equipped creature', or 'enchanted creature'
   to avoid picking up random 1/1 token text etc. */
function extractPTDeltaFromText(txt){
  if(!txt) return {dp:0, dt:0, hits:[]};
  let dp=0, dt=0; const hits=[];
  const lines = txt.split(/\r?\n|(?<=\.)\s+/);
  const guard = /(equipped creature|enchanted creature|gets)/i;
  const re = /([+\-]?\d+)\s*\/\s*([+\-]?\d+)/g;
  for(const line of lines){
    if(!guard.test(line)) continue;
    let m; while((m = re.exec(line))){
      const p = parseInt(m[1],10), t = parseInt(m[2],10);
      if(!isNaN(p) && !isNaN(t)){
        dp += p; dt += t; hits.push(`${p>=0?'+':''}${p}/${t>=0?'+':''}${t}`);
      }
    }
  }
  return {dp, dt, hits};
}

function ensurePTBadge(card){
  if(card._ptBadge) return card._ptBadge;
  const el = document.createElement('div');
  el.className = 'pt-badge';
  el.textContent = ''; // filled in by update
  card.appendChild(el);
  card._ptBadge = el;
  return el;
}

function hidePTBadge(card){
  if(card._ptBadge) card._ptBadge.style.display='none';
}

function showPTBadge(card, text, title){
  const el = ensurePTBadge(card);
  el.textContent = text;
  if(title) el.title = title;
  el.style.display='block';
}

/* Recalculate and render the creature's current P/T.
   Looks through all cards stacked above this creature (base._stack[1..]) and
   sums any "+N/+M" buffs in their oracle text. */
function updateCreaturePT(card){
  if(!isCreatureCard(card)){ hidePTBadge(card); return; }

  const [bp, bt] = basePT(card);
  // If base P/T is unknown (e.g. * / *), just show '--/--'
  if(bp==null || bt==null){ showPTBadge(card, '--/--', 'Base P/T unknown'); return; }

  // Sum buffs from attachments in this stack (anything above the base)
  let sumP = 0, sumT = 0; const reasons = [];
  if(card._stack && card._stack.length > 1){
    for(let i=1;i<card._stack.length;i++){
      const att = card._stack[i];
      const {dp, dt, hits} = extractPTDeltaFromText(oracleText(att));
      if(dp || dt){
        sumP += dp; sumT += dt;
        if(hits.length){
          const n = att._data?.name || att.getAttribute('data-name') || 'Attachment';
          reasons.push(`${n}: ${hits.join(', ')}`);
        }
      }
    }
  }

  const finalP = bp + sumP;
  const finalT = bt + sumT;

  const title = reasons.length
    ? `Base ${bp}/${bt}\n` + reasons.join('\n')
    : `Base ${bp}/${bt}`;

  showPTBadge(card, `${finalP}/${finalT}`, title);
}

/* Convenience: when a stack changes or a card loads data, refresh the base creature P/T. */
function refreshPTForCard(card){
  const base = getStackBase(card) || card;
  updateCreaturePT(base);
}




/* =========================================================
   Drawer toggle
   ========================================================= */
$('#hamb').addEventListener('click', ()=>{
  const wrap = $('#drawerWrap');
  const collapsed = wrap.classList.contains('collapsed');
  wrap.classList.toggle('collapsed', !collapsed);
  wrap.classList.toggle('expanded', collapsed);
});


function collapseDrawer(){
  const wrap = $('#drawerWrap');
  wrap.classList.add('collapsed');
  wrap.classList.remove('expanded');
}


/* =========================================================
   Deck parsing + Scryfall fetch
   ========================================================= */
function parseDeck(text){
  // Accept "3 Name" / "Name x3" / "- Name" etc.
  var lines=(text||'').split(/\r?\n/), out=[];
  for (var i=0;i<lines.length;i++){
    var raw=lines[i]; if(!raw) continue;
    var l=raw.replace(/[-\u2022\u2023\u25E6\u2043\u2219*\t]+\s*/g,'').replace(/\s+/g,' ').trim();
    if(!l) continue; if(/^side\s*board\s*:?\s*$/i.test(l)) continue;
    var m, qty=1, name=l;
    if((m=/^(\d+)\s*[x×]?\s+(.+)$/.exec(l))){ qty=parseInt(m[1],10); name=m[2]; }
    else if((m=/^(.+?)\s+[x×]\s*(\d+)$/.exec(l))){ name=m[1]; qty=parseInt(m[2],10); }
    name=name.replace(/^[-•\s]+/,'').trim(); if(!name) continue;
    for(var k=0;k<Math.max(1,qty);k++) out.push(name);
  }
  return out;
}
async function fetchCard(name){
  const key=name.toLowerCase(); if(cache.has(key)) return cache.get(key);
  const url='https://api.scryfall.com/cards/named?'+new URLSearchParams({fuzzy:name});
  const r=await fetch(url,{mode:'cors'}); if(!r.ok) throw new Error('scryfall '+r.status);
  const d=await r.json(); cache.set(key,d); return d;
}
function candidateUris(card){
  const list=[]; function push(u){ if(!u) return; ['large','normal','png','border_crop','art_crop','small'].forEach(k=>u[k]&&list.push(u[k])); }
  if(card && card.image_uris) push(card.image_uris);
  if(card && card.card_faces && card.card_faces[0] && card.card_faces[0].image_uris) push(card.card_faces[0].image_uris);
  return Array.from(new Set(list));
}
function loadFirstWorking(img,uris){
  // Try URLs until one works; memoize failures to skip next time
  return new Promise(res=>{
    let i=0; (function step(){
      if(i>=uris.length){res(false);return;}
      const u=uris[i++]; if(imgOk.get(u)===false){step();return;}
      const t=new Image(); t.crossOrigin='anonymous';
      t.onload=()=>{imgOk.set(u,true); img.src=u; res(true);};
      t.onerror=()=>{imgOk.set(u,false); step();};
      t.src=u;
    })();
  });
}

/* =========================================================
   Tooltip helpers (now anchored above the in-hand center card)
   ========================================================= */

// NEW: parse what a card grants to an equipped/enchanted creature.
function parseGrantedInfoFromOracle(oracle){
  const text = (oracle || '').replace(/\s+/g, ' ').trim();
  const types = new Set();
  const effects = new Set();
  if(!text) return { types: [], effects: [] };

  // --- Additional types (handle “gets ... and is a ... in addition to its other types”)
  // allow anything between "creature" and "is" (e.g., "gets +2/+2 and")
  let m;
  const typesRe = /\b(?:equipped|enchanted)\s+creature\b.*?\bis\s+(?:also\s+)?(?:a|an)?\s*([^.\n]+?)\s+in addition to (?:its|their) other types\b/gi;
  while((m = typesRe.exec(text))){
    let phrase = m[1].trim().replace(/^\s*(?:a|an)\s+/i,'').replace(/\s*\.$/,'');
    // split “Spider Hero and Warrior”, “Zombie, Horror”, “Merfolk/Elf”
    phrase.split(/\s*,\s*|\s+and\s+|\/+/i).forEach(t=>{
      t = t.trim();
      if(t) types.add(t);
    });
  }
  // catch “is every/all creature type(s)”
  if(/\b(?:equipped|enchanted)\s+creature\b.*?\bis\s+(?:also\s+)?(?:every|all)\s+creature\s+type[s]?\b/i.test(text)){
    types.add('every creature type');
  }

  // --- Additional effects (e.g. “has haste and shroud”, “gains flying”, “can’t be blocked”)
  const hasRe   = /\b(?:equipped|enchanted)\s+creature\b.*?\bhas\s+([^.\n]+)/gi;
  const gainsRe = /\b(?:equipped|enchanted)\s+creature\b.*?\bgains\s+([^.\n]+)/gi;
  const cantRe  = /\b(?:equipped|enchanted)\s+creature\b.*?\b(can(?:'t|not)\s+[^.\n]+)/gi;

  function takeList(re){
    let mm;
    while((mm = re.exec(text))){
      // drop reminder text like “(It can’t be …)”
      let listStr = (mm[1] || '').replace(/\([^)]*\)/g,'').trim();
      listStr.split(/\s*,\s*|\s+and\s+|\s+or\s+/i).forEach(k=>{
        k = k.trim().replace(/^(?:have|has|gains)\s+/i,'');
        if(k) effects.add(k);
      });
    }
  }
  takeList(hasRe);
  takeList(gainsRe);
  let mc; while((mc = cantRe.exec(text))){ const clause=(mc[1]||'').trim(); if(clause) effects.add(clause); }

  // prune accidental P/T captures like “+2/+2”
  for(const e of Array.from(effects)){
    if(/^[+\-]?\d+\s*\/\s*[+\-]?\d+$/.test(e)) effects.delete(e);
  }
  return { types: [...types], effects: [...effects] };
}

function grantedFromAttachments(base){
  const types = new Set();
  const effects = new Set();
  if(!base || !base._stack || base._stack.length < 2) return {types:[], effects:[]};

  for(let i=1;i<base._stack.length;i++){
    const att = base._stack[i];

    // 1) parse from the attachment’s oracle text (existing behavior)
    const g = parseGrantedInfoFromOracle( oracleText(att) );
    g.types.forEach(t => types.add(t));
    g.effects.forEach(e => effects.add(e));

    // 2) include manual extras saved via the editor
    if (att._extras){
      (att._extras.addTypes || []).forEach?.(t => types.add(t));
      (att._extras.addEffects || []).forEach?.(e => effects.add(e));
      // chosenType doesn’t auto-grant a *type* to the base creature by itself,
      // so we skip it here.
    }
    // Back-compat if something still writes to _meta
    if (att._meta){
      (att._meta.extraTypes || []).forEach(t => types.add(t));
      (att._meta.extraEffects || []).forEach(e => effects.add(e));
    }
  }
  return { types:[...types], effects:[...effects] };
}



/* ===== Mana → icon HTML ===== */
function escapeHTML(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

function manaClassForSymbol(sym){
  // Normalize like {w/u}, {W/P}, {2/W}, {C}, {S}, numbers, X/Y/Z
  const S = sym.toUpperCase();

  // plain numbers and single symbols
  if (/^\d+$/.test(S)) return 'ms-' + S;
  if (['W','U','B','R','G','C','S','X','Y','Z'].includes(S)) return 'ms-' + S.toLowerCase();

  // hybrids & phyrexian: {W/U}, {2/W}, {W/P}
  if (S.includes('/')){
    const parts = S.split('/');
    // phyrexian (W/P or P/W)
    if (parts.includes('P')){
      const color = (parts[0]==='P' ? parts[1] : parts[0]).toLowerCase();
      return 'ms-p' + color; // e.g. ms-pw
    }
    // two-color hybrid, e.g. W/U → ms-wu
    if (parts.length === 2 && parts[0] !== '2' && parts[1] !== '2'){
      return 'ms-' + parts.map(p=>p.toLowerCase()).join('');
    }
    // 2/color hybrid, e.g. 2/W → ms-2w
    if (parts.includes('2')){
      const color = (parts[0]==='2' ? parts[1] : parts[0]).toLowerCase();
      return 'ms-2' + color;
    }
  }
  // Fallback if some odd symbol appears
  return null;
}

function renderManaCost(cost, withRing=true){
  if(!cost) return '';
  const tokens = cost.match(/\{[^}]+\}/g) || [];
  return tokens.map(tok=>{
    const cls = manaClassForSymbol(tok.slice(1,-1));
    return cls ? `<i class="ms ${withRing ? 'ms-cost' : ''} ${cls}"></i>` : escapeHTML(tok);
  }).join('');
}



// Only sets text; showing/positioning is handled by updateHint()
function fillHintContent(card){
  const d = card?._data || {};
  const face = (d?.card_faces && d.card_faces[0]) || null;

  const mana = (d?.mana_cost || face?.mana_cost || '') || '';
  const type = (d?.type_line  || face?.type_line  || '') || '';

  const p = (d?.power ?? face?.power);
  const t = (d?.toughness ?? face?.toughness);
  const pt = (p != null && t != null) ? `${p}/${t}` : '';
  const loyalty = (d?.loyalty ?? face?.loyalty) ? `Loyalty ${d?.loyalty ?? face?.loyalty}` : '';
  const defense = (d?.defense ?? face?.defense) ? `Defense ${d?.defense ?? face?.defense}` : '';

  hTitle.textContent = d?.name || card?.getAttribute('data-name') || '';
  const stat = pt || loyalty || defense;
  // Build the meta line with icons for the cost
  const manaHTML = renderManaCost(mana, true); // true = show cost ring style
  const parts = [];
  if (manaHTML) parts.push(`<span class="mana-line">${manaHTML}</span>`);
  if (type)     parts.push(escapeHTML(type));
  if (stat)     parts.push(escapeHTML(stat));
  hMeta.innerHTML = parts.join(' • ');

  // Base oracle (single- or multi-faced)
  let oracle = d?.oracle_text || '';
  if (!oracle && d?.card_faces){
    oracle = d.card_faces.map(f => (f.name||'') + "\n" + (f.oracle_text||'')).join("\n—\n");
  }

  // If the selected card itself grants to an equipped/enchanted creature, summarize it.
  let selfExtra = '';
  if(/\b(?:equipped|enchanted)\s+creature\b/i.test(oracle)){
    const g = parseGrantedInfoFromOracle(oracle);
    const lines = [];
    if(g.types.length)   lines.push('Additional Types: '   + g.types.join(', '));
    if(g.effects.length) lines.push('Additional Effects: ' + g.effects.join(', '));
    if(lines.length) selfExtra = '\n\n' + lines.join('\n');
  }

  // If this card is (or is part of) a stacked creature, aggregate what its attachments grant.
  let attachExtra = '';
  const base = getStackBase(card) || card;
  if (isCreatureCard(base) && base._stack && base._stack.length > 1) {
    const agg = grantedFromAttachments(base);
    // (Optionally subtract keywords already on base oracle to avoid dupes.)
    const lines = [];
    if(agg.types.length)   lines.push('Additional Types: '   + agg.types.join(', '));
    if(agg.effects.length) lines.push('Additional Effects: ' + agg.effects.join(', '));
    if(lines.length) attachExtra = '\n\n' + lines.join('\n');
  }

  // --- NEW: include the base creature's own manual extras (from overlay) ---
  let baseManual = '';
  if (base && (base._extras || base._meta)){
    const bTypes   = base._extras ? Array.from(base._extras.addTypes   || []) : (base._meta?.extraTypes   || []);
    const bEffects = base._extras ? Array.from(base._extras.addEffects || []) : (base._meta?.extraEffects || []);
    const blines = [];
    if (bTypes.length)   blines.push('Additional Types: '   + bTypes.join(', '));
    if (bEffects.length) blines.push('Additional Effects: ' + bEffects.join(', '));
    if (blines.length) baseManual = '\n\n' + blines.join('\n');
  }

  // Prefer attachment summary when you’re looking at the creature; otherwise the card’s own grant summary.
  // Also append the base creature's manual extras when viewing the base creature.
  const extra = (isCreatureCard(base) && base===card) ? (attachExtra + baseManual) : selfExtra;

  const bodyHTML  = renderTextWithIcons(oracle || '', true);  // true = ringed style; set false for flat
  const extraHTML = extra ? ('\n\n' + extra) : '';
  hTxt.innerHTML  = bodyHTML + escapeHTML(extraHTML).replace(/\n/g,'<br>');
}





// Position the tooltip centered above the *center in-hand card*.
// Hide it if no selection, or no in-hand center exists.
function updateHint(){
  if (hintSuppressed) {          // <-- added
    hint.style.display = 'none';
    return;
  }
  if(!selectedCard){
    hint.style.display='none';
    return;
  }
  const cards = handCards();
  if(!cards.length){
    hint.style.display='none';
    return;
  }
  const center = cards[handIndex];
  if(!center){
    hint.style.display='none';
    return;
  }

  // Ensure the content matches the *selected* card
  fillHintContent(selectedCard);

  // Compute position above the center hand card
  const r = center.getBoundingClientRect();
  const padY = 10; // gap above the card
  const hintW = parseFloat(getComputedStyle(hint).width) || 320;
  const left = Math.round(r.left + (r.width/2) - (hintW/2));
  // Render off-screen to measure height on first show
  hint.style.display='block';
  const hintH = hint.offsetHeight || 0;

  let top = Math.round(r.top - hintH - padY);
  let clampedLeft = Math.max(8, Math.min(left, window.innerWidth - hintW - 8));
  if(top < 8) top = 8;

  hint.style.left = clampedLeft + 'px';
  hint.style.top  = top + 'px';
}

// Back-compat name used by layoutHand(); just call updateHint()
function syncCenterTooltip(){ updateHint(); }


/* =========================================================
   Stacks — data & layout (adapted from your test file)
   ========================================================= */
let nextStackId=1;

/* Returns the base (bottom) card of a stack for any member, or null. */
function getStackBase(card){
  if(card.dataset.stackBase==='1') return card;
  if(!card.dataset.stackId) return null;
  return document.querySelector(`.card[data-stack-id="${card.dataset.stackId}"][data-stack-base="1"]`);
}
/* Ensure a base has a stack id/array and return the id. */
function initStack(base){
  if(base.dataset.stackId) return base.dataset.stackId;
  const id=String(nextStackId++);
  base.dataset.stackId=id;
  base.dataset.stackBase='1';
  base._stack=[base];
  return id;
}
/* Couple card into base’s stack and lay it out. */
function addToStack(base,card){
  const id=initStack(base);
  card.dataset.stackId=id;
  card.dataset.stackBase='0';
  const arr=base._stack||(base._stack=[base]);
  if(!arr.includes(card)) arr.push(card);
  layoutStack(base);
  refreshPTForCard(base);
  if (selectedCard) updateHint();         
}



/* Decouple a member from a stack. */
function removeFromStack(base, card){
  const arr = base?._stack; if (!arr) return;
  const i = arr.indexOf(card);
  if (i > 0){
    arr.splice(i, 1);

    // If stack now only has the base, clear its stack markers
    if (arr.length === 1) {
      delete base.dataset.stackId;
      delete base.dataset.stackBase;
      delete base._stack;
    } else {
      // Otherwise, re-layout immediately so indices/z-order/positions update
      layoutStack(base);
    }

    // Clean the detached card’s markers
    delete card.dataset.stackId;
    delete card.dataset.stackBase;

    refreshPTForCard(base);
    refreshPTForCard(card);
    if (selectedCard) updateHint();
  }
}


/* Position all members relative to base (vertical “pile”). */
function layoutStack(base){
  const arr=base._stack||[];
  const baseZ=parseInt(base.style.zIndex||10,10);
  const gapY=34; // vertical offset between stacked cards
  const x=parseFloat(base.style.left)||0, y=parseFloat(base.style.top)||0;
  arr.forEach((c,i)=>{
    c.style.left = x + 'px';
    c.style.top  = (i===0 ? y : (y - i*gapY)) + 'px';
    c.style.zIndex = (i===0 ? baseZ : (baseZ - i - 1));
  });
}

/* Simple overlap + “top card at point” helper used on drop. */
function rectsOverlap(a,b){ return !(a.right<b.left || a.left>b.right || a.bottom<b.top || a.top>b.bottom); }
function topCardAtClient(x,y,exclude){
  const els=document.elementsFromPoint(x,y);
  for(const el of els){
    const c=el.closest && el.closest('.card');
    if(c && c!==exclude && c.parentElement===world) return c;
  }
  return null;
}

/* =========================================================
   Selection + table-card drags (now stack-aware)
   ========================================================= */

// Clear all selection outlines and state + hide tooltip
function clearSelection(){
hideAllGears();

  if(selectedGroup && selectedGroup.length){
    selectedGroup.forEach(c => c.classList.remove('selected'));
  }
  selectedGroup = [];
  selectedCard = null;
  hint.style.display='none';
}

// Select `card` and everything below it in its stack (base..card) + show tooltip.
// If the selected card isn't hydrated yet (no _data), fetch it first so the tooltip
// can render mana, type line, oracle text, etc.
function setSelectionFromCard(card){
  hint.style.display = 'none';
  clearSelection();
  selectedCard = card;
  hideAllGears();
showGearFor(selectedCard);

  selectedGroup = stackSliceFrom(card);
  selectedGroup.forEach(c => c.classList.add('selected'));

  // If this card (or the base) doesn’t have Scryfall data yet, hydrate it.
  const base = getStackBase(card) || card;
  const needsHydrate = !base._data || !card._data;

  if (needsHydrate && typeof hydrateCardData === 'function'){
    // Hydrate the specific card the user selected (and the base if different)
    const promises = [];
    if (!card._data) promises.push(hydrateCardData(card));
    if (base !== card && !base._data) promises.push(hydrateCardData(base));

    Promise.all(promises).finally(()=>{
      // Once data is in, refresh the tooltip with rich info
      updateHint();
      // Also refresh P/T badge if this selection affects it
      refreshPTForCard(base);
    });
  } else {
    updateHint();
  }
}


function makeDraggable(card){
  const body=card.querySelector('.cardBody');
  let dragging=false, offX=0, offY=0, draggingBase=null, draggingGroup=null;

  body.addEventListener('pointerdown', e=>{
    e.preventDefault();
    if(card.parentElement===handZone) return; // hand owns swipe/lift gestures

    // Select this card + all below it in its stack
    setSelectionFromCard(card);
hintSuppressed = true;           // <-- added
hint.style.display = 'none';
    // If the pressed card is the *base* of a stack, drag the whole group.
    const base = getStackBase(card) || card;
    if(base===card && base._stack && base._stack.length>1){
      draggingBase = base;
      draggingGroup = [...base._stack];
    }else{
      draggingBase = null;
      draggingGroup = null;
    }

    // Finger offset within the element we actually move
    const targetForOffset = draggingBase || card;
    const r=targetForOffset.getBoundingClientRect();
    offX=e.clientX-r.left; offY=e.clientY-r.top;

    dragging=true; (draggingBase||card).style.zIndex=++zCounter; body.setPointerCapture(e.pointerId);
  });

  body.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const rTable=table.getBoundingClientRect();
    const worldX=(e.clientX-rTable.left-state.tx)/state.scale;
    const worldY=(e.clientY-rTable.top -state.ty)/state.scale;

    if(draggingBase){
      // Move base, then re-layout the stack
      draggingBase.style.left=(worldX-offX/state.scale)+'px';
      draggingBase.style.top =(worldY-offY/state.scale)+'px';
      layoutStack(draggingBase);
    }else{
      // Move single card
      card.style.left=(worldX-offX/state.scale)+'px';
      card.style.top =(worldY-offY/state.scale)+'px';
    }
  });

  function stop(e){
  if(!dragging) return; 
  dragging=false;

  // helper so we don't forget to re-show it
  const showHintIfSelected = ()=>{
    hintSuppressed = false;   // <-- clear suppression
    updateHint();             // <-- show again if selected
  };

  // Hand overlap → goes to hand (no hint wanted)
  const hz = handZone.getBoundingClientRect();
  const cr = card.getBoundingClientRect();
  const overlapHand = !(cr.right<hz.left || cr.left>hz.right || cr.bottom<hz.top || cr.top>hz.bottom);
  if (overlapHand){
    const base=getStackBase(card);
    if(base && base!==card) removeFromStack(base,card);
    moveToHand(card);
    clearSelection();
    return; // (no hint)
  }

  // Stack modes
  if(stackMode){
    const target = topCardAtClient(e.clientX, e.clientY, card);
    if(target){
      if(stackMode==='up'){
        const base = getStackBase(target) || target;
        if(card.parentElement!==world) world.appendChild(card);
        const oldBase = getStackBase(card);
        if(oldBase && oldBase!==base) removeFromStack(oldBase,card);
        addToStack(base, card);
        setSelectionFromCard(card);
        showHintIfSelected();      // <-- add this
        return;
      }
      // left / right row placement
      const tgt3d = target.querySelector('.card3d') || target.querySelector('.cardBody');
      const tapped = (tgt3d && (tgt3d.style.transform||'').includes('rotate(90deg)'));
      const w=parseFloat(getComputedStyle(target).width), h=parseFloat(getComputedStyle(target).height);
      const pad=12, delta=(tapped?h:w)+pad;
      const baseX=parseFloat(target.style.left)||0;
      const baseY=parseFloat(target.style.top)||0;
      const newX = (stackMode==='right') ? (baseX + delta) : (baseX - delta);

      const oldBase = getStackBase(card);
      if(oldBase) removeFromStack(oldBase,card);

      card.style.left=newX+'px';
      card.style.top =baseY+'px';

      setSelectionFromCard(card);
      refreshPTForCard(card);
      showHintIfSelected();        // <-- add this
      return;
    }
  }

// detach-or-restack case… (neighbor-based)
const base = getStackBase(card);
if (base && base !== card && Array.isArray(base._stack)) {
  const arr = base._stack;
  const idx = arr.indexOf(card);
  if (idx > 0) {
    const below = arr[idx - 1];                // the card I’m attached to
    const br = below.getBoundingClientRect();
    const mr = card.getBoundingClientRect();

    // If I'm no longer overlapping the card directly below me, detach.
    if (!rectsOverlap(mr, br)) {
      removeFromStack(base, card);
    } else {
      // still overlapping -> snap back into vertical stack
      layoutStack(base);
      refreshPTForCard(base);
    }
  }
}


  // final: keep selection on table drops so T/F works immediately
  setSelectionFromCard(card);
showHintIfSelected();
// refresh global static effects after moves/stacks
recomputeContinuousEffects();
// persist after drag/drop/stack operations
if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);


}



  body.addEventListener('pointerup', stop);
  body.addEventListener('pointercancel', stop);

  // No hover tooltip anymore — only show when selected
  body.addEventListener('mouseenter', ()=>{
    if(selectedCard===card) updateHint();
  });
  body.addEventListener('mouseleave', ()=>{ /* noop: selection drives tooltip */ });
}


function applyMetallicMimicETB(creatureCard){
  if(!isCreatureCard(creatureCard)) return;
  const myTypes = getEffectiveTypes(creatureCard).map(t=>t.toLowerCase());
  // find any Metallic Mimic with chosenType matching one of my types
  const mimics = Array.from(world.querySelectorAll('.card')).filter(c=>{
    const n = (c._data?.name || c.getAttribute('data-name') || '').toLowerCase();
    return c.parentElement===world && n==='metallic mimic' && (c._meta?.chosenType || '').trim();
  });
  let bonus = 0;
  mimics.forEach(mm=>{
    const chosen = (mm._meta?.chosenType || '').trim().toLowerCase().replace(/s$/,'');
    if(chosen && myTypes.some(t=>t.toLowerCase()===chosen)) bonus += 1;
  });
  if(bonus>0){
    const meta = creatureCard._meta || (creatureCard._meta = { extraTypes:[], extraEffects:[], ptMod:{dp:0,dt:0}, chosenType:'' });
    meta.ptMod.dp = Number(meta.ptMod.dp||0) + bonus;
    meta.ptMod.dt = Number(meta.ptMod.dt||0) + bonus;
    refreshPTForCard(creatureCard);
  }
}


/* Build the DOM for a new card, wire it, and fetch art/text. */
/* Build the DOM for a new card, wire it, fetch art/text, and add the ⚙️ editor */
function spawnCard(name, x=300, y=150){
  const card=document.createElement('div'); 
  card.className='card'; 
  card.style.left=x+'px'; 
  card.style.top=y+'px'; 
  card.style.zIndex=++zCounter; 
  card.setAttribute('data-name',name);

  const body=document.createElement('div'); 
  body.className='cardBody';

  const c3=document.createElement('div'); 
  c3.className='card3d';

  const inner=document.createElement('div'); 
  inner.className='inner';

  const f1=document.createElement('div'); 
  f1.className='face front'; 
  const imgF=document.createElement('img'); 
  imgF.alt=name; 
  imgF.draggable=false; 
  f1.appendChild(imgF);

  const f2=document.createElement('div'); 
  f2.className='face back'; 
  const imgB=document.createElement('img'); 
  imgB.alt='Card back'; 
  imgB.src=CARD_BACK; 
  imgB.draggable=false; 
  f2.appendChild(imgB);

  inner.appendChild(f1); 
  inner.appendChild(f2); 
  c3.appendChild(inner); 
  body.appendChild(c3); 
  card.appendChild(body);

  // wire drag
  makeDraggable(card); 
  world.appendChild(card);

  // add the gear
  attachGearButton(card);

  // default extras container
  if (!card._extras) card._extras = { addTypes:new Set(), addEffects:new Set(), dp:0, dt:0, chosenType:'' };

  // fetch art + oracle text
  fetchCard(name).then(async d=>{
    card._data=d;
    const uris=candidateUris(d);
    await loadFirstWorking(imgF,uris);

    // P/T badge if creature
    refreshPTForCard(card);

    // Only update tooltip if this card is currently selected
    if(selectedCard===card) updateHint();

    // OPTIONAL one-liner: handle ETB choose-type prompts (e.g., Metallic Mimic)
    // If you don’t want this, comment the next call out.
    maybePromptChooseTypeOnETB(card);

  }).catch(()=>{});

  return card;
}


/* =========================
   Manual meta helpers + editor
   ========================= */

/* Apply saved meta fields to a card, then refresh visuals */
function applySavedMeta(card, saved){
  if(!card) return;
  const m = card._meta || (card._meta = { extraTypes:[], extraEffects:[], ptMod:{dp:0,dt:0}, chosenType:'' });
  if(saved){
    m.extraTypes   = Array.isArray(saved.extraTypes)   ? saved.extraTypes : (typeof saved.extraTypes==='string' ? saved.extraTypes.split(',').map(s=>s.trim()).filter(Boolean) : []);
    m.extraEffects = Array.isArray(saved.extraEffects) ? saved.extraEffects : (typeof saved.extraEffects==='string' ? saved.extraEffects.split(',').map(s=>s.trim()).filter(Boolean) : []);
    if(saved.ptMod && (typeof saved.ptMod.dp==='number' || typeof saved.ptMod.dt==='number')){
      m.ptMod = { dp: Number(saved.ptMod.dp||0), dt: Number(saved.ptMod.dt||0) };
    }
    if(typeof saved.chosenType === 'string') m.chosenType = saved.chosenType.trim();
  }
  // refresh P/T & tooltip
  refreshPTForCard(card);
  if(selectedCard===card) updateHint();
}

/* Return all effective creature types for a card: oracle types + manual extra types */
function getEffectiveTypes(card){
  const d = card?._data || {};
  const face = (d.card_faces && d.card_faces[0]) || null;
  const typeLine = (d.type_line || face?.type_line || '') + '';
  // very coarse extraction of types: split before "—" and take words
  const main = typeLine.split('—')[0] || '';
  const fromOracle = main.split(/\s+/).filter(Boolean); // includes super/sub types; OK for heuristics
  const extras = (card._meta?.extraTypes || []).slice();
  // Metallic Mimic style chosen type can be included as well
  if(card._meta?.chosenType) extras.push(card._meta.chosenType);
  // Unique, basic normalize (singularize naive: Zombies -> Zombie)
  const norm = t => t.replace(/s$/i,'');
  return Array.from(new Set(fromOracle.concat(extras).map(norm)));
}

/* Very small rule engine: anthem-like static buffs
   Looks for text like "Other Zombies you control get +1/+1". */
function recomputeContinuousEffects(){
  // 1) compute per-creature lord buffs
  const tableCreatures = Array.from(world.querySelectorAll('.card')).filter(c => c.parentElement===world && isCreatureCard(c));
  // Pre-parse possible lords
  const lords = Array.from(world.querySelectorAll('.card')).filter(c => c.parentElement===world);
  const lordSpecs = lords.map(c=>{
    const txt = oracleText(c);
    // match: Other X you control get +n/+m
    // X can be a single word like Zombies, Vampires, Goblins
    const re = /Other\s+([A-Za-z]+)s?\s+you\s+control\s+get\s*\+(\d+)\s*\/\s*\+(\d+)/ig;
    const hits = [];
    let m;
    while((m=re.exec(txt))){
      hits.push({ type: m[1].replace(/s$/i,''), dp: parseInt(m[2],10)||0, dt: parseInt(m[3],10)||0, source:c });
    }
    return { card:c, hits };
  });

  // 2) for each creature, sum buffs from all other lords that match type
  tableCreatures.forEach(crea=>{
    // base refresh (includes equipment parsing) first
    refreshPTForCard(crea);

    // manual pt mod
    const meta = crea._meta || { ptMod:{dp:0,dt:0} };
    const manualDP = Number(meta.ptMod?.dp||0);
    const manualDT = Number(meta.ptMod?.dt||0);

    // then anthem overlays
    const myTypes = getEffectiveTypes(crea);
    let sumDP = manualDP, sumDT = manualDT;

    lordSpecs.forEach(spec=>{
      if(!spec.hits.length) return;
      // "Other" means the lord should not buff itself even if it matches
      if(spec.card === crea) return;
      spec.hits.forEach(h=>{
        if(myTypes.some(t => t.toLowerCase() === h.type.toLowerCase())){
          sumDP += h.dp;
          sumDT += h.dt;
        }
      });
    });

    // show final overlay as base+equip already done by refreshPTForCard; we add manual+anthem on top visually
    // easiest: append text to the PT badge title and re-render with a synthetic add
    const base = getStackBase(crea) || crea;
    // We piggyback on updateCreaturePT output but we want to show final including manual + anthem.
    // Read the badge current text as final-from-equipment, add our sum on top:
    const el = base._ptBadge || ensurePTBadge(base);
    const curr = el.textContent || '';
    const mm = curr.match(/(\d+)\s*\/\s*(\d+)/);
    if(mm){
      const p = parseInt(mm[1],10)||0, t=parseInt(mm[2],10)||0;
      const fp = p + manualDP; 
      const ft = t + manualDT;
      el.textContent = `${fp}/${ft}`;
      let reasons = [`Manual ${manualDP>=0?'+':''}${manualDP}/${manualDT>=0?'+':''}${manualDT}`];
      // summarize anthem if any
      const anthemSum = (sumDP - manualDP) || (sumDT - manualDT);
      if(anthemSum){
        reasons.push(`Anthem ${ (sumDP-manualDP)>=0?'+':'' }${sumDP-manualDP}/${ (sumDT-manualDT)>=0?'+':'' }${sumDT-manualDT}`);
      }
      el.title = (el.title ? (el.title + '\n') : '') + reasons.join('\n');
      el.style.display='block';
    }
  });
}

/* Editor overlay for one card */
function openCardEditor(card){
  // remove any existing
  const old = document.getElementById('cardMetaEditor');
  if(old) old.remove();

  const overlay = document.createElement('div');
  overlay.id='cardMetaEditor';
  overlay.style.position='fixed';
  overlay.style.inset='0';
  overlay.style.background='rgba(0,0,0,.72)';
  overlay.style.zIndex='99999';
  overlay.style.display='flex';
  overlay.style.alignItems='center';
  overlay.style.justifyContent='center';
  overlay.addEventListener('pointerdown',(e)=>{ if(e.target===overlay) overlay.remove(); });

  const panel = document.createElement('div');
  panel.style.width='min(520px, 92vw)';
  panel.style.maxHeight='86vh';
  panel.style.overflow='auto';
  panel.style.background='#0b0f15';
  panel.style.border='1px solid #24324a';
  panel.style.borderRadius='14px';
  panel.style.padding='16px';
  panel.style.boxShadow='0 18px 48px rgba(0,0,0,.6)';
  panel.style.color='#e7e9ee';
  panel.addEventListener('pointerdown', e=>e.stopPropagation());

  const title = document.createElement('h3');
  title.textContent = (card._data?.name) || card.getAttribute('data-name') || 'Card';
  title.style.margin='0 0 8px';
  panel.appendChild(title);

  const row = (label, inputEl) => {
    const wrap = document.createElement('div');
    wrap.style.margin='10px 0';
    const lab = document.createElement('div');
    lab.textContent = label;
    lab.style.fontSize='12px';
    lab.style.opacity='0.85';
    lab.style.margin='0 0 4px';
    wrap.appendChild(lab);
    wrap.appendChild(inputEl);
    return wrap;
  };

  const mkInput = () => {
    const i = document.createElement('input');
    i.type='text';
    i.style.width='100%';
    i.style.border='1px solid #24324a';
    i.style.borderRadius='10px';
    i.style.background='#0a0f16';
    i.style.color='#e7e9ee';
    i.style.padding='10px';
    i.style.font='14px/1.4 ui-monospace, Menlo, Consolas, monospace';
    return i;
  };

  const iTypes = mkInput();
  iTypes.placeholder='Comma-separated (e.g., Zombie, Warrior)';
  iTypes.value = (card._meta?.extraTypes||[]).join(', ');

  const iEffects = mkInput();
  iEffects.placeholder='Comma-separated (e.g., menace, shroud)';
  iEffects.value = (card._meta?.extraEffects||[]).join(', ');

  const rowPT = document.createElement('div');
  rowPT.style.display='grid';
  rowPT.style.gridTemplateColumns='1fr 1fr';
  rowPT.style.gap='10px';
  const iP = mkInput(); iP.placeholder='+/- Power delta'; iP.value = String(card._meta?.ptMod?.dp||0);
  const iT = mkInput(); iT.placeholder='+/- Toughness delta'; iT.value = String(card._meta?.ptMod?.dt||0);
  rowPT.appendChild(iP); rowPT.appendChild(iT);

  const iChosen = mkInput();
  iChosen.placeholder='Chosen Type (for “choose a type” cards)';
  iChosen.value = card._meta?.chosenType || '';

  const btns = document.createElement('div');
  btns.style.display='flex';
  btns.style.gap='8px';
  btns.style.marginTop='12px';

  const save = document.createElement('button');
  save.textContent='Save';
  save.className='pill';
  save.style.cursor='pointer';
save.addEventListener('click', ()=>{
  // 1) Keep _meta (back-compat with older code)
  const meta = card._meta || (card._meta = { extraTypes:[], extraEffects:[], ptMod:{dp:0,dt:0}, chosenType:'' });
  meta.extraTypes  = iTypes.value.split(',').map(s=>s.trim()).filter(Boolean);
  meta.extraEffects= iEffects.value.split(',').map(s=>s.trim()).filter(Boolean);
  meta.ptMod       = { dp:Number(iP.value||0), dt:Number(iT.value||0) };
  meta.chosenType  = iChosen.value.trim();

  // 2) NEW: also mirror into _extras (this is what serializeCard persists)
  const ex = card._extras || (card._extras = { addTypes:new Set(), addEffects:new Set(), dp:0, dt:0, chosenType:'' });
  ex.addTypes   = new Set(meta.extraTypes);
  ex.addEffects = new Set(meta.extraEffects);
  ex.dp         = meta.ptMod.dp;
  ex.dt         = meta.ptMod.dt;
  ex.chosenType = meta.chosenType;

  // 3) Refresh visuals/tooltips and recompute buffs, then persist
  refreshPTForCard(card);
  recomputeContinuousEffects?.();
  if (selectedCard === card) updateHint();
  if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);

  overlay.remove();
});



  const close = document.createElement('button');
  close.textContent='Close';
  close.className='pill';
  close.style.cursor='pointer';
  close.addEventListener('click', ()=>overlay.remove());

  panel.appendChild(row('Additional Types', iTypes));
  panel.appendChild(row('Additional Effects', iEffects));
  panel.appendChild(rowPT);
  panel.appendChild(row('Chosen Type', iChosen));
  btns.appendChild(save);
  btns.appendChild(close);
  panel.appendChild(btns);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);
}



/* Build a table card from a saved snapshot object */
function spawnCardFromSaved(c){
  // build DOM
  const card = document.createElement('div');
  card.className = 'card';
  card.style.left   = (c.x || 0) + 'px';
  card.style.top    = (c.y || 0) + 'px';
  card.style.zIndex = (c.z || 10);
  if (c.name) card.setAttribute('data-name', c.name);

  const body  = document.createElement('div'); body.className = 'cardBody';
  const c3    = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img');
  imgF.alt = c.name || '';
  imgF.draggable = false;
  if (c.img) imgF.src = c.img;   // fast path: use saved art if present
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img');
  imgB.alt = 'Card back';
  imgB.src = CARD_BACK;
  imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2);
  c3.appendChild(inner);
  body.appendChild(c3);
  card.appendChild(body);

  // restore flip/tap
  if (c.flipped) card.classList.add('flipped');
  if (c.tapped)  c3.style.transform = 'rotate(90deg)';

  // add to world first so sizing/transform math is valid
  world.appendChild(card);

  // gear button for the editor
  if (typeof attachGearButton === 'function') attachGearButton(card);

  // restore saved extras/meta (types/effects/ptMod/chosenType) if you updated serializeCard to store them
  if (typeof applySavedCardExtras === 'function') applySavedCardExtras(card, c);

  // wire dragging unless we’re explicitly in read-only viewer
  if (!viewerMode && typeof makeDraggable === 'function') makeDraggable(card);

  // Hydrate with Scryfall so tooltips/PT/oracle are correct (and art if none was saved)
  if (typeof hydrateCardData === 'function') {
    // after hydration, re-evaluate buffs if it’s a creature
    Promise.resolve(hydrateCardData(card)).then(()=>{
      if (typeof isCreatureCard === 'function' && typeof recomputeContinuousEffects === 'function'){
        if (isCreatureCard(card)) recomputeContinuousEffects();
      }
    });
  }

  return card;
}



/* =========================================================
   Hand zone (carousel + move in/out)
   ========================================================= */
function handCards(){ return Array.from(handZone.querySelectorAll('.card')); }

function moveToHand(card){
  // If card belongs to a stack, cleanly decouple
  const base=getStackBase(card);
  if(base && base!==card) removeFromStack(base,card);

  handZone.appendChild(card);
  card.classList.add('in-hand');
  card.classList.remove('hand-small','hand-left','hand-right','hand-center','hand-hidden','hand-l2','hand-l3','hand-r2','hand-r3','hand-slot');

  // Clear any absolute position (hand layout owns it)
  card.style.left=''; card.style.top=''; card.style.zIndex=++zCounter;

  // IMPORTANT: clear any inline transform on the interactive child so hand sizing works
  const body=card.querySelector('.cardBody'); if(body) body.style.transform='';
  const card3d=card.querySelector('.card3d'); // keep taps/rotations as-is — hand scales the wrapper element

  layoutHand();
  if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);
}


function removeFromHand(card){
  if(card.parentElement!==handZone) return;
  card.classList.remove('in-hand','hand-small','hand-left','hand-right','hand-center','hand-hidden','hand-l2','hand-l3','hand-r2','hand-r3','hand-slot');
  restoreTableSize(card);
}

function layoutHand(){
  const cards = handCards();
  if(cards.length===0){ handZone.querySelector('.label').textContent='Hand'; return; }
  if(handIndex >= cards.length) handIndex = cards.length-1;
  if(handIndex < 0) handIndex = 0;
  handZone.querySelector('.label').textContent='';

  const n = cards.length;
  const norm = k => (k + n) % n;

  const l1 = norm(handIndex - 1), l2 = norm(handIndex - 2), l3 = norm(handIndex - 3);
  const r1 = norm(handIndex + 1), r2 = norm(handIndex + 2), r3 = norm(handIndex + 3);

  cards.forEach((c,i)=>{
    c.classList.remove('hand-small','hand-left','hand-right','hand-center','hand-hidden','hand-l2','hand-l3','hand-r2','hand-r3','hand-slot');
    c.classList.add('in-hand');

    if(i===handIndex){
      c.classList.add('hand-center','hand-slot');
      attachCenterHandDrag(c); // only center has swipe/lift
    }else if(i===l1){ c.classList.add('hand-left','hand-small','hand-slot'); }
    else if(i===r1){ c.classList.add('hand-right','hand-small','hand-slot'); }
    else if(i===l2){ c.classList.add('hand-l2','hand-small','hand-slot'); }
    else if(i===l3){ c.classList.add('hand-l3','hand-small','hand-slot'); }
    else if(i===r2){ c.classList.add('hand-r2','hand-small','hand-slot'); }
    else if(i===r3){ c.classList.add('hand-r3','hand-small','hand-slot'); }
    else { c.classList.add('hand-hidden'); }

    sizeHandCardForRole(c);
  });

  syncCenterTooltip();
}

function rotateHand(dir){
  const n = handCards().length; if(n<=1) return;
  handIndex = (handIndex + dir + n) % n;
  layoutHand();

  // NEW: when rotating, unselect any table selection and
  // select the current center hand card so its tooltip appears.
  const center = handCards()[handIndex];
  if(center){ setSelectionFromCard(center); }
  else { clearSelection(); }
}

/* Center-card swipe/lift (bind to .cardBody for reliable hits) */
function attachCenterHandDrag(card){
  if(card._handBound) return;

  const body = card.querySelector('.cardBody');
  let start=null, lifted=false;

  function down(e){
    if(card.parentElement!==handZone) return;
    e.preventDefault();
    start={x:e.clientX,y:e.clientY};
    lifted=false;
    body.setPointerCapture(e.pointerId);
  }
  function move(e){
    if(!start) return;
    if(card.parentElement!==handZone){ start=null; return; }

    const dx=e.clientX-start.x, dy=e.clientY-start.y;

    // Horizontal swipe → rotate carousel
    if(!lifted && Math.abs(dx)>40 && Math.abs(dx)>Math.abs(dy)){
      // Clear any table selection immediately, then rotate (which selects center)
      clearSelection();
      rotateHand(dx<0 ? +1 : -1);
      start={x:e.clientX,y:e.clientY};
      return;
    }

    // Up swipe → lift into world
    if(!lifted && dy<-30 && Math.abs(dy)>Math.abs(dx)){
      removeFromHand(card);
world.appendChild(card);

// Select card + everything below it in any stack (currently just itself)
setSelectionFromCard(card);

// re-run lords/anthems when a new permanent hits the table
recomputeContinuousEffects();


      // Place under finger (world coords)
      const r=table.getBoundingClientRect();
      const worldX=(e.clientX - r.left - state.tx)/state.scale;
      const worldY=(e.clientY - r.top  - state.ty)/state.scale;
      const defW=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))||223;
      const defH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))||310;
const LIFT_Y_OFFSET = 1000;
card.style.left = (worldX - defW/2) + 'px';
card.style.top  = (worldY - LIFT_Y_OFFSET - defH/2) + 'px';
      card.style.zIndex=++zCounter;

      lifted=true;
      layoutHand(); // also refreshes tooltip to new center
    }
  }
  function up(){ start=null; }

  card.addEventListener('pointerdown',down);
  card.addEventListener('pointermove',move);
  card.addEventListener('pointerup',up);
  card.addEventListener('pointercancel',up);
  card._handBound=true;
}



/* =========================================================
   Topbar (load/shuffle/draw)
   ========================================================= */
$('#loadBtn').addEventListener('click', ()=>{
  const names=parseDeck($('#deckIn').value);
  if(!names.length){ alert('No cards parsed. Paste your deck and tap Load again.'); return;}
  drawPile=names.reverse();
  $('#deckCount').textContent=drawPile.length;

  collapseDrawer();          // <-- hide the input
  // no alert anymore
});

$('#shuffleBtn').addEventListener('click', ()=>{
  for(let i=drawPile.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=drawPile[i]; drawPile[i]=drawPile[j]; drawPile[j]=t; }
  alert('Shuffled.');
});
function drawToHand(n){
  if(!drawPile.length) return;
  for(let i=0;i<n;i++){
    const name=drawPile.pop(); if(!name) break;
    $('#deckCount').textContent=drawPile.length;
    const c=spawnCard(name,0,0);
    moveToHand(c);
	    // persist after draw
    if (typeof currentPlayer !== 'undefined') savePlayerState(currentPlayer);

  }
}
$('#draw7').addEventListener('click', ()=>drawToHand(7));
$('#draw1').addEventListener('click', ()=>drawToHand(1));

/* =========================================================
   Tap / Flip  (T acts on base..selected slice)
   ========================================================= */

// Toggle tap state for a single card
function toggleTapOne(card){
  const t = card.querySelector('.card3d');
  const tapped = (t.style.transform || '').includes('rotate(90deg)');
  t.style.transform = tapped ? 'rotate(0deg)' : 'rotate(90deg)';
}

// Flip still acts on just the selected card
function toggleFlip(card){ card.classList.toggle('flipped'); }

// T: tap/untap the slice from stack base up through the selected card
$('#tapBtn').addEventListener('click', ()=>{
  if(!selectedCard) return;
  const group = stackSliceFrom(selectedCard);
  group.forEach(toggleTapOne);
});

// F: flip the selected card only (unchanged behavior)
$('#flipBtn').addEventListener('click', ()=>{
  if(selectedCard) toggleFlip(selectedCard);
});



/* =========================================================
   Chat + Stack UI + Compass (home) + Player + View
   ========================================================= */

/* ---------- minimal helpers so this block is drop-in ---------- */
function clearHand(){
  handCards().forEach(c => c.remove());
  handZone.querySelector('.label').textContent = 'Hand';
}
function spawnCardToHandFromSaved(c){
  const card = document.createElement('div');
  card.className = 'card in-hand';
  card.setAttribute('data-name', c.name || '');
  card.style.zIndex = ++zCounter;

  const body = document.createElement('div'); body.className = 'cardBody';
  const c3 = document.createElement('div'); c3.className = 'card3d';
  const inner = document.createElement('div'); inner.className = 'inner';

  const f1 = document.createElement('div'); f1.className = 'face front';
  const imgF = document.createElement('img'); imgF.alt = c.name || ''; imgF.draggable = false; imgF.src = c.img || '';
  f1.appendChild(imgF);

  const f2 = document.createElement('div'); f2.className = 'face back';
  const imgB = document.createElement('img'); imgB.alt = 'Card back'; imgB.src = CARD_BACK; imgB.draggable = false;
  f2.appendChild(imgB);

  inner.appendChild(f1); inner.appendChild(f2); c3.appendChild(inner); body.appendChild(c3); card.appendChild(body);
  makeDraggable(card);  
  handZone.appendChild(card);
  return card;
}
function renderFullState(data){
  drawPile = (data?.Deck || []).map(d => d.name).reverse();
  $('#deckCount').textContent = drawPile.length;

  renderSavedStateToWorld(data);   // battlefield + zones
  clearHand();
  (data?.Hand || []).forEach(spawnCardToHandFromSaved);
  layoutHand();

  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';
  goHome();
}


function captureLocalSnapshot(){
  return {
    Deck: drawPile.slice().reverse().map(name => ({name})),
    Hand: handCards().map(serializeCard),
    Table: Array.from(world.querySelectorAll('.card')).filter(c => c.parentElement===world).map(serializeCard),
    Graveyard: Array.from(document.querySelectorAll('.graveyard .card')).map(serializeCard),
    Exile: Array.from(document.querySelectorAll('.exile .card')).map(serializeCard),
    Commander: Array.from(document.querySelectorAll('.commander .card')).map(serializeCard)
  };
}
async function enterViewer(playerId){
  if (!viewerMode) localSnapshot = captureLocalSnapshot();
  viewerMode = true;
  viewerPlayer = String(playerId);
  document.body.classList.add('viewer');
  handZone.style.display = 'none';

  const data = await loadPlayerState(playerId);
  if (!data){ alert('No saved data for player '+playerId); exitViewer(); return; }
  renderSavedStateToWorld(data); // no hand
  goHome();
}
function exitViewer(){
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';
  if (localSnapshot) renderFullState(localSnapshot); else { clearBoard(); clearHand(); drawPile=[]; $('#deckCount').textContent='0'; goHome(); }
}

// === helper: resume current player's saved state ===
async function resumeOrInitForPlayer(playerId){
  // leave viewer mode if active
  viewerMode = false;
  viewerPlayer = null;
  document.body.classList.remove('viewer');
  handZone.style.display = '';

  const data = await loadPlayerState(String(playerId));
  if (data && ((data.Table?.length||0) + (data.Hand?.length||0) + (data.Deck?.length||0) > 0)) {
    renderFullState(data);   // rebuild Deck/Hand/Table + zones
  } else {
    // Fresh state: clear world + hand + deck count
    world.querySelectorAll('.card').forEach(el => el.remove());
    handCards().forEach(el => el.remove());
    drawPile = [];
    document.getElementById('deckCount').textContent = '0';
    layoutHand();
    goHome();
  }
}

// Boot: after Firebase is ready, resume the default currentPlayer
firebaseReady.then(()=> resumeOrInitForPlayer(currentPlayer));


/* ========== Player / Viewer button wiring ========== */
// (keep your existing consts that query the DOM for player/view controls)
const playerWrapper = document.getElementById('playerWrapper');
const playerBtn = document.getElementById('playerBtn');
const playerActions = document.getElementById('playerActions');
const playerActionButtons = Array.from(playerActions.querySelectorAll('.pbtn'));

const viewWrapper = document.getElementById('viewWrapper');
const viewBtn = document.getElementById('viewBtn');
const viewActions = document.getElementById('viewActions');
const viewActionButtons = Array.from(viewActions.querySelectorAll('.pbtn'));

// Toggle open/close for the pickers
playerBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  playerWrapper.classList.toggle('open');
});

viewBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  // If already in viewer mode, clicking the eye exits viewer—no auto-swap
  if (viewerMode){ exitViewer(); return; }
  viewWrapper.classList.toggle('open');
});

// Select player as "me" (load their saved state immediately)
playerActionButtons.forEach(b=>{
  b.addEventListener('click', async ()=>{
    const p = Number(b.getAttribute('data-player'));
    if (String(currentPlayer) === String(p)) {
      playerWrapper.classList.remove('open');
      return;
    }
    // highlight UI
    playerActionButtons.forEach(x=>x.classList.remove('on'));
    b.classList.add('on');

    currentPlayer = p;

    // resume that player's saved state (deck/hand/table)
    await resumeOrInitForPlayer(currentPlayer);

    playerWrapper.classList.remove('open');
  });
});

// Eye → view another player's field (no hands, no auto swap back)
viewActionButtons.forEach(b=>{
  b.addEventListener('click', async ()=>{
    const p = b.getAttribute('data-player');
    viewActionButtons.forEach(x=>x.classList.remove('on'));
    b.classList.add('on');
    viewWrapper.classList.remove('open');
    await enterViewer(p);
  });
});


/* ========== Simple overlay viewer (shows saved zones for a player) ========== */
function showPlayerOverlay(data, playerId){
  const existing = document.getElementById('playerOverlay');
  if(existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'playerOverlay';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(2,6,10,0.85)';
  overlay.style.color = 'white';
  overlay.style.zIndex = 9999;
  overlay.style.padding = '22px';
  overlay.style.overflow = 'auto';
  overlay.style.fontFamily = 'system-ui, sans-serif';

  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.style.position = 'fixed';
  closeBtn.style.right = '18px';
  closeBtn.style.top = '18px';
  closeBtn.style.zIndex = 10001;
  closeBtn.className = 'pill';
  closeBtn.addEventListener('click', ()=>overlay.remove());
  overlay.appendChild(closeBtn);

  const title = document.createElement('h2');
  title.textContent = `Player ${playerId} — Saved View`;
  overlay.appendChild(title);

  const deckCount = (data.Deck && data.Deck.length) || 0;
  const pDeck = document.createElement('div');
  pDeck.textContent = `Deck (${deckCount})`;
  pDeck.style.marginBottom = '8px';
  overlay.appendChild(pDeck);

  function appendZone(name, arr){
    const zoneWrap = document.createElement('div');
    zoneWrap.style.margin = '10px 0 20px 0';
    const h = document.createElement('h3');
    h.textContent = name + ` (${(arr && arr.length)||0})`;
    zoneWrap.appendChild(h);

    const grid = document.createElement('div');
    grid.style.display = 'flex';
    grid.style.flexWrap = 'wrap';
    grid.style.gap = '10px';
    grid.style.marginTop = '8px';

    (arr || []).forEach(card=>{
      const cardEl = document.createElement('div');
      cardEl.style.width = '120px';
      cardEl.style.border = '1px solid rgba(255,255,255,0.08)';
      cardEl.style.borderRadius = '8px';
      cardEl.style.padding = '6px';
      cardEl.style.background = 'rgba(255,255,255,0.02)';
      cardEl.style.fontSize = '12px';
      cardEl.style.boxSizing = 'border-box';

      const img = document.createElement('img');
      img.src = card.img || '';
      img.alt = card.name || '';
      img.style.width = '100%';
      img.style.height = '80px';
      img.style.objectFit = 'cover';
      img.style.borderRadius = '6px';
      img.loading = 'lazy';
      cardEl.appendChild(img);

      const nm = document.createElement('div');
      nm.textContent = card.name || '(unknown)';
      nm.style.marginTop = '6px';
      nm.style.whiteSpace = 'nowrap';
      nm.style.overflow = 'hidden';
      nm.style.textOverflow = 'ellipsis';
      cardEl.appendChild(nm);

      if(typeof card.x !== 'undefined' || typeof card.y !== 'undefined'){
        const meta = document.createElement('div');
        meta.textContent = `x:${Math.round(card.x||0)} y:${Math.round(card.y||0)}`;
        meta.style.fontSize = '11px';
        meta.style.opacity = '0.8';
        meta.style.marginTop = '4px';
        cardEl.appendChild(meta);
      }

      grid.appendChild(cardEl);
    });

    zoneWrap.appendChild(grid);
    overlay.appendChild(zoneWrap);
  }

  appendZone('Table', data.Table);
  appendZone('Hand', data.Hand);
  appendZone('Graveyard', data.Graveyard);
  appendZone('Exile', data.Exile);
  appendZone('Commander', data.Commander);

  document.body.appendChild(overlay);
}

/* Close overlays when pressing Escape */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){
    const el = document.getElementById('playerOverlay');
    if(el) el.remove();
    playerWrapper.classList.remove('open');
    viewWrapper.classList.remove('open');
  }
});

/* # and + buttons (placeholder) and END */
/* ===== Amount of players, Adding Tokens, and Ending Turns ===== */
// Toggle the # popout
document.getElementById('numBtn').addEventListener('click', ()=>{
  document.getElementById('numWrapper').classList.toggle('open');
});

// Pick 1/2/3 players, close, and reset turn to Player 1 (SERVER SOURCE OF TRUTH)
document.querySelectorAll('#numActions .pbtn').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const n = parseInt(btn.dataset.n, 10);
    NUM_PLAYERS = Math.max(1, Math.min(3, n));
    turnPlayer  = 1; // keep local in sync after we write

    document.getElementById('numWrapper').classList.remove('open');
    showToast(`Players: ${NUM_PLAYERS} • Turn: P${turnPlayer}`);

    // >>> write to Firestore so both phones agree
    try{
      await writeTurnToServer(turnPlayer, NUM_PLAYERS);
    }catch(e){ console.warn('[turn] write failed:', e); }
  });
});


// Sword Combat stub
// Sword button (Battle picker): read server turn first, THEN choose
document.getElementById('plusBtn')?.addEventListener('click', async ()=>{
  try{
    const data = await readCombatFresh(); // force server
    const serverTurn = Number(data.turnPlayer || turnPlayer);
    const serverN    = Number(data.numPlayers || NUM_PLAYERS);

    // keep locals in sync (no local-only truth)
    turnPlayer  = serverTurn;
    NUM_PLAYERS = serverN;

    console.log('[battle] server turn:', serverTurn, 'me:', Number(currentPlayer));
    if (serverTurn === Number(currentPlayer)){
      openAttackOverlay();
    } else {
      openDefenseOverlay();
    }
  }catch(e){
    console.warn('[battle] failed to read server turn, using local', e);
    if (Number(turnPlayer) === Number(currentPlayer)) openAttackOverlay();
    else openDefenseOverlay();
  }
});


// COMBAT HELPERS -----------
// --- Identity (use your data-cid consistently)
function ensureCid(card){
  if(!card.dataset.cid) card.dataset.cid = String(Math.random()).slice(2);
  return card.dataset.cid;
}
function cardFrontUrl(card){
  const img = card.querySelector('.face.front img');
  if (img && img.src) return img.src;
  return ''; // (hydration may fill later; we still store empty safely)
}
function cardName(card){
  return card.getAttribute('data-name') || card._data?.name || '(Unnamed)';
}

// --- Compute current P/T exactly like your badge math (base + attachments + manual extras)
function computeCurrentPT(base){
  const [bp, bt] = basePT(base);
  if (bp==null || bt==null) return ['--','--'];
  let sumP = 0, sumT = 0;
  if (base._stack && base._stack.length > 1){
    for (let i=1;i<base._stack.length;i++){
      const att = base._stack[i];
      const {dp, dt} = extractPTDeltaFromText(oracleText(att));
      sumP += dp; sumT += dt;
    }
  }
  // include manual dp/dt edits saved via the editor
  sumP += Number(base._extras?.dp || 0);
  sumT += Number(base._extras?.dt || 0);
  return [bp + sumP, bt + sumT];
}

// --- Ownership (your cards vs others). If no owner marker, we treat all as yours.
function isOwnedByMe(card){
  const owner = (getStackBase(card)||card).getAttribute('data-owner');
  return !owner || String(owner) === String(currentPlayer);
}
function myCreatureBases(){
  const all = Array.from(document.querySelectorAll('#world .card'));
  const seen = new Set();
  const out = [];
  for (const c of all){
    const base = getStackBase(c) || c;
    if (!isCreatureCard(base)) continue;
    if (!isOwnedByMe(base)) continue;
    const id = ensureCid(base);
    if (seen.has(id)) continue;
    seen.add(id);
    out.push(base);
  }
  return out;
}

function combatDoc(){
  // games/{GAME_ID}/combat/current
  return db.collection('games').doc(GAME_ID).collection('combat').doc('current');
}

async function readCombat(){
  await firebaseReady;
  if(!db) return {};
  // Force server so both phones see each other immediately
  const snap = await combatDoc().get({ source: 'server' });
  return snap.exists ? (snap.data() || {}) : {};
}

async function readCombatFresh(){
  await firebaseReady;
  if(!db) return {};
  // Force server so both phones see each other immediately
  const snap = await combatDoc().get({ source: 'server' });
  return snap.exists ? (snap.data() || {}) : {};
}

async function writeTurnToServer(nextTurn, nextNumPlayers){
  await firebaseReady; if(!db) return;
  await combatDoc().set({
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    turnPlayer: Number(nextTurn),
    numPlayers: Number(nextNumPlayers)
  }, { merge: true });
  console.log('[turn] wrote to server:', { turnPlayer: Number(nextTurn), numPlayers: Number(nextNumPlayers) });
}



async function saveAttacksForCurrentPlayer(attackMap){
  // attackMap: { attackerCid -> targetPlayer or null }
  await firebaseReady; if(!db) return;
  const list = [];
  for (const [cid, target] of Object.entries(attackMap)){
    const el = document.querySelector(`.card[data-cid="${CSS.escape(cid)}"]`);
    if(!el) continue;
    list.push({
      attackerId: cid,
      name: cardName(el),
      url: cardFrontUrl(el),
      targetPlayer: target == null ? null : Number(target),
      seat: Number(currentPlayer)
    });
  }
  const ref = combatDoc();
await ref.set({
  updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  turnPlayer: Number(turnPlayer),
  numPlayers: Number(NUM_PLAYERS),
  attacksByPlayer: {
    [String(currentPlayer)]: list
  }
}, { merge: true });

}

async function saveBlocksForDefender(defenderSeat, orderedMap){
  // orderedMap: { [attackerId]: [blockerCid, ...] }  (order = damage order)
  await firebaseReady; if(!db) return;
  const ref = combatDoc();
await ref.set({
  updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  turnPlayer: Number(turnPlayer),
  numPlayers: Number(NUM_PLAYERS),
  blocksByDefender: {
    [String(defenderSeat)]: orderedMap
  }
}, { merge: true });

}

async function clearCombatForNewTurn(){
  await firebaseReady; if(!db) return;
  await combatDoc().set({
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    turnPlayer: Number(turnPlayer),
    numPlayers: Number(NUM_PLAYERS),
    attacksByPlayer: {},
    blocksByDefender: {}
  }, { merge: false }); // replace entirely
}

function openAttackOverlay(){
  // preload existing choices (if you re-open)
  let currentChoices = {}; // { attackerCid: targetPlayer or null }
  readCombat().then(data=>{
    const mine = data?.attacksByPlayer?.[String(currentPlayer)] || [];
    for (const row of mine){
      currentChoices[row.attackerId] = row.targetPlayer;
    }
    render(currentChoices);
  });

  function render(choices){
    const bases = myCreatureBases();
    const oppSeats = Array.from({length:NUM_PLAYERS}, (_,i)=>i+1).filter(p => p !== Number(currentPlayer));

    const ov = document.createElement('div');
    ov.className = 'overlay battle-overlay';
    ov.style.cssText = `
      position:fixed; inset:0; background:rgba(5,7,12,.86); z-index:11000;
      display:flex; flex-direction:column; padding:14px; gap:10px;
    `;
    ov.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h2 style="margin:0;font:600 18px/1 ui-sans-serif,system-ui">Attacking — Player ${currentPlayer}</h2>
        <button id="atkClose" class="btn" style="padding:6px 10px;border-radius:10px;background:#1b2a47;color:#d8e7ff">✕</button>
      </div>
      <div id="atkScroll" style="flex:1; overflow:auto; padding-right:6px;"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end">
        <button id="atkReset" class="btn" style="border-radius:10px;background:#1b2a47;color:#d8e7ff">Reset</button>
        <button id="atkConfirm" class="btn" style="border-radius:10px;background:#6aa9ff;color:#091323;font-weight:800">Confirm Attacks</button>
      </div>
    `;
    document.body.appendChild(ov);

    const list = ov.querySelector('#atkScroll');
    list.innerHTML = '';

    bases.forEach(base=>{
      const cid = ensureCid(base);
      const [p,t] = computeCurrentPT(base);
      const atts = (base._stack||[]).slice(1).map(a => cardName(a));
      const row = document.createElement('div');
      row.className = 'atk-row';
      row.dataset.cid = cid;
      row.style.cssText = `border:1px solid #2b3344;border-radius:10px;background:#141823;padding:10px;margin-bottom:10px;`;

      const oppButtons = oppSeats.map(seat=>{
        const on = choices[cid] === seat ? 'outline:2px solid #6aa9ff;box-shadow:0 0 0 6px rgba(106,169,255,.18) inset;' : '';
        return `<button class="pbtn choose" data-target="${seat}" style="${on}">${seat}</button>`;
      }).join('');

      const noneOn = (choices[cid] == null) ? 'outline:2px solid #6aa9ff;box-shadow:0 0 0 6px rgba(106,169,255,.18) inset;' : '';
      row.innerHTML = `
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
          <img src="${cardFrontUrl(base)}" alt="" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>
          <div style="flex:1;min-width:180px">
            <div style="font-weight:700">${escapeHTML(cardName(base))}</div>
            <div style="opacity:.8">P/T: ${p}/${t}</div>
            ${atts.length ? `<div style="opacity:.75;font-size:12px;margin-top:2px">Attachments: ${escapeHTML(atts.join(', '))}</div>`:''}
          </div>
          <div style="display:flex;gap:6px;flex-wrap:wrap">
            <button class="pbtn choose" data-target="" style="${noneOn}">—</button>
            ${oppButtons}
          </div>
        </div>
      `;
      row.addEventListener('click', (e)=>{
        const btn = e.target.closest('.choose');
        if(!btn) return;
        const target = btn.dataset.target === '' ? null : Number(btn.dataset.target);
        choices[cid] = target;
        // refresh selection styles quickly
        row.querySelectorAll('.choose').forEach(b=> b.style.outline='');
        row.querySelectorAll('.choose').forEach(b=> b.style.boxShadow='');
        btn.style.outline='2px solid #6aa9ff';
        btn.style.boxShadow='0 0 0 6px rgba(106,169,255,.18) inset';
      });
      list.appendChild(row);
    });

    ov.querySelector('#atkClose').onclick = ()=> ov.remove();
    ov.querySelector('#atkReset').onclick = ()=>{
      if(!confirm('Clear all your attack choices?')) return;
      choices = {};
      list.querySelectorAll('.atk-row').forEach(r=>{
        r.querySelectorAll('.choose').forEach(b=> {
          b.style.outline=''; b.style.boxShadow='';
          if (b.dataset.target===''){ b.style.outline='2px solid #6aa9ff'; b.style.boxShadow='0 0 0 6px rgba(106,169,255,.18) inset'; }
        });
      });
      showToast('Attacks reset');
    };
    ov.querySelector('#atkConfirm').onclick = async ()=>{
      await saveAttacksForCurrentPlayer(choices);
      showToast('Attacks set');
      ov.remove();
    };
  }
}


async function openDefenseOverlay(){
  try{
    // Force server so both phones agree immediately
    const data = await readCombatFresh();

    // Start with the normal nested map…
    let byPlayer = data?.attacksByPlayer || {};

    // Back-compat: if older writes created top-level fields like "attacksByPlayer.1",
    // fold those into a proper map so reads work.
    if (!Object.keys(byPlayer).length) {
      for (const [k, v] of Object.entries(data)) {
        if (k.startsWith('attacksByPlayer.')) {
          const seat = k.split('.')[1];
          byPlayer[seat] = Array.isArray(v) ? v : [];
        }
      }
    }

    const mySeat = Number(currentPlayer);

    // Flatten all attackers from everyone, then keep only those aimed at me
    const all = Object.values(byPlayer).flat();
    console.log('[DEF overlay] byPlayer keys=', Object.keys(byPlayer),
                'turnPlayer=', Number(data.turnPlayer),
                'numPlayers=', Number(data.numPlayers),
                'mySeat=', mySeat,
                'all attackers count=', all.length);


    // Log each row before filtering, so you can see raw target vs mySeat
    all.forEach((row, i)=>{
      console.log(`[DEF row ${i}] attackerId=${row?.attackerId} seat=${row?.seat} name="${row?.name}" targetPlayer(raw)=`, row?.targetPlayer, '→ Number=', Number(row?.targetPlayer));
    });

    const vsMe = all.filter(a => Number(a?.targetPlayer) === mySeat);
    console.log('[DEF overlay] vsMe count=', vsMe.length);

    // === Overlay shell + rows ===
    const ov = document.createElement('div');
    ov.className = 'overlay battle-overlay';
    ov.style.cssText = 'position:fixed;inset:0;background:rgba(5,7,12,0.86);z-index:11000;display:flex;flex-direction:column;padding:14px;gap:10px;';
    ov.innerHTML =
      '<div style="display:flex;justify-content:space-between;align-items:center">' +
        '<h2 style="margin:0;font:600 18px/1 ui-sans-serif,system-ui">Defending — Player ' + mySeat + '</h2>' +
        '<button id="boClose" class="btn" style="padding:6px 10px;border-radius:10px;background:#1b2a47;color:#d8e7ff">✕</button>' +
      '</div>' +
      '<div id="boScroll" style="flex:1; overflow:auto; padding-right:6px;"></div>' +
      '<div style="display:flex; gap:8px; justify-content:flex-end">' +
        '<button id="boReset" class="btn" style="border-radius:10px;background:#1b2a47;color:#d8e7ff">Reset</button>' +
        '<button id="boConfirm" class="btn" style="border-radius:10px;background:#6aa9ff;color:#091323;font-weight:800">Confirm Blocks</button>' +
      '</div>';
    document.body.appendChild(ov);

    const rows = ov.querySelector('#boScroll');
    if (!vsMe.length){
      rows.innerHTML = '<div style="opacity:.8">No creatures are attacking you.</div>';
    } else {
      rows.innerHTML = '';
      for (const atk of vsMe){
        const row = document.createElement('div');
        row.className = 'atk-row';
        row.dataset.attackerId = atk.attackerId;
        row.style.cssText = 'border:1px solid #2b3344;border-radius:10px;background:#141823;padding:10px;margin-bottom:10px;';
        row.innerHTML =
          '<div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">' +
            (atk.url ? `<img src="${atk.url}" style="width:44px;height:62px;object-fit:cover;border-radius:6px;border:1px solid #2b3344"/>` : '') +
            `<div style="flex:1;min-width:200px">
               <div style="font-weight:700">${(typeof escapeHTML==='function'?escapeHTML(atk.name):atk.name)}
                 <span style="opacity:.7">(P${atk.seat})</span></div>
               <div style="opacity:.8">Assign blockers (order matters) — wire-up next.</div>
             </div>` +
          '</div>';
        rows.appendChild(row);
      }
    }

    // Extra summary logs (keep for debugging)
    console.log('[DEF overlay] byPlayer keys=', Object.keys(byPlayer));
    for (const [k, arr] of Object.entries(byPlayer)) {
      console.log(' [DEF overlay] seat', k, 'rows=', Array.isArray(arr)?arr.length:0,
                  'first.targetPlayer=', arr?.[0]?.targetPlayer);
    }

    ov.querySelector('#boClose').onclick = ()=> ov.remove();
    ov.querySelector('#boReset').onclick  = ()=> (typeof showToast==='function' && showToast('Blocks reset'));
    ov.querySelector('#boConfirm').onclick= ()=> { if (typeof showToast==='function') showToast('Blocks set'); ov.remove(); };

  } catch (err){
    console.error('[defense overlay]', err);
  }
}



//---------------------------

// END turn with confirm; rotate 1..N (server source of truth)
document.getElementById('endBtn').addEventListener('click', async ()=>{
  const ok = confirm(`End Player ${turnPlayer}'s turn?`);
  if(!ok) return;

  const nextTurn = (Number(turnPlayer) % Number(NUM_PLAYERS)) + 1;
  turnPlayer = nextTurn; // keep local mirror

  showToast(`Turn: Player ${turnPlayer}`);

  try{
    // Clear combat rows and write new turn/players atomically
    await firebaseReady; if(!db) return;
    await combatDoc().set({
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      turnPlayer: Number(nextTurn),
      numPlayers: Number(NUM_PLAYERS),
      attacksByPlayer: {},
      blocksByDefender: {}
    }, { merge: false }); // replace
    console.log('[turn] advanced on server to P' + nextTurn);
  }catch(e){
    console.warn('[turn] end turn write failed:', e);
  }
});



// Optional: clicking outside closes the # popout (like others)
document.addEventListener('click', (e)=>{
  const w = document.getElementById('numWrapper');
  if (!w.contains(e.target)) w.classList.remove('open');
}, true);


/* Chat button (placeholder) */
/* ===== Chat overlay + Firestore-backed chat ===== */
const chatOverlay = $('#chatOverlay');
const chatPanel   = chatOverlay.querySelector('.chatPanel');
const chatLog     = $('#chatLog');
const chatInput   = $('#chatInput');
const chatSend    = $('#chatSend');
const chatClose   = $('#chatClose');
const toastEl     = $('#toast');

let chatUnsub = null;     // onSnapshot unsubscribe for chat list
let announceUnsub = null; // onSnapshot unsubscribe for announce doc
let chatOpen = false;

// Helper: tiny HTML escaper
function esc(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

// Helper: show toast
let toastTimer = null;
function showToast(msg){
  toastEl.textContent = msg;
  toastEl.style.display = 'block';
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>{ toastEl.style.display='none'; }, 2800);
}

// Render chat messages into the log
function renderChatSnap(snap){
  const me = (typeof currentPlayer === 'number' ? currentPlayer : 0);
  const frag = document.createDocumentFragment();

  // Clear and rebuild for simplicity (chat is small)
  chatLog.textContent = '';

  snap.forEach(doc=>{
    const d = doc.data() || {};
    const line = document.createElement('div');
    line.className = 'chatLine';
    line.dataset.mid = doc.id;

    const who  = document.createElement('div'); who.className = 'chatWho';  who.textContent = `P${d.playerId ?? 0}`;
    const text = document.createElement('div'); text.className = 'chatText'; text.textContent = d.text || '';
    const time = document.createElement('div'); time.className = 'chatTime';
    const ts   = d.ts && d.ts.toDate ? d.ts.toDate() : null;
    time.textContent = ts ? ts.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';

    const del  = document.createElement('button');
    del.className = 'chatDel';
    del.title = 'Delete message';
    del.textContent = '×';
    del.style.display = (Number(d.playerId) === Number(me)) ? 'inline-flex' : 'none';
    del.addEventListener('click', async (e)=>{
      e.stopPropagation();
      await firebaseReady;
      if(!db) return;
      try{
        await db.collection('games').doc(GAME_ID).collection('chat').doc(doc.id).delete();
      }catch(err){ console.warn('delete fail', err); }
    });

    line.appendChild(who);
    line.appendChild(text);
    line.appendChild(time);
    line.appendChild(del);
    frag.appendChild(line);
  });

  chatLog.appendChild(frag);
  chatLog.scrollTop = chatLog.scrollHeight;
}

// Open/close overlay
function openChat(){
  chatOverlay.style.display = 'block';
  chatOverlay.removeAttribute('aria-hidden');
  chatOpen = true;
  chatInput.focus();

  // Live chat stream
  (async ()=>{
    await firebaseReady; if(!db) return;
    if(!chatUnsub){
      chatUnsub = db.collection('games').doc(GAME_ID).collection('chat')
        .orderBy('ts','asc')
        .onSnapshot(renderChatSnap);
    }
    if(!announceUnsub){
      // Watch the announce doc to show toasts for messages not sent by me
      const aRef = db.collection('games').doc(GAME_ID).collection('meta').doc('chatAnnounce');
      announceUnsub = aRef.onSnapshot(s=>{
        if(!s.exists) return;
        const d = s.data() || {};
        const me = (typeof currentPlayer === 'number' ? currentPlayer : 0);
        if(d.hasAnnounced === 0 && Number(d.playerId) !== Number(me)){
          const preview = (d.text || '').slice(0, 120);
          showToast(`P${d.playerId}: ${preview}`);
          aRef.set({ hasAnnounced: 1 }, { merge:true }).catch(()=>{});
        }
      });
    }
  })();
}
function closeChat(){
  chatOverlay.style.display = 'none';
  chatOverlay.setAttribute('aria-hidden','true');
  chatOpen = false;
}

// Send message
async function sendChat(){
  const text = (chatInput.value || '').trim();
  if(!text) return;
  chatInput.value = '';

  await firebaseReady; if(!db) return;

  const me = (typeof currentPlayer === 'number' ? currentPlayer : 0);
  const ref = db.collection('games').doc(GAME_ID);
  const chatRef = ref.collection('chat');
  const metaRef = ref.collection('meta').doc('chatAnnounce');

  try{
    const docRef = await chatRef.add({
      text, playerId: me,
      ts: firebase.firestore.FieldValue.serverTimestamp()
    });
    // Flip announce flag to “new” so other clients toast it
    await metaRef.set({
      hasAnnounced: 0,
      playerId: me,
      text,
      mid: docRef.id,
      ts: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge:true });
  }catch(err){
    console.warn('sendChat fail', err);
  }
}

// Wire UI
$('#chatBtn').addEventListener('click', ()=>{
  if(chatOpen) closeChat(); else openChat();
});
chatClose.addEventListener('click', closeChat);
chatSend.addEventListener('click', sendChat);
chatInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendChat(); }
});

// Click-away: only close if the BACKDROP itself is tapped
chatOverlay.addEventListener('pointerdown', (e)=>{
  if (e.target === chatOverlay) closeChat();
});

// Shield interactions inside the panel so they never bubble to the backdrop
chatPanel.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });

// Global: clicking the table (outside overlay) still closes if open
table.addEventListener('pointerdown', ()=>{ if(chatOpen) closeChat(); });

// Esc closes
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && chatOpen) closeChat();
});

/* ===== end chat overlay ===== */

const stackWrap = $('#stackWrap');
const stackBtn  = $('#stackBtn');
const upBtn     = $('#stackUpBtn');
const leftBtn   = $('#stackLeftBtn');
const rightBtn  = $('#stackRightBtn');
const homeBtn   = $('#homeBtn');


stackBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  stackWrap.classList.toggle('open');
});
document.addEventListener('pointerdown', (e)=>{
  if (!stackWrap.contains(e.target) && !stackMode){
    stackWrap.classList.remove('open');
  }
});
function setStackMode(mode){
  stackMode = (stackMode===mode ? null : mode);
  [upBtn,leftBtn,rightBtn].forEach(b=>b.classList.remove('on'));
  if(stackMode==='up') upBtn.classList.add('on');
  if(stackMode==='left') leftBtn.classList.add('on');
  if(stackMode==='right') rightBtn.classList.add('on');
  if(stackMode){ stackWrap.classList.add('open'); } else { stackWrap.classList.remove('open'); }
}
upBtn.addEventListener('click',   (e)=>{ e.stopPropagation(); setStackMode('up');    });
leftBtn.addEventListener('click', (e)=>{ e.stopPropagation(); setStackMode('left');  });
rightBtn.addEventListener('click',(e)=>{ e.stopPropagation(); setStackMode('right'); });

// Compass: ALWAYS zoom out to min and center on table cards (or center origin if none)
homeBtn.addEventListener('click', goHome);


/* =========================================================
   Pan & pinch the table/world
   ========================================================= */
const pointers=new Map(); let mode=null; let panOffset={x:0,y:0};
let pinchStart={center:{x:0,y:0}, dist:1, scale:1, tx:0, ty:0};
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function centerOfPointers(){ let sx=0,sy=0,n=0; pointers.forEach(p=>{sx+=p.x; sy+=p.y; n++;}); return {x:sx/n,y:sy/n}; }
function worldPointAt(cx,cy,st){ const r=table.getBoundingClientRect(); const px=cx-r.left, py=cy-r.top; const sc=st?st.scale:state.scale, tx=st?st.tx:state.tx, ty=st?st.ty:state.ty; return {x:(px-tx)/sc,y:(py-ty)/sc}; }

table.addEventListener('pointerdown', e=>{
  // If press lands inside the hand's screen rect, do not start table pan.
  const hz = handZone.getBoundingClientRect();
  const inHand = (e.clientX>=hz.left && e.clientX<=hz.right && e.clientY>=hz.top && e.clientY<=hz.bottom);
  if (inHand) return;

  // If a card body is the target, let the card’s handler own it.
  if (e.target.closest('.cardBody')) return;

  clearSelection();

  table.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(pointers.size===1){ mode='pan'; panOffset.x=e.clientX-state.tx; panOffset.y=e.clientY-state.ty; }
  else if(pointers.size===2){
    mode='pinch';
    const c=centerOfPointers(); const arr=Array.from(pointers.values());
    pinchStart.center=c; pinchStart.dist=dist(arr[0],arr[1])||1;
    pinchStart.scale=state.scale; pinchStart.tx=state.tx; pinchStart.ty=state.ty;
  }
});
table.addEventListener('pointermove', e=>{
  if(!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(mode==='pan' && pointers.size===1){
    state.tx=e.clientX-panOffset.x; state.ty=e.clientY-panOffset.y; applyTransform();
  }
  if(mode==='pinch' && pointers.size>=2){
    const arr=Array.from(pointers.values());
    const cNow=centerOfPointers(); const dNow=dist(arr[0],arr[1])||1;
    const newScale=clamp(pinchStart.scale*(dNow/pinchStart.dist),0.35,2.0);
    const wp=worldPointAt(pinchStart.center.x,pinchStart.center.y,{scale:pinchStart.scale,tx:pinchStart.tx,ty:pinchStart.ty});
    const r=table.getBoundingClientRect(); const cx=cNow.x-r.left, cy=cNow.y-r.top;
    state.scale=newScale; state.tx=cx-wp.x*state.scale; state.ty=cy-wp.y*state.scale; applyTransform();
  }
});
function endPointer(e){
  if(!pointers.has(e.pointerId)) return;
  pointers.delete(e.pointerId);
  if(pointers.size===0){ mode=null; }
  else if(pointers.size===1){ const only=pointers.values().next().value; mode='pan'; panOffset.x=only.x-state.tx; panOffset.y=only.y-state.ty; }
  else if(pointers.size>=2){
    const arr=Array.from(pointers.values()); mode='pinch';
    pinchStart.center=centerOfPointers(); pinchStart.dist=dist(arr[0],arr[1])||1;
    pinchStart.scale=state.scale; pinchStart.tx=state.tx; pinchStart.ty=state.ty;
  }
}
table.addEventListener('pointerup', endPointer);
table.addEventListener('pointercancel', endPointer);
window.addEventListener('resize', applyTransform);

/* =========================================================
   Seed deck + boot
   ========================================================= */
$('#deckIn').value=[
"1 Liliana's Reaver",
"1 Lord of the Accursed",
"1 Macabre Waltz",
"1 Metallic Mimic",
"1 Mikaeus, the Unhallowed",
"1 Mindleech Ghoul",
"1 Neheb, the Eternal",
"1 Phylactery Lich",
"1 Phyrexian Ghoul",
"1 Prized Amalgam"
].join('\n');

applyTransform();
requestAnimationFrame(goHome);
</script>
<!-- === Card Edit Overlay === -->
<div id="editOverlay" aria-hidden="true">
  <div class="panel">
    <h3 id="editTitle">Edit Card</h3>

    <div class="row">
      <label>Additional Types</label>
      <input id="editTypes" type="text" placeholder="Comma-separated (e.g., Zombie, Warrior)"/>
    </div>

    <div class="row">
      <label>Additional Effects</label>
      <textarea id="editEffects" placeholder="Comma-separated keywords/effects (e.g., menace, flying, shroud)"></textarea>
    </div>

    <div class="row">
      <label>P/T Modifier</label>
      <div style="display:flex; gap:8px;">
        <input id="editP" type="number" step="1" placeholder="+P (e.g., 1)"/>
        <input id="editT" type="number" step="1" placeholder="+T (e.g., 1)"/>
      </div>
    </div>

    <div class="row">
      <label>Chosen Type (for “choose a type” cards)</label>
      <input id="editChosenType" type="text" placeholder="e.g., Zombie"/>
    </div>

    <div class="actions">
      <button class="btn cancel" id="editCancel">Cancel</button>
      <button class="btn save"   id="editSave">Save</button>
    </div>
  </div>
</div>

</body>
</html>
