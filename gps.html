<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GPS – Setups Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{
    --accent:#0b74ff;
    --ray:#111827;
    --panel:#ffffffcc;
    --bg:#f5f5f5;

    /* populated by JS on mobile */
    --hud-h: 0px;

    /* blues by group index */
    --g0:#0b74ff; --g1:#2563eb; --g2:#3b82f6; --g3:#60a5fa; --g4:#93c5fd;
    --blind:#16a34a; --trainer:#f97316;
  }

  html, body { height:100%; margin:0; background:var(--bg); font-family:system-ui, sans-serif; }

  /* Map: full height on desktop; on mobile we subtract the HUD height */
  #map { height:100%; width:100%; }
  @supports (height: 100svh) { #map { height:100svh; } }
  @media (max-width: 820px) {
    body.hud-outside #map { height: calc(100svh - var(--hud-h)); }
  }

  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; align-items:center; justify-content:center; z-index:99999; }
  .overlay.open { display:flex; }
  .overlay-card { background:#fff; padding:18px; border-radius:12px; min-width:280px; border:1px solid #e5e5e5; box-shadow:0 10px 30px rgba(0,0,0,.2); }
  .overlay-actions { display:flex; gap:10px; margin-top:12px; justify-content:space-between; flex-wrap:wrap; }
  .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .btn.primary { background:var(--accent); border-color:var(--accent); color:#fff; }
  .btn.ghost { background:#fff; border-color:#ccc; }
  .btn.warn { border-color:#ef4444; color:#b91c1c; }

  /* HUD: fixed overlay on desktop; becomes static block above the map on mobile */
  .hud {
    position:fixed; left:10px; top:10px; z-index:1000;
    display:grid; gap:8px; padding:10px;
    background:var(--panel); backdrop-filter: blur(4px);
    border:1px solid #ddd; border-radius:12px; max-width:min(92vw,520px);
  }
  @media (max-width: 820px) {
    .hud { position:static; max-width:none; margin:10px; backdrop-filter:none; }
  }

  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .tabs { display:flex; gap:6px; flex-wrap:wrap; align-items:flex-end; }
  .tab {
    padding:8px 12px; border:1px solid #ddd; border-bottom:none;
    border-top-left-radius:10px; border-top-right-radius:10px;
    background:#f6f6f6; cursor:pointer; font-weight:600; color:#444;
  }
  .tab.active { background:#fff; color:#111; box-shadow:0 -1px 0 #fff inset; }

  /* Dock floats; on mobile it sits below the HUD height so it never covers the HUD */
  .dock {
    position:fixed; right:10px; top:10px; z-index:1000;
    width:min(92vw, 340px); max-height:80vh; overflow:auto;
    display:grid; gap:10px; padding:10px;
    background:var(--panel); border:1px solid #ddd; border-radius:12px; backdrop-filter: blur(4px);
  }
  @media (max-width: 820px) {
    body.hud-outside .dock { top: calc(10px + var(--hud-h)); }
  }

  .group { border:1px solid #ddd; border-radius:10px; padding:8px; background:#fff; }
  .group h4 { margin:0 0 8px; font-size:14px; display:flex; align-items:center; gap:8px; }
  .swatch { width:12px; height:12px; border-radius:50%; border:1px solid #999; }
  .chips { display:flex; flex-wrap:wrap; gap:8px; }
  .chip { user-select:none; padding:6px 10px; border:1px solid #bbb; border-radius:999px; background:#f7f7f7; cursor:grab; font-weight:600; }
  .chip[draggable="true"]:active { cursor:grabbing; }
  .blind-group h4 .swatch { background:var(--blind); }

  /* Touch-drag ghost for mobile */
  .chip-ghost {
    position: fixed; left:0; top:0; transform:translate(-50%,-50%);
    padding:6px 10px; border:1px solid #bbb; border-radius:999px; background:#fff;
    box-shadow:0 6px 18px rgba(0,0,0,.25);
    z-index: 100000; pointer-events:none; font-weight:700;
  }

  /* Map pills */
  .mk { display:grid; place-items:center; pointer-events:auto; }
  .pill {
    min-width: 28px; height:28px; padding:0 8px; border-radius:14px; color:#fff; font-weight:800; font-size:13px;
    display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(0,0,0,.35); transform:translateY(-4px); border:2px solid #fff;
  }

  .handle-hit { width:32px; height:32px; border-radius:50%; background:transparent; display:grid; place-items:center; }
  .handle-dot { width:4px; height:4px; border-radius:50%; background:currentColor; box-shadow:0 0 0 1.5px #fff; }

  .dist-label { background:#fff; padding:2px 6px; border-radius:10px; border:1px solid #ddd; font-size:12px; color:#111; box-shadow:0 1px 4px rgba(0,0,0,.15); }
  .muted { color:#666; font-size:12px; }
</style>
</head>
<body>

<!-- Trainer chooser -->
<div class="overlay" id="trainerOverlay">
  <div class="overlay-card">
    <h3>Who are you?</h3>
    <div class="overlay-actions">
      <button class="btn primary" data-trainer="Scott">Scott</button>
      <button class="btn primary" data-trainer="Cody">Cody</button>
      <button class="btn primary" data-trainer="Brian">Brian</button>
    </div>
  </div>
</div>

<!-- Place-at-me chooser -->
<div class="overlay" id="placeOverlay">
  <div class="overlay-card">
    <h3>Place at my location</h3>
    <div id="placeList" class="overlay-actions"></div>
    <div class="overlay-actions">
      <button class="btn" id="placeCancel">Cancel</button>
    </div>
  </div>
</div>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="row">
    <h2 style="margin:0">GPS – Setups Map</h2>
    <a id="changeUserLink" class="muted" href="#">change user</a>
    <div id="ctx" class="muted">Loading…</div>
  </div>

  <div class="row">
    <label>Day: <input type="date" id="dayPicker"></label>
    <button class="btn ghost" id="todayBtn">Today</button>
    <div class="tabs" id="tabs"></div>
  </div>

  <div class="row">
    <button class="btn" id="locBtn">Location</button>
    <button class="btn" id="fitBtn">Fit All</button>
    <button class="btn primary" id="placeBtn">Place at me</button>
    <label style="display:flex;align-items:center;gap:6px;margin-left:auto;">
      <input id="raysChk" type="checkbox" />
      <span>Distances</span>
    </label>
  </div>
</div>

<!-- Dock -->
<div class="dock" id="dock">
  <div class="muted">Fetching setups…</div>
</div>

<div id="map"></div>

<script type="module">
  /* ---------------- Firebase (v10) ---------------- */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getFirestore, doc, setDoc, updateDoc, onSnapshot,
    collection, query, orderBy, deleteField
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
    authDomain: "task-tracker-73b77.firebaseapp.com",
    projectId: "task-tracker-73b77",
    storageBucket: "task-tracker-73b77.firebasestorage.app",
    messagingSenderId: "795274673000",
    appId: "1:795274673000:web:0ea07130e45c72384134dd",
    measurementId: "G-VLW5KLY4FF"
  };
  const app = initializeApp(firebaseConfig);
  const db  = getFirestore(app);

  /* ---------------- Utilities ---------------- */
  const $ = s => document.querySelector(s);
  function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
  const GROUP_BLUES = ['var(--g0)','var(--g1)','var(--g2)','var(--g3)','var(--g4)'];

/* ---- UI scale knob (0.7 = smaller, 1 = current, 1.3 = larger) ---- */
const PILL_SCALE = 0.5;   // try 0.85 first on phone


  /* Mobile placement state */
  let pendingPlacement = null;
  function showPlacingMsg(what){ $('#ctx').textContent = `Placing ${what} — tap on the map`; $('#ctx').style.fontWeight='700'; }
  function clearPlacingMsg(){ $('#ctx').textContent = `Trainer: ${trainerId}`; $('#ctx').style.fontWeight='400'; }

  /* Trainer picker */
  const overlay = $('#trainerOverlay');
  const placeOverlay = $('#placeOverlay');
  const ctxEl   = $('#ctx');
  $('#placeCancel').addEventListener('click', ()=> placeOverlay.classList.remove('open'));

  $('#changeUserLink').addEventListener('click', (e)=> {
    e.preventDefault();
    const url = new URL(location.href); url.searchParams.delete('trainer');
    history.replaceState(null,'',url.toString());
    showTrainerPrompt();
  });

  let trainerId = (new URL(location.href)).searchParams.get('trainer') || '';
  function setTrainer(name){
    trainerId = name;
    const url = new URL(location.href); url.searchParams.set('trainer', trainerId);
    history.replaceState(null,'',url.toString());
    ctxEl.textContent = `Trainer: ${trainerId}`;
    boot();
  }
  function showTrainerPrompt(){
    overlay.classList.add('open');
    overlay.querySelectorAll('button[data-trainer]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        overlay.classList.remove('open');
        setTrainer(btn.dataset.trainer);
      }, { once:true });
    });
  }
  if (trainerId) ctxEl.textContent = `Trainer: ${trainerId}`;

  /* Date + tabs */
  const dayPicker = $('#dayPicker');
  const todayBtn  = $('#todayBtn');
  dayPicker.value = ymd(new Date());
  todayBtn.addEventListener('click', ()=>{ dayPicker.value = ymd(new Date()); switchDay(dayPicker.value); });
  dayPicker.addEventListener('change', ()=> switchDay(dayPicker.value));
  const tabsEl = $('#tabs');

  let currentDateKey = dayPicker.value;
  let setupsMeta = [];
  let activeSetupId = null;

  const dayDocPath = () => doc(db, 'setups', trainerId, 'days', currentDateKey);
  const setupsColl = () => collection(dayDocPath(), 'setups');
  const setupDoc   = () => (activeSetupId ? doc(setupsColl(), activeSetupId) : null);

  /* Map */
  const MAX_COMFORT_ZOOM = 19; // ⬅ bumped from 17
  const map = L.map('map', { maxZoom: MAX_COMFORT_ZOOM }).setView([39.5,-98.35], 5);
  let hasAutoCentered = false;
  L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom:20, maxNativeZoom:17, attribution:'&copy; Esri, Maxar, Earthstar Geographics' }).addTo(map);
  L.control.scale({imperial:true, metric:false}).addTo(map);
  map.on('zoomend', renderAllArrows);

  const markLines  = L.layerGroup().addTo(map);
  const markPins   = L.layerGroup().addTo(map);
  const markDots   = L.layerGroup().addTo(map);
  const blindPins  = L.layerGroup().addTo(map);
  const trainerLay = L.layerGroup().addTo(map);
  const raysLayer  = L.layerGroup().addTo(map);
  const distLabels = L.layerGroup().addTo(map);

  function iconPill(text, colorCSS){
  const H       = Math.round(28 * PILL_SCALE);                // height
  const PADX    = Math.round(8 * PILL_SCALE);                 // left/right padding
  const FZ      = Math.max(11, Math.round(13 * PILL_SCALE));  // font size
  const BORDER  = Math.max(1, Math.round(2 * PILL_SCALE));    // white ring thickness
  const lift    = Math.round(-4 * PILL_SCALE);                // visual “lift” (negative = up)
  const anchorY = Math.max(0, H - Math.round(4 * PILL_SCALE)); // keep bottom edge near point

  const html = `<div class="pill"
                      style="
                        background:${colorCSS};
                        height:${H}px; min-width:${H}px; padding:0 ${PADX}px;
                        font-size:${FZ}px; border-width:${BORDER}px;
                        border-radius:${Math.round(H/2)}px;
                        transform:translateY(${lift}px)
                      ">
                  ${text}
                </div>`;

  return L.divIcon({
    className: 'mk',
    html,
    iconSize: [H, H],                       // keep hitbox in sync
    iconAnchor: [Math.round(H/2), anchorY]  // anchor near visual tip
  });
}

  const handleIcon = (colorCSS) => {
  const HS  = Math.round(32 * PILL_SCALE);                // handle hit area
  const DOT = Math.max(3, Math.round(4 * PILL_SCALE));    // actual dot size
  const html = `<div class="handle-hit"
                   style="width:${HS}px; height:${HS}px">
                  <div class="handle-dot"
                       style="width:${DOT}px; height:${DOT}px; color:${colorCSS}"></div>
                </div>`;
  return L.divIcon({
    className:'mk',
    html,
    iconSize:[HS,HS],
    iconAnchor:[Math.round(HS/2), Math.round(HS/2)]
  });
};


  /* Geo utils */
  const Rm = 6371000;
  const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
  function distanceMeters(a,b){ return map.distance(a,b); }
  function yards(m){ return m*1.09361; }
  function fmtYards(m){ return `${Math.round(yards(m))} yd`; }
 function bearing(a,b){
  const φ1=toRad(a.lat), φ2=toRad(b.lat), λ1=toRad(a.lng), λ2=toRad(b.lng);
  const y = Math.sin(λ2-λ1)*Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
  return ((toDeg(Math.atan2(y,x))+360)%360);
}

  function destPoint(start, brgDeg, distM){
    const δ = distM / Rm, θ = toRad(brgDeg);
    const φ1 = toRad(start.lat), λ1 = toRad(start.lng);
    const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
    const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
    const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
    const φ2 = Math.asin(sinφ2);
    const y = Math.sin(θ)*sinδ*cosφ1;
    const x = cosδ - sinφ1*sinφ2;
    const λ2 = λ1 + Math.atan2(y, x);
    return L.latLng(toDeg(φ2), ((toDeg(λ2)+540)%360)-180);
  }

  const DEFAULT_ARROW_BRG = 315;
  const DEFAULT_ARROW_LEN = 100;
  const MIN_ARROW_VISIBLE = 12;

  function drawArrow(A, B, colorCSS){
    L.polyline([A,B], { color: colorCSS, weight:4, opacity:0.95, interactive:false }).addTo(markLines);
    const z = map.getZoom();
    const aPt = map.project(A, z), bPt = map.project(B, z);
    const v = bPt.subtract(aPt); const len = Math.hypot(v.x, v.y); if (!len) return;
    const ux=v.x/len, uy=v.y/len;
    const headLen = 18, headAng = 32*Math.PI/180;
    const lx = bPt.x - headLen*( ux*Math.cos(headAng) - uy*Math.sin(headAng) );
    const ly = bPt.y - headLen*( uy*Math.cos(headAng) + ux*Math.sin(headAng) );
    const rx = bPt.x - headLen*( ux*Math.cos(headAng) + uy*Math.sin(headAng) );
    const ry = bPt.y - headLen*( uy*Math.cos(headAng) - ux*Math.sin(headAng) );
    const L1 = map.unproject(L.point(lx,ly), z);
    const L2 = map.unproject(L.point(rx,ry), z);
    L.polyline([B,L1], { color: colorCSS, weight:4, opacity:0.95, interactive:false }).addTo(markLines);
    L.polyline([B,L2], { color: colorCSS, weight:4, opacity:0.95, interactive:false }).addTo(markLines);
  }

  /* State */
  let activeSetupData = { items:[], columns:{dock:[], cols:[]}, blinds:[], geo:{} };
  let unsubSetups = null, unsubSetupDoc = null;

  function renderTabs(){
    tabsEl.innerHTML = '';
    setupsMeta.sort((a,b)=>(a.order??0)-(b.order??0)).forEach((m, idx)=>{
      const b = document.createElement('button');
      b.className = 'tab' + (m.id===activeSetupId ? ' active' : '');
      b.textContent = m.name || `Setup ${idx+1}`;
      b.addEventListener('click', ()=> setActiveSetup(m.id));
      tabsEl.appendChild(b);
    });
  }

  function renderAllArrows() {
    markLines.clearLayers();
    const marksPlaced = activeSetupData.geo?.marks || {};
    const cols = Array.isArray(activeSetupData.columns?.cols) ? activeSetupData.columns.cols : [];
    const groupOf = (id)=>{ for (let i=0;i<cols.length;i++){ if ((cols[i].items||[]).includes(id)) return i; } return 0; };
    activeSetupData.items.forEach(it => {
      const g = marksPlaced[it.id]; if (!g) return;
      const color = GROUP_BLUES[groupOf(it.id) % GROUP_BLUES.length];
      const A = L.latLng(g.lat, g.lng);
      const H = g.handle ? L.latLng(g.handle.lat, g.handle.lng) : destPoint(A, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);
      drawArrow(A, H, color);
    });
    renderRays();
  }

  /* Desktop drag + Mobile touch drag + Tap-to-place */
  let touchDrag = null;
  let justDidTouchDrop = false;

  function startTouchDrag(chip, data, touch){
    justDidTouchDrop = false;
    const ghost = document.createElement('div');
    ghost.className = 'chip-ghost';
    ghost.textContent = chip.textContent.trim();
    document.body.appendChild(ghost);
    positionGhost(ghost, touch.clientX, touch.clientY);
    try { map.dragging.disable(); map.touchZoom.disable(); map.boxZoom.disable(); map.doubleClickZoom.disable(); map.scrollWheelZoom.disable(); } catch {}
    touchDrag = { data, ghost };
  }
  function positionGhost(ghost, x, y){ ghost.style.left = x + 'px'; ghost.style.top = y + 'px'; }
  async function endTouchDrag(touch){
    if (!touchDrag) return;
    const { data, ghost } = touchDrag;
    touchDrag = null;
    ghost.remove();
    try { map.dragging.enable(); map.touchZoom.enable(); map.boxZoom.enable(); map.doubleClickZoom.enable(); map.scrollWheelZoom.enable(); } catch {}
    const rect = map.getContainer().getBoundingClientRect();
    const inside = touch.clientX>=rect.left && touch.clientX<=rect.right && touch.clientY>=rect.top && touch.clientY<=rect.bottom;
    if (!inside) return;
    const pt = L.point(touch.clientX-rect.left, touch.clientY-rect.top);
    const ll = map.containerPointToLatLng(pt);
    await placeItem(data, ll);
    justDidTouchDrop = true;
  }

  function wireDockChips(container){
    container.querySelectorAll('.chip').forEach(ch => {
      const data = { type: ch.dataset.type, id: ch.dataset.id, color: ch.dataset.color };
      ch.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', JSON.stringify(data)); e.dataTransfer.effectAllowed = 'copy'; });
      ch.addEventListener('touchstart', e => { if (e.touches && e.touches[0]) { e.preventDefault(); startTouchDrag(ch, data, e.touches[0]); } }, { passive:false });
      ch.addEventListener('click', e => {
        if (justDidTouchDrop) { justDidTouchDrop=false; return; }
        e.preventDefault(); pendingPlacement = data;
        const label = ch.textContent.trim(); showPlacingMsg(label || (pendingPlacement.type==='trainer' ? 'TR' : 'Item'));
      }, { passive:true });
    });
  }
  window.addEventListener('touchmove', e => { if (!touchDrag) return; e.preventDefault(); if (e.touches && e.touches[0]) positionGhost(touchDrag.ghost, e.touches[0].clientX, e.touches[0].clientY); }, { passive:false });
  window.addEventListener('touchend', e => { if (!touchDrag) return; const t = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0] : null; if (t) endTouchDrag(t); }, { passive:false });
  window.addEventListener('touchcancel', () => { if (touchDrag){ touchDrag.ghost.remove(); touchDrag=null; } }, { passive:true });

  /* Dock building */
  function buildDock(){
    const dock = $('#dock');
    dock.innerHTML = '';

    if (!activeSetupData.items.length && !activeSetupData.blinds.length && activeSetupData.geo?.trainer) {
      dock.innerHTML = '<div class="muted">Everything is placed.</div>';
      return;
    }

    // Trainer chip if not placed
    if (!activeSetupData.geo?.trainer){
      const tBox = document.createElement('div');
      tBox.className = 'group';
      tBox.innerHTML = `<h4><span class="swatch" style="background:var(--trainer)"></span>Trainer</h4>
                        <div class="chips">
                          <div class="chip" draggable="true" data-type="trainer" data-id="TR" data-color="var(--trainer)">TR</div>
                        </div>`;
      dock.appendChild(tBox);
    }

    // Groups
    const cols = Array.isArray(activeSetupData.columns?.cols) ? activeSetupData.columns.cols : [];
    cols.forEach((col, gi) => {
      const color = GROUP_BLUES[gi % GROUP_BLUES.length];
      const box = document.createElement('div');
      box.className = 'group';
      box.innerHTML = `<h4><span class="swatch" style="background:${color}"></span>Group ${gi+1}</h4><div class="chips"></div>`;
      const chips = box.querySelector('.chips');

      (col.items||[]).forEach(id=>{
        if (activeSetupData.geo?.marks?.[id]) return;
        const idx = activeSetupData.items.findIndex(i=>i.id===id);
        const chip = document.createElement('div');
        chip.className='chip'; chip.draggable=true; chip.textContent=`M${idx>=0?idx+1:'?'}`;
        chip.dataset.type='mark'; chip.dataset.id=id; chip.dataset.color=color;
        chips.appendChild(chip);
      });

      if (chips.children.length) dock.appendChild(box);
    });

    // Ungrouped
    const groupedIds = new Set((Array.isArray(activeSetupData.columns?.cols)?activeSetupData.columns.cols:[]).flatMap(c => c.items||[]));
    const ungroup = activeSetupData.items.filter(m => !groupedIds.has(m.id)).map(m => m.id);
    if (ungroup.length){
      const color = GROUP_BLUES[0];
      const box = document.createElement('div');
      box.className = 'group';
      box.innerHTML = `<h4><span class="swatch" style="background:${color}"></span>Ungrouped Marks</h4><div class="chips"></div>`;
      const chips = box.querySelector('.chips');
      ungroup.forEach(id=>{
        if (activeSetupData.geo?.marks?.[id]) return;
        const idx = activeSetupData.items.findIndex(i=>i.id===id);
        const chip = document.createElement('div');
        chip.className='chip'; chip.draggable=true; chip.textContent=`M${idx+1}`;
        chip.dataset.type='mark'; chip.dataset.id=id; chip.dataset.color=color;
        chips.appendChild(chip);
      });
      if (chips.children.length) dock.appendChild(box);
    }

    // Blinds
    const bBox = document.createElement('div');
    bBox.className = 'group blind-group';
    bBox.innerHTML = `<h4><span class="swatch"></span>Blinds</h4><div class="chips"></div>`;
    const bChips = bBox.querySelector('.chips');
    (activeSetupData.blinds||[]).forEach((b,i)=>{
      if (activeSetupData.geo?.blinds?.[b.id]) return;
      const chip = document.createElement('div');
      chip.className='chip'; chip.draggable=true; chip.textContent=`B${i+1}`;
      chip.dataset.type='blind'; chip.dataset.id=b.id; chip.dataset.color=getComputedStyle(document.documentElement).getPropertyValue('--blind').trim();
      bChips.appendChild(chip);
    });
    if (bChips.children.length) dock.appendChild(bBox);

    wireDockChips(dock);
  }

  async function placeItem(data, ll){
    if (data.type === 'mark') {
      const hLL = destPoint(ll, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);
      await setDoc(setupDoc(), { geo: { marks: { [data.id]: { lat: ll.lat, lng: ll.lng, handle: { lat: hLL.lat, lng: hLL.lng } } } } }, { merge:true });
    } else if (data.type === 'blind') {
      await setDoc(setupDoc(), { geo: { blinds: { [data.id]: { lat: ll.lat, lng: ll.lng } } } }, { merge:true });
    } else if (data.type === 'trainer') {
      await setDoc(setupDoc(), { geo: { trainer: { lat: ll.lat, lng: ll.lng } } }, { merge:true });
    }
  }

  /* Desktop drop target */
  const mapEl = map.getContainer();
  mapEl.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
  mapEl.addEventListener('drop', async e => {
    e.preventDefault();
    const data = JSON.parse(e.dataTransfer.getData('text/plain')||'{}');
    if (!data || !data.id || !data.type) return;
    const rect = mapEl.getBoundingClientRect();
    const pt = L.point(e.clientX-rect.left, e.clientY-rect.top);
    const ll = map.containerPointToLatLng(pt);
    await placeItem(data, ll);
  });

  /* Tap-to-place fallback */
  map.on('click', async (e) => {
    if (!pendingPlacement) return;
    const ll = e.latlng;
    try { await placeItem(pendingPlacement, ll); }
    finally { pendingPlacement = null; clearPlacingMsg(); }
  });
  window.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && pendingPlacement){ pendingPlacement=null; clearPlacingMsg(); } });

  /* Render map from activeSetupData */
  function renderMap(){
    markPins.clearLayers(); markLines.clearLayers(); markDots.clearLayers();
    blindPins.clearLayers(); trainerLay.clearLayers(); raysLayer.clearLayers(); distLabels.clearLayers();

    const geo = activeSetupData.geo || {};
    const marksPlaced = geo.marks || {};
    const blindsPlaced = geo.blinds || {};

    // Trainer
    if (geo.trainer){
      const t = L.marker(geo.trainer, { draggable:true, autoPan:false, icon: iconPill('TR','var(--trainer)') })
        .addTo(trainerLay)
        .bindPopup('<div><strong>Trainer</strong><div class="row" style="margin-top:6px;"><button class="btn warn" id="delTrainer">Redock</button></div></div>')
        .on('dragend', async e => {
          const ll = e.target.getLatLng();
          await setDoc(setupDoc(), { geo: { trainer: { lat:ll.lat, lng:ll.lng } } }, { merge:true });
        });

      t.on('popupopen', ev=>{
        ev.popup.getElement().querySelector('#delTrainer')?.addEventListener('click', async ()=>{
          try { await updateDoc(setupDoc(), { 'geo.trainer': deleteField() }); } catch(err){ alert('Could not redock trainer'); }
        }, { once:true });
      });
    }

    const cols = Array.isArray(activeSetupData.columns?.cols) ? activeSetupData.columns.cols : [];
    const groupOf = (id)=>{ for (let i=0;i<cols.length;i++){ if ((cols[i].items||[]).includes(id)) return i; } return 0; };

    // Marks
    activeSetupData.items.forEach((it, idx) => {
      const geoM = marksPlaced[it.id]; if (!geoM) return;
      const gi = groupOf(it.id);
      const color = GROUP_BLUES[gi % GROUP_BLUES.length];
      const A = L.latLng(geoM.lat, geoM.lng);
      let H = geoM.handle ? L.latLng(geoM.handle.lat, geoM.handle.lng) : destPoint(A, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);

      const base = L.marker(A, { draggable:true, autoPan:false, riseOnHover:true, zIndexOffset:500, icon: iconPill(`M${idx+1}`, color) }).addTo(markPins);
base.on('add', () => { if (base._icon) base._icon.style.pointerEvents = 'auto'; });


      let dragBrg = 0, dragDist = MIN_ARROW_VISIBLE;
      base.on('dragstart', () => { dragBrg = bearing(A, H); dragDist = Math.max(distanceMeters(A, H), MIN_ARROW_VISIBLE); });
      base.on('drag', e => {
        const newA = e.target.getLatLng();
        A.lat=newA.lat; A.lng=newA.lng;
        H = destPoint(newA, dragBrg, dragDist);
        dot.setLatLng(H);
        redraw();
      });
      base.on('dragend', async e => {
        const ll = e.target.getLatLng();
        await setDoc(setupDoc(), { geo: { marks: { [it.id]: { lat: ll.lat, lng: ll.lng, handle: { lat:H.lat, lng:H.lng } } } } }, { merge:true });
      });

      const dot = L.marker(H, { draggable:true, autoPan:false, icon: handleIcon(color), zIndexOffset:1000 }).addTo(markDots);
      dot.on('drag', e => { H = e.target.getLatLng(); redraw(); });
      dot.on('dragend', async e => {
        H = e.target.getLatLng();
        await setDoc(setupDoc(), { geo: { marks: { [it.id]: { lat: A.lat, lng: A.lng, handle: { lat:H.lat, lng:H.lng } } } } }, { merge:true });
      });

      function redraw(){
        markLines.clearLayers();
        const mp = activeSetupData.geo?.marks || {};
        activeSetupData.items.forEach(it2 => {
          if (it2.id === it.id) return;
          const g = mp[it2.id]; if (!g) return;
          const color2 = GROUP_BLUES[groupOf(it2.id) % GROUP_BLUES.length];
          const A2 = L.latLng(g.lat, g.lng);
          const H2 = g.handle ? L.latLng(g.handle.lat, g.handle.lng) : destPoint(A2, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);
          drawArrow(A2, H2, color2);
        });
        drawArrow(A, H, color);
        renderRays();
      }

      drawArrow(A, H, color);

      base.bindPopup(`<div><strong>Mark M${idx+1}</strong><div class="row" style="margin-top:6px;"><button class="btn warn" id="redock">Redock</button></div></div>`);
      base.on('popupopen', ev=>{
        ev.popup.getElement().querySelector('#redock')?.addEventListener('click', async ()=>{
          try { await updateDoc(setupDoc(), { [`geo.marks.${it.id}`]: deleteField() }); }
          catch(err){ alert('Could not redock this mark'); }
        }, { once:true });
      });
    });

    // Blinds
    (activeSetupData.blinds||[]).forEach((b, i)=>{
      const g = blindsPlaced[b.id]; if (!g) return;
      const B = L.latLng(g.lat, g.lng);
      const pin = L.marker(B, { draggable:true, autoPan:false, icon: iconPill(`B${i+1}`, 'var(--blind)') }).addTo(blindPins);
      pin.on('dragend', async e=>{
        const ll = e.target.getLatLng();
        await setDoc(setupDoc(), { geo: { blinds: { [b.id]: { lat: ll.lat, lng: ll.lng } } } }, { merge:true });
      });
      pin.bindPopup(`<div><strong>Blind B${i+1}</strong><div class="row" style="margin-top:6px;"><button class="btn warn" id="redockB">Redock</button></div></div>`);
      pin.on('popupopen', ev=>{
        ev.popup.getElement().querySelector('#redockB')?.addEventListener('click', async ()=>{
          try { await updateDoc(setupDoc(), { [`geo.blinds.${b.id}`]: deleteField() }); }
          catch(err){ alert('Could not redock this blind'); }
        }, { once:true });
      });
    });

    renderRays();
  }

  function renderRays(){
    raysLayer.clearLayers(); distLabels.clearLayers();
    if (!$('#raysChk').checked) return;
    const t = activeSetupData.geo?.trainer; if (!t) return;
    const T = L.latLng(t.lat, t.lng);

    function ray(toLL, colorCSS){
      L.polyline([T,toLL], { color:'var(--ray)', weight:2, opacity:.85, dashArray:'6,6', interactive:false }).addTo(raysLayer);
      const mid = L.latLng((T.lat+toLL.lat)/2, (T.lng+toLL.lng)/2);
      const yardsTxt = fmtYards(distanceMeters(T, toLL));
      L.marker(mid, { icon: L.divIcon({ className:'mk', html:`<div class="dist-label" style="border-color:${colorCSS}">${yardsTxt}</div>` }), interactive:false })
        .addTo(distLabels);
    }

    const marksPlaced = activeSetupData.geo?.marks || {};
    const blindsPlaced = activeSetupData.geo?.blinds || {};
    const cols = activeSetupData.columns?.cols || [];
    const groupOf = (id)=>{ for(let i=0;i<cols.length;i++){ if ((cols[i].items||[]).includes(id)) return i; } return 0; };

    activeSetupData.items.forEach(it=>{
      const g = marksPlaced[it.id]; if (!g) return;
      const color = GROUP_BLUES[groupOf(it.id) % GROUP_BLUES.length];
      ray(L.latLng(g.lat, g.lng), color);
    });
    (activeSetupData.blinds||[]).forEach(b=>{
      const g = blindsPlaced[b.id]; if (!g) return;
      ray(L.latLng(g.lat, g.lng), 'var(--blind)');
    });
  }

  /* Listeners: setups + docs */
  async function attachSetupsListener(){
    if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups=null; }
    const qy = query(setupsColl(), orderBy('order'));
    unsubSetups = onSnapshot(qy, snap=>{
      const arr=[]; snap.forEach(d=>{ const data=d.data()||{}; arr.push({ id:d.id, name:data.name||'Setup', order: typeof data.order==='number'?data.order:9999 }); });
      setupsMeta = arr;
      if (!activeSetupId && setupsMeta.length) activeSetupId = setupsMeta[0].id;
      renderTabs();
      attachSetupDocListener();
    });
  }

  function attachSetupDocListener(){
    if (!activeSetupId) return;
    if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc=null; }

    unsubSetupDoc = onSnapshot(setupDoc(), snap=>{
      const d = snap.data()||{};
      let colsShape = d.columns || { dock:[], cols:[{items:[]},{items:[]}] };
      if (Array.isArray(colsShape.cols) && colsShape.cols.every(el=>Array.isArray(el))) {
        colsShape = { dock: Array.isArray(colsShape.dock) ? colsShape.dock : [], cols: colsShape.cols.map(a => ({ items: a.slice() })) };
      }

      activeSetupData = {
        items: Array.isArray(d.items) ? d.items.map(x => ({ id:x.id, dist: typeof x.dist==='number'?x.dist:0 })) : [],
        columns: { dock: colsShape.dock||[], cols: colsShape.cols||[] },
        blinds: Array.isArray(d.blinds) ? d.blinds.map(x => ({ id:x.id, dist: typeof x.dist==='number'?x.dist:0 })) : [],
        geo: d.geo || {}
      };

      buildDock();
      renderMap();
      renderAllArrows();

      if (!hasAutoCentered) {
        const firstPlaced =
          Object.values(activeSetupData.geo?.marks || {})[0] ||
          Object.values(activeSetupData.geo?.blinds || {})[0] ||
          activeSetupData.geo?.trainer;
        if (firstPlaced) {
          map.setView([firstPlaced.lat, firstPlaced.lng], 16);
          hasAutoCentered = true;
        }
      }

      updateHudHeightVar();
    });
  }

  async function setActiveSetup(id){
    activeSetupId = id;
    hasAutoCentered = false;
    renderTabs();
    attachSetupDocListener();
  }

  async function switchDay(key){
    currentDateKey = key;
    if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups=null; }
    if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc=null; }
    setupsMeta=[]; activeSetupId=null; activeSetupData={ items:[], columns:{dock:[], cols:[]}, blinds:[], geo:{} };
    renderTabs(); buildDock(); renderMap();
    hasAutoCentered = false;
    if (trainerId) attachSetupsListener();
  }

  /* Fit + Locate */
  $('#fitBtn').addEventListener('click', ()=>{
    const bounds = L.latLngBounds([]);
    const g = activeSetupData.geo || {};
    if (g.trainer) bounds.extend(g.trainer);
    Object.values(g.marks||{}).forEach(v => bounds.extend(v));
    Object.values(g.blinds||{}).forEach(v => bounds.extend(v));
    if (bounds.isValid()) map.fitBounds(bounds, { padding:[30,30], maxZoom: MAX_COMFORT_ZOOM });
  });

  $('#locBtn').addEventListener('click', ()=>{
    if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
    navigator.geolocation.getCurrentPosition(
      pos => {
        const { latitude, longitude } = pos.coords;
        map.flyTo([latitude, longitude], 16, { duration: 0.9 });
      },
      err => alert('Could not get your location'),
      { enableHighAccuracy:true, timeout:10000, maximumAge:30000 }
    );
  });

  /* -------- Place at me -------- */
function getGPS(){
  return new Promise((resolve, reject)=>{
    if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
    navigator.geolocation.getCurrentPosition(
      p => resolve({ lat:p.coords.latitude, lng:p.coords.longitude }),
      err => reject(err),
      { enableHighAccuracy:true, timeout:12000, maximumAge:5000 }
    );
  });
}

/* tweak these to taste (meters); south is positive here via bearing 180° */
const PLACE_AT_ME_OFFSET_SOUTH_M = 2;   // e.g. nudge 2 m south
const PLACE_AT_ME_OFFSET_EAST_M  = 0;   // optional: positive = east, negative = west

function applyPlaceOffset(ll){
  // move south first (bearing 180), then east/west (bearing 90)
  let out = ll;
  if (PLACE_AT_ME_OFFSET_SOUTH_M) out = destPoint(out, 180, PLACE_AT_ME_OFFSET_SOUTH_M);
  if (PLACE_AT_ME_OFFSET_EAST_M)  out = destPoint(out,  90, PLACE_AT_ME_OFFSET_EAST_M);
  return out;
}


  $('#placeBtn').addEventListener('click', ()=>{
    const opts = [];

    // Trainer if unplaced
    if (!activeSetupData.geo?.trainer){
      opts.push({ type:'trainer', id:'TR', label:'Trainer (TR)' });
    }

    // Marks (unplaced)
    const marksPlaced = activeSetupData.geo?.marks || {};
    (activeSetupData.items||[]).forEach((m, idx)=>{
      if (!marksPlaced[m.id]) opts.push({ type:'mark', id:m.id, label:`Mark M${idx+1}` });
    });

    // Blinds (unplaced)
    const blindsPlaced = activeSetupData.geo?.blinds || {};
    (activeSetupData.blinds||[]).forEach((b, i)=>{
      if (!blindsPlaced[b.id]) opts.push({ type:'blind', id:b.id, label:`Blind B${i+1}` });
    });

    if (!opts.length){ alert('Everything is already placed.'); return; }

    const list = $('#placeList'); list.innerHTML = '';
    opts.forEach(o=>{
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = o.label;
      btn.addEventListener('click', async ()=>{
        try{
          btn.disabled = true; btn.textContent = 'Placing…';
          const p = await getGPS();
const P = applyPlaceOffset(p);

if (o.type==='mark'){
  const hLL = destPoint(P, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);
  await setDoc(setupDoc(), {
    geo: { marks: { [o.id]: { lat:P.lat, lng:P.lng, handle:{ lat:hLL.lat, lng:hLL.lng } } } }
  }, { merge:true });
}else if (o.type==='blind'){
  await setDoc(setupDoc(), {
    geo: { blinds: { [o.id]: { lat:P.lat, lng:P.lng } } }
  }, { merge:true });
}else if (o.type==='trainer'){
  await setDoc(setupDoc(), {
    geo: { trainer: { lat:P.lat, lng:P.lng } }
  }, { merge:true });
}

          placeOverlay.classList.remove('open');
          map.flyTo([p.lat, p.lng], Math.min(MAX_COMFORT_ZOOM, 18), { duration:0.6 });
        }catch(e){
          alert('Unable to get your location.');
          btn.disabled = false; btn.textContent = o.label;
        }
      }, { once:true });
      list.appendChild(btn);
    });

    placeOverlay.classList.add('open');
  });

  $('#raysChk').addEventListener('change', renderRays);

// Long-press to set trainer (desktop) — ignore if press starts on a marker or handle
let pressTimer = null;
map.on('mousedown', (e) => {
  const t = e.originalEvent?.target;
  if (t && (t.closest?.('.leaflet-marker-icon') || t.closest?.('.handle-hit'))) return; // don't hijack marker drags
  pressTimer = setTimeout(async () => {
    await setDoc(setupDoc(), { geo: { trainer: { lat: e.latlng.lat, lng: e.latlng.lng } } }, { merge: true });
  }, 2000);
});
map.on('mouseup',  () => clearTimeout(pressTimer));
map.on('mouseout', () => clearTimeout(pressTimer));


  /* HUD outside map on mobile */
  const hudEl = document.getElementById('hud');
  function updateHudHeightVar(){
    const mobile = window.matchMedia('(max-width: 820px)').matches;
    if (!mobile) { document.body.classList.remove('hud-outside'); document.documentElement.style.setProperty('--hud-h','0px'); return; }
    document.body.classList.add('hud-outside');
    requestAnimationFrame(()=> {
      document.documentElement.style.setProperty('--hud-h', hudEl.offsetHeight + 'px');
    });
  }
  window.addEventListener('resize', updateHudHeightVar);
  updateHudHeightVar();
  if ('ResizeObserver' in window) new ResizeObserver(updateHudHeightVar).observe(hudEl);

  /* Boot */
  async function boot(){
    if (!trainerId) return showTrainerPrompt();
    ctxEl.textContent = `Trainer: ${trainerId}`;
    await switchDay(dayPicker.value);
  }
  if (trainerId) boot(); else showTrainerPrompt();
</script>
</body>
</html>
