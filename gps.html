<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GPS – Setups Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{
    --accent:#0b74ff;
    --ray:#111827;
    --panel:#ffffffcc;
    --bg:#f5f5f5;

    /* populated by JS on mobile */
    --hud-h: 0px;

    /* blues by group index */
    /* blues by group index – higher contrast for groups 1 & 2 */
--g0:#0061ff;   /* Group 1: bright azure */
--g1:#0a2a88;   /* Group 2: deep royal/navy */
--g2:#3b82f6;
--g3:#60a5fa;
--g4:#93c5fd;

    --blind:#16a34a; --trainer:#f97316;
  }

  html, body { height:100%; margin:0; background:var(--bg); font-family:system-ui, sans-serif; }

  /* Map: full height on desktop; on mobile we subtract the HUD height */
  #map { height:100%; width:100%; }
  @supports (height: 100svh) { #map { height:100svh; } }
  @media (max-width: 820px) {
    body.hud-outside #map { height: calc(100svh - var(--hud-h)); }
  }

  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; align-items:center; justify-content:center; z-index:99999; }
  .overlay.open { display:flex; }
  .overlay-card { background:#fff; padding:18px; border-radius:12px; min-width:280px; border:1px solid #e5e5e5; box-shadow:0 10px 30px rgba(0,0,0,.2); }
  .overlay-actions { display:flex; gap:10px; margin-top:12px; justify-content:space-between; flex-wrap:wrap; }
  .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .btn.primary { background:var(--accent); border-color:var(--accent); color:#fff; }
  .btn.ghost { background:#fff; border-color:#ccc; }
  .btn.warn { border-color:#ef4444; color:#b91c1c; }

  /* HUD: fixed overlay on desktop; becomes static block above the map on mobile */
  .hud {
    position:fixed; left:10px; top:10px; z-index:1000;
    display:grid; gap:8px; padding:10px;
    background:var(--panel); backdrop-filter: blur(4px);
    border:1px solid #ddd; border-radius:12px; max-width:min(92vw,520px);
  }
  @media (max-width: 820px) {
    .hud { position:static; max-width:none; margin:10px; backdrop-filter:none; }
  }

  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .tabs { display:flex; gap:6px; flex-wrap:wrap; align-items:flex-end; }
  .tab {
    padding:8px 12px; border:1px solid #ddd; border-bottom:none;
    border-top-left-radius:10px; border-top-right-radius:10px;
    background:#f6f6f6; cursor:pointer; font-weight:600; color:#444;
  }
  .tab.active { background:#fff; color:#111; box-shadow:0 -1px 0 #fff inset; }

  /* Dock floats; on mobile it sits below the HUD height so it never covers the HUD */
  .dock {
    position:fixed; right:10px; top:10px; z-index:1000;
    width:min(92vw, 340px); max-height:80vh; overflow:auto;
    display:grid; gap:10px; padding:10px;
    background:var(--panel); border:1px solid #ddd; border-radius:12px; backdrop-filter: blur(4px);
  }
  @media (max-width: 820px) {
    body.hud-outside .dock { top: calc(10px + var(--hud-h)); }
  }

  .group { border:1px solid #ddd; border-radius:10px; padding:8px; background:#fff; }
  .group h4 { margin:0 0 8px; font-size:14px; display:flex; align-items:center; gap:8px; }
  .swatch { width:12px; height:12px; border-radius:50%; border:1px solid #999; }
  .chips { display:flex; flex-wrap:wrap; gap:8px; }
  .chip { user-select:none; padding:6px 10px; border:1px solid #bbb; border-radius:999px; background:#f7f7f7; cursor:grab; font-weight:600; }
  .chip[draggable="true"]:active { cursor:grabbing; }
  .blind-group h4 .swatch { background:var(--blind); }

  /* Touch-drag ghost for mobile */
  .chip-ghost {
    position: fixed; left:0; top:0; transform:translate(-50%,-50%);
    padding:6px 10px; border:1px solid #bbb; border-radius:999px; background:#fff;
    box-shadow:0 6px 18px rgba(0,0,0,.25);
    z-index: 100000; pointer-events:none; font-weight:700;
  }

  /* Map pills */
  .mk { display:grid; place-items:center; pointer-events:auto; }
  .pill {
    min-width: 28px; height:28px; padding:0 8px; border-radius:14px; color:#fff; font-weight:800; font-size:13px;
    display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(0,0,0,.35); transform:translateY(-4px); border:2px solid #fff;
	white-space: nowrap;
  }

  .handle-hit { width:32px; height:32px; border-radius:50%; background:transparent; display:grid; place-items:center; }
  .handle-dot { width:4px; height:4px; border-radius:50%; background:currentColor; box-shadow:0 0 0 1.5px #fff; }

  .dist-label {
  background:#fff; padding:2px 6px; border-radius:10px;
  border:1px solid #ddd; font-size:12px; color:#111;
  box-shadow:0 1px 4px rgba(0,0,0,.15);
  white-space: nowrap;      /* NEW: don't wrap "199 yd" */
  line-height: 1.1;         /* NEW: tidy vertical spacing */
}

.title-link {
  color: #0066cc;       /* bright link blue */
  text-decoration: underline;
}

  .muted { color:#666; font-size:12px; }
  #fitBtn { display: none !important; }

/* Place overlay should stack its rows */
#placeList{
  display:flex;
  flex-direction:column;   /* stack rows */
  gap:10px;                /* space between rows */
}

/* Each row: normal button flow, not stretched */
#placeList .overlay-actions{
  justify-content:flex-start; /* not space-between */
  flex-wrap:wrap;
}

/* FAB */
.fab {
  position: fixed;
  right: 16px;
  bottom: 16px;
  width: 56px; height: 56px;
  border-radius: 50%;
  border: none;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,.25);
  z-index: 1100;            /* above HUD/Dock, below overlays */
  display: grid; place-items: center;
}
.fab:active { transform: translateY(1px); }

/* 3 dashes icon */
.fab .bars { display: grid; gap: 4px; }
.fab .bars i { display:block; width:22px; height:2px; background:#fff; border-radius:2px; }

/* FAB menu */
.fab-menu {
  position: fixed;
  right: 16px;
  bottom: 80px;             /* sits above the button */
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 12px;
  box-shadow: 0 12px 30px rgba(0,0,0,.2);
  padding: 8px;
  z-index: 1100;
  display: none;
  min-width: 160px;
}
.fab-menu.open { display: block; }
.fab-menu a {
  display: block;
  padding: 10px 12px;
  border-radius: 8px;
  color: #111;
  text-decoration: none;
}
.fab-menu a:hover { background: #f5f5f5; }

/* allow hiding the dock */
.dock.hidden { display: none !important; }


</style>
</head>
<body>

<!-- Trainer chooser -->
<div class="overlay" id="trainerOverlay">
  <div class="overlay-card">
    <h3>Who are you?</h3>
    <div class="overlay-actions">
      <button class="btn primary" data-trainer="Scott">Scott</button>
      <button class="btn primary" data-trainer="Cody">Cody</button>
      <button class="btn primary" data-trainer="Brian">Brian</button>
    </div>
  </div>
</div>

<!-- No-setup prompt -->
<div class="overlay" id="noSetupOverlay">
  <div class="overlay-card">
    <h3>No setup for this day</h3>
    <p id="noSetupMsg" class="muted" style="margin:8px 0 0">
      <!-- filled by JS -->
    </p>
    <div class="overlay-actions">
      <button class="btn primary" id="createSetupYes">Yes</button>
      <button class="btn" id="createSetupNo">No</button>
    </div>
  </div>
</div>


<!-- Place-at-me chooser -->
<div class="overlay" id="placeOverlay">
  <div class="overlay-card">
    <h3>Place at my location</h3>
    <div id="placeList" class="overlay-actions"></div>
    <div class="overlay-actions">
      <button class="btn" id="placeCancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Group picker overlay (ADD) -->
<div class="overlay" id="groupOverlay">
  <div class="overlay-card" style="min-width:320px;">
    <h3>Choose a group</h3>
    <div id="groupList" class="overlay-actions" style="justify-content:flex-start"></div>
    <div class="overlay-actions" style="justify-content:flex-end">
      <button class="btn" id="groupCancel">Cancel</button>
    </div>
  </div>
</div>


<!-- HUD -->
<div class="hud" id="hud">
  <div class="row">
<h2 style="margin:0">
  GPS – <a id="setupsLink" class="title-link" href="#">Setups</a> Map
</h2>

    <a id="changeUserLink" class="muted" href="#">change user</a>
    <div id="ctx" class="muted">Loading…</div>
  </div>

  <div class="row">
    <label>Day: <input type="date" id="dayPicker"></label>
    <button class="btn ghost" id="todayBtn">Today</button>
    <div class="tabs" id="tabs"></div>
  </div>

  <div class="row">
    <button class="btn" id="locBtn">Location</button>
    <button class="btn" id="fitBtn">Fit All</button>
    <button class="btn primary" id="placeBtn">Place at me</button>
    <label style="display:flex;align-items:center;gap:6px;margin-left:auto;">
      <input id="raysChk" type="checkbox" />
      <span>Distances</span>
    </label>
  </div>
</div>

<!-- Dock -->
<div class="dock" id="dock">
  <div class="muted">Fetching setups…</div>
</div>

<div id="map"></div>

<button id="fab" class="fab" aria-haspopup="true" aria-controls="fabMenu" aria-label="More">
  <span class="bars">
    <i></i><i></i><i></i>
  </span>
</button>

<div id="fabMenu" class="fab-menu" role="menu" aria-hidden="true">
  <a id="fabChangeTrainer" href="#" role="menuitem">Change trainer</a>
<a id="fabLoadSetup"    href="#" role="menuitem">Load setup…</a>
	
	<a id="fabSetup"  href="#" role="menuitem">Setup</a>
  <a id="fabScores" href="#" role="menuitem">Scores</a>
  <a id="fabDockToggle" href="#" role="menuitem">Hide dock</a>
</div>


<script type="module">
  /* ---------------- Firebase (v10) ---------------- */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
  getFirestore, doc, setDoc, updateDoc, onSnapshot,
  collection, query, orderBy, deleteField,
  getDocs, getDoc, limit, runTransaction
} from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";


  const firebaseConfig = {
    apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
    authDomain: "task-tracker-73b77.firebaseapp.com",
    projectId: "task-tracker-73b77",
    storageBucket: "task-tracker-73b77.firebasestorage.app",
    messagingSenderId: "795274673000",
    appId: "1:795274673000:web:0ea07130e45c72384134dd",
    measurementId: "G-VLW5KLY4FF"
  };
  const app = initializeApp(firebaseConfig);
  const db  = getFirestore(app);

  /* ---------------- Utilities ---------------- */
  const $ = s => document.querySelector(s);
  function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
  const GROUP_BLUES = ['var(--g0)','var(--g1)','var(--g2)','var(--g3)','var(--g4)'];

let currentHeading = null;  // store last known compass heading

// Compass listener
if (window.DeviceOrientationEvent) {
  if (typeof DeviceOrientationEvent.requestPermission === "function") {
    document.body.addEventListener("click", () => {
      DeviceOrientationEvent.requestPermission().then(state => {
        if (state === "granted") {
          window.addEventListener("deviceorientationabsolute", (e) => {
            if (e.alpha != null) {
              currentHeading = 360 - e.alpha;
              document.getElementById("headingDebug").textContent = "Heading: " + Math.round(currentHeading) + "°";
            }
          });
        }
      }).catch(console.warn);
    }, { once:true });
  } else {
    window.addEventListener("deviceorientationabsolute", (e) => {
      if (e.alpha != null) {
        currentHeading = 360 - e.alpha;
        document.getElementById("headingDebug").textContent = "Heading: " + Math.round(currentHeading) + "°";
      }
    });
  }
}

// Qualifier -> suffix
function qualSuffix(mark){
  const o = mark?.options || {};
  if (o.retire)     return ' RT';
  if (o.whiteCoat)  return ' WC';
  if (o.handTossed) return ' HT';
  if (o.goBird)     return ' GO';
  return '';
}


/* ---- UI scale knob (0.7 = smaller, 1 = current, 1.3 = larger) ---- */
const PILL_SCALE = 0.5;   // try 0.85 first on phone
const SETUPS_URL = 'https://morrowind4732.github.io/task-tracker/setups.html';
const PROFILE_URL = 'https://morrowind4732.github.io/task-tracker/profile.html';



/* ================= Setup ensure + append helpers (ADD) ================= */

function newId(prefix){
  // short unique id (e.g., "m_x7k3f9")
  return `${prefix}_${Math.random().toString(36).slice(2,8)}`;
}

async function ensureActiveSetupExists(){
  // Ensure trainer/day is chosen
  if (!trainerId) throw new Error('No trainer selected');
  if (!currentDateKey) currentDateKey = ymd(new Date());

  // If we already have an active setup id, we're good
  if (activeSetupId) return activeSetupId;

  // See if there is any setup doc — if so, the listener will set activeSetupId
  const snap = await getDocs(query(setupsColl(), limit(1)));
  if (!snap.empty){
    // pick first; listener will populate activeSetupId
    const first = snap.docs[0];
    activeSetupId = first.id;
    return activeSetupId;
  }

  // Create a new setup (order=1) with 2 default groups
  const ref = doc(setupsColl());
  const seed = {
    order: 1,
    name: 'Setup 1',
    items: [],
    blinds: [],
    columns: {
      dock: [],
      cols: [ { items: [] }, { items: [] } ]   // default two groups
    },
    geo: {}
  };
  await setDoc(ref, seed, { merge: true });
  activeSetupId = ref.id;
  renderTabs();        // show the tab
  attachSetupDocListener(); // begin listening to the new doc
  return activeSetupId;
}

function openGroupPicker({ onPick, allowAdd=true }){
  const ov   = document.getElementById('groupOverlay');
  const list = document.getElementById('groupList');
  const cancel = document.getElementById('groupCancel');

  // Build current groups (fallback to 2 if missing)
  const cols = Array.isArray(activeSetupData.columns?.cols) && activeSetupData.columns.cols.length
    ? activeSetupData.columns.cols
    : [{items:[]},{items:[]}];

  list.innerHTML = '';

  cols.forEach((_, i) => {
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = `Group ${i+1}`;
    b.addEventListener('click', () => {
      close(); onPick({ index: i, addedNew: false });
    }, { once:true });
    list.appendChild(b);
  });

  if (allowAdd){
    const add = document.createElement('button');
    add.className = 'btn primary';
    add.textContent = '+ Group';
    add.addEventListener('click', () => {
      close(); onPick({ index: cols.length, addedNew: true });
    }, { once:true });
    list.appendChild(add);
  }

  function close(){
    ov.classList.remove('open');
  }
  cancel.onclick = close;
  ov.classList.add('open');
}

/** Append a new Mark/Blind into the setup safely (transaction; no overwrites). */
async function appendSetupItem({ kind, groupIndex }){
  if (kind !== 'mark' && kind !== 'blind') throw new Error('kind must be "mark" or "blind"');

  await ensureActiveSetupExists();
  const sref = setupDoc();
  if (!sref) throw new Error('No setup doc');

  const newItemId = newId(kind === 'mark' ? 'm' : 'b');

  await runTransaction(db, async (tx) => {
    const snap = await tx.get(sref);
    const d = snap.exists() ? (snap.data() || {}) : {};

    // Ensure shapes
    const items  = Array.isArray(d.items)  ? d.items.slice()  : [];
    const blinds = Array.isArray(d.blinds) ? d.blinds.slice() : [];
    const cols   = Array.isArray(d.columns?.cols) ? d.columns.cols.map(c => ({ items: Array.isArray(c.items)?c.items.slice():[] })) : [{items:[]},{items:[]}];
    const dock   = Array.isArray(d.columns?.dock) ? d.columns.dock.slice() : [];

    // Expand groups if needed (e.g., "+ Group" case)
    while (groupIndex >= cols.length) cols.push({ items: [] });

    if (kind === 'mark'){
      items.push({ id: newItemId, dist: 0 });
      cols[groupIndex].items.push(newItemId);
      tx.set(sref, { items, columns: { dock, cols } }, { merge: true });
    } else {
      blinds.push({ id: newItemId, dist: 0 });
      // Blinds are not grouped in columns; nothing to push to group
      tx.set(sref, { blinds, columns: { dock, cols } }, { merge: true });
    }
  });

  return newItemId;
}



/* Place a newly added item at current GPS (same offsets & distance writers) */
async function placeNewlyAdded(kind, id){
  const p = await getGPS();
  const P = applyPlaceOffset(p);
  const payload = { type: kind, id, label: '' }; // label not needed by placeItem()

  await placeItem(payload, L.latLng(P.lat, P.lng));
  // Center the map like other "place at me" actions
  map.flyTo([p.lat, p.lng], Math.min(MAX_COMFORT_ZOOM, 18), { duration: 0.6 });
}


  /* Mobile placement state */
  let pendingPlacement = null;
  function showPlacingMsg(what){ $('#ctx').textContent = `Placing ${what} — tap on the map`; $('#ctx').style.fontWeight='700'; }
  function clearPlacingMsg(){ $('#ctx').textContent = `Trainer: ${trainerId}`; $('#ctx').style.fontWeight='400'; }

  /* Trainer picker */
  const overlay = $('#trainerOverlay');
  const placeOverlay = $('#placeOverlay');
  const ctxEl   = $('#ctx');
  $('#placeCancel').addEventListener('click', ()=> placeOverlay.classList.remove('open'));



  let trainerId = (new URL(location.href)).searchParams.get('trainer') || '';
  updateSetupsLink();
updateFabLinks();
updateFabDockLabel();   // <-- add here


  $('#changeUserLink').addEventListener('click', (e)=> {
  e.preventDefault();
  const url = new URL(location.href);
  url.searchParams.delete('trainer');
  history.replaceState(null,'',url.toString());
  trainerId = '';
  updateSetupsLink();
updateFabLinks();
updateFabDockLabel();   // <-- add here

  showTrainerPrompt();
});

  
  function setTrainer(name){
    trainerId = name;
    const url = new URL(location.href); url.searchParams.set('trainer', trainerId);
    history.replaceState(null,'',url.toString());
    ctxEl.textContent = `Trainer: ${trainerId}`;
	updateSetupsLink();
updateFabLinks();
updateFabDockLabel();   // <-- add here

    boot();
  }
  
  function showTrainerPrompt(){
    overlay.classList.add('open');
    overlay.querySelectorAll('button[data-trainer]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        overlay.classList.remove('open');
        setTrainer(btn.dataset.trainer);
      }, { once:true });
    });
  }
  
  
  // --- "No setup / No objectives" overlay wiring ---
const noSetupOverlay = document.getElementById('noSetupOverlay');
const noSetupMsg     = document.getElementById('noSetupMsg');
const noSetupTitleEl = noSetupOverlay.querySelector('h3');

document.getElementById('createSetupNo').addEventListener('click', () => {
  noSetupOverlay.classList.remove('open');
});
document.getElementById('createSetupYes').addEventListener('click', () => {
  const url = new URL('https://morrowind4732.github.io/task-tracker/setups.html');
  url.searchParams.set('trainer', trainerId || '');
  location.href = url.toString();
});

/** Helper to open the overlay with custom text */
function promptToSetups(title, msg) {
  noSetupTitleEl.textContent = title;
  noSetupMsg.textContent = msg;
  noSetupOverlay.classList.add('open');
}

// Avoid nagging: only prompt once per trainer+day per load
const promptedNoSetup       = new Set(); // “no setups at all” check
const promptedNoObjectives  = new Set(); // “blank setup (no marks/blinds)” check

/** Primary check: does any setup doc exist for this trainer/day? */
async function checkForSetupAndPrompt(){
  if (!trainerId) return;
  const key = `${trainerId}|${currentDateKey}`;
  if (promptedNoSetup.has(key)) return;

  try {
    const snap = await getDocs(query(setupsColl(), limit(1)));
    if (snap.empty) {
      promptToSetups(
        'No setup for this day',
        `No setup found for ${trainerId} on ${currentDateKey}. Create one now?`
      );
    }
  } catch (e) {
    console.warn('checkForSetupAndPrompt failed:', e);
  } finally {
    promptedNoSetup.add(key);
  }
}

/** Secondary check: setup exists but no marks/blinds (dock OR map) */
function checkForObjectivesAndPrompt(docExists){
  if (!trainerId || !docExists) return;
  const key = `${trainerId}|${currentDateKey}`;
  if (promptedNoObjectives.has(key)) return;

  const hasConfigured =
    (activeSetupData.items?.length || 0) > 0 ||
    (activeSetupData.blinds?.length || 0) > 0;

  const hasPlaced =
    Object.keys(activeSetupData.geo?.marks  || {}).length > 0 ||
    Object.keys(activeSetupData.geo?.blinds || {}).length > 0;

  if (!hasConfigured && !hasPlaced) {
    promptToSetups(
      'No objectives yet',
      `No marks or blinds found for ${trainerId} on ${currentDateKey}. Go to the setup page to add objectives?`
    );
    promptedNoObjectives.add(key);
  }
}


  
  if (trainerId) ctxEl.textContent = `Trainer: ${trainerId}`;

  /* Date + tabs */
  const dayPicker = $('#dayPicker');
  const todayBtn  = $('#todayBtn');
  dayPicker.value = ymd(new Date());
  todayBtn.addEventListener('click', ()=>{ dayPicker.value = ymd(new Date()); switchDay(dayPicker.value); });
  dayPicker.addEventListener('change', ()=> switchDay(dayPicker.value));
  const tabsEl = $('#tabs');

  let currentDateKey = dayPicker.value;
  let setupsMeta = [];
  let activeSetupId = null;

  const dayDocPath = () => doc(db, 'setups', trainerId, 'days', currentDateKey);
  const setupsColl = () => collection(dayDocPath(), 'setups');
  const setupDoc   = () => (activeSetupId ? doc(setupsColl(), activeSetupId) : null);

  /* Map */
  const MAX_COMFORT_ZOOM = 19; // ⬅ bumped from 17
  const FIT_MIN_ZOOM = 18;          // don’t zoom out past this
const FIT_PADDING  = [20, 20];    // pixels of padding around the fit
const FIT_MAX_CLUSTER_KM = 1;     // ignore points farther than this from the cluster center

const START_ZOOM_PLACED = 18;
  const map = L.map('map', { maxZoom: MAX_COMFORT_ZOOM }).setView([39.5,-98.35], 5);
  let hasAutoCentered = false;
  L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom:20, maxNativeZoom:17, attribution:'&copy; Esri, Maxar, Earthstar Geographics' }).addTo(map);
  L.control.scale({imperial:true, metric:false}).addTo(map);
  map.on('zoomend', renderAllArrows);

const distPane = map.createPane('distPane');
distPane.style.zIndex = 650;          // above markerPane (600), below popupPane (700)
distPane.style.pointerEvents = 'none';

  const markLines  = L.layerGroup().addTo(map);
  const markPins   = L.layerGroup().addTo(map);
  const markDots   = L.layerGroup().addTo(map);
  const blindPins  = L.layerGroup().addTo(map);
  const trainerLay = L.layerGroup().addTo(map);
  const raysLayer  = L.layerGroup().addTo(map);
  const distLabels = L.layerGroup().addTo(map);

  function iconPill(text, colorCSS){
  const H       = Math.round(28 * PILL_SCALE);
  const PADX    = Math.round(8  * PILL_SCALE);
  const FZ      = Math.max(11, Math.round(13 * PILL_SCALE));
  const BORDER  = Math.max(1,  Math.round( 2 * PILL_SCALE));
  const lift    = Math.round(-4 * PILL_SCALE);
  const anchorY = Math.max(0, H - Math.round(4 * PILL_SCALE));

  const html = `<div class="pill"
                  style="
                    background:${colorCSS};
                    height:${H}px; padding:0 ${PADX}px;
                    font-size:${FZ}px; border-width:${BORDER}px;
                    border-radius:${Math.round(H/2)}px;
                    display:inline-flex; align-items:center; justify-content:center;
                    white-space:nowrap;
                    transform:translateY(${lift}px)
                  ">
                  ${text}
                </div>`;

  // Let CSS decide width initially; we'll measure and correct on 'add'
  return L.divIcon({
    className: 'mk',
    html,
    iconSize: null,                          // <-- no fixed width
    iconAnchor: [Math.round(H/2), anchorY],  // provisional; fixed after measure
  });
}


function updateSetupsLink() {
  const a = document.getElementById('setupsLink');
  if (!a) return;
  const url = new URL(SETUPS_URL);
  if (trainerId) url.searchParams.set('trainer', trainerId);
  a.href = url.toString();
}


function makeTrainerUrl(base){
  const url = new URL(base);
  if (trainerId) url.searchParams.set('trainer', trainerId);
  return url.toString();
}

function updateFabLinks(){
  const setupA  = document.getElementById('fabSetup');
  const scoresA = document.getElementById('fabScores');
  if (!setupA || !scoresA) return;
  setupA.href  = makeTrainerUrl(SETUPS_URL);
  scoresA.href = makeTrainerUrl(PROFILE_URL);
}


function isDockVisible(){
  const d = document.getElementById('dock');
  return d && !d.classList.contains('hidden');
}
function setDockVisible(show){
  const d = document.getElementById('dock');
  if (!d) return;
  d.classList.toggle('hidden', !show);
  updateFabDockLabel();
}
function updateFabDockLabel(){
  const a = document.getElementById('fabDockToggle');
  if (!a) return;
  a.textContent = isDockVisible() ? 'Hide dock' : 'Show dock';
}

document.getElementById('fabDockToggle')?.addEventListener('click', (e)=>{
  e.preventDefault();
  setDockVisible(!isDockVisible());
});




  /* pill size helper */
function sizeMarkerPill(marker) {
  marker.on('add', () => {
    if (marker.__sized) return;        // guard so we don't loop after setIcon()
    const el = marker._icon;
    if (!el) return;

    // keep the marker icon interactive (your existing fix)
    el.style.pointerEvents = 'auto';

    const pill = el.querySelector('.pill');
    const w = (pill?.offsetWidth) || 0;
    if (!w) return;

    const H       = Math.round(28 * PILL_SCALE);
    const anchorY = Math.max(0, H - Math.round(4 * PILL_SCALE));

    marker.__sized = true;
    marker.setIcon(L.divIcon({
      className: 'mk',
      html: el.innerHTML,                 // same pill HTML
      iconSize: [w, H],                   // <-- exact width
      iconAnchor: [Math.round(w/2), anchorY],
    }));
  });
}


  const handleIcon = (colorCSS) => {
  const HS  = Math.round(32 * PILL_SCALE);                // handle hit area
  const DOT = Math.max(3, Math.round(4 * PILL_SCALE));    // actual dot size
  const html = `<div class="handle-hit"
                   style="width:${HS}px; height:${HS}px">
                  <div class="handle-dot"
                       style="width:${DOT}px; height:${DOT}px; color:${colorCSS}"></div>
                </div>`;
  return L.divIcon({
    className:'mk',
    html,
    iconSize:[HS,HS],
    iconAnchor:[Math.round(HS/2), Math.round(HS/2)]
  });
};


  /* Geo utils */
  const Rm = 6371000;
  const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
  function distanceMeters(a,b){ return map.distance(a,b); }
  function yards(m){ return m*1.09361; }
  function fmtYards(m){ return `${Math.round(yards(m))} yd`; }
  
 // ---- Distance writers (yards) ----
const DEBUG_DIST = true;
const dlog  = (...a) => DEBUG_DIST && console.log('[DIST]', ...a);
const dwarn = (...a) => DEBUG_DIST && console.warn('[DIST]', ...a);

function yardsBetween(ll1, ll2){
  const meters = distanceMeters(ll1, ll2);
  const yardsV = yards(meters);
  dlog('yardsBetween()', { ll1, ll2, meters, yards: yardsV, rounded: Math.round(yardsV) });
  return Math.round(yardsV);
}

// mark: update items[].dist for one id
async function writeMarkDistance(id, A){
  const t = activeSetupData.geo?.trainer;
  const docPath = `setups/${trainerId}/days/${currentDateKey}/setups/${activeSetupId}`;
  if (!t) { dwarn('writeMarkDistance: no trainer — skipping', { id, docPath }); return; }

  const T   = L.latLng(t.lat, t.lng);
  const yds = yardsBetween(T, A);

  const before = activeSetupData.items || [];
  const idx    = before.findIndex(it => it.id === id);
  if (idx === -1) dwarn('writeMarkDistance: mark id not found in items[]', { id, itemIds: before.map(i=>i.id) });

  const items = before.map(it => it.id === id ? ({ ...it, dist: yds }) : it);

  dlog('writeMarkDistance -> setDoc', {
    docPath, id, trainer:T, A, yds,
    itemsCount: items.length, updatedIndex: idx
  });

  await setDoc(setupDoc(), { items }, { merge:true });
  dlog('writeMarkDistance: DONE', { id, yds });
}

// blind: update blinds[].dist for one id
async function writeBlindDistance(id, B){
  const t = activeSetupData.geo?.trainer;
  const docPath = `setups/${trainerId}/days/${currentDateKey}/setups/${activeSetupId}`;
  if (!t) { dwarn('writeBlindDistance: no trainer — skipping', { id, docPath }); return; }

  const T   = L.latLng(t.lat, t.lng);
  const yds = yardsBetween(T, B);

  const before = activeSetupData.blinds || [];
  const idx    = before.findIndex(b => b.id === id);
  if (idx === -1) dwarn('writeBlindDistance: blind id not found in blinds[]', { id, blindIds: before.map(b=>b.id) });

  const blinds = before.map(b => b.id === id ? ({ ...b, dist: yds }) : b);

  dlog('writeBlindDistance -> setDoc', {
    docPath, id, trainer:T, B, yds,
    blindsCount: blinds.length, updatedIndex: idx
  });

  await setDoc(setupDoc(), { blinds }, { merge:true });
  dlog('writeBlindDistance: DONE', { id, yds });
}

// trainer moved/placed: recompute all distances
async function writeAllDistancesFromTrainer(T){
  const docPath = `setups/${trainerId}/days/${currentDateKey}/setups/${activeSetupId}`;
  dlog('writeAllDistancesFromTrainer: recomputing', {
    docPath, trainer:T,
    itemsBefore: (activeSetupData.items||[]).length,
    blindsBefore: (activeSetupData.blinds||[]).length
  });

  const items = (activeSetupData.items||[]).map(it => {
    const g = activeSetupData.geo?.marks?.[it.id];
    if (!g) return it;
    const A = L.latLng(g.lat, g.lng);
    return { ...it, dist: yardsBetween(T, A) };
  });

  const blinds = (activeSetupData.blinds||[]).map(b => {
    const g = activeSetupData.geo?.blinds?.[b.id];
    if (!g) return b;
    const B = L.latLng(g.lat, g.lng);
    return { ...b, dist: yardsBetween(T, B) };
  });

  dlog('writeAllDistancesFromTrainer -> setDoc (preview first few)', {
    items: items.slice(0,5).map(i => ({ id:i.id, dist:i.dist })),
    blinds: blinds.slice(0,5).map(b => ({ id:b.id, dist:b.dist }))
  });

  await setDoc(setupDoc(), { items, blinds }, { merge:true });
  dlog('writeAllDistancesFromTrainer: DONE');
}


  
 function bearing(a,b){
  const φ1=toRad(a.lat), φ2=toRad(b.lat), λ1=toRad(a.lng), λ2=toRad(b.lng);
  const y = Math.sin(λ2-λ1)*Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
  return ((toDeg(Math.atan2(y,x))+360)%360);
}

  function destPoint(start, brgDeg, distM){
    const δ = distM / Rm, θ = toRad(brgDeg);
    const φ1 = toRad(start.lat), λ1 = toRad(start.lng);
    const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
    const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
    const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
    const φ2 = Math.asin(sinφ2);
    const y = Math.sin(θ)*sinδ*cosφ1;
    const x = cosδ - sinφ1*sinφ2;
    const λ2 = λ1 + Math.atan2(y, x);
    return L.latLng(toDeg(φ2), ((toDeg(λ2)+540)%360)-180);
  }

  const DEFAULT_ARROW_BRG = 315;
  const DEFAULT_ARROW_LEN = 60;
  const MIN_ARROW_VISIBLE = 12;

  function drawArrow(A, B, colorCSS){
    L.polyline([A,B], { color: colorCSS, weight:4, opacity:0.95, interactive:false }).addTo(markLines);
    const z = map.getZoom();
    const aPt = map.project(A, z), bPt = map.project(B, z);
    const v = bPt.subtract(aPt); const len = Math.hypot(v.x, v.y); if (!len) return;
    const ux=v.x/len, uy=v.y/len;
    const headLen = 18, headAng = 32*Math.PI/180;
    const lx = bPt.x - headLen*( ux*Math.cos(headAng) - uy*Math.sin(headAng) );
    const ly = bPt.y - headLen*( uy*Math.cos(headAng) + ux*Math.sin(headAng) );
    const rx = bPt.x - headLen*( ux*Math.cos(headAng) + uy*Math.sin(headAng) );
    const ry = bPt.y - headLen*( uy*Math.cos(headAng) - ux*Math.sin(headAng) );
    const L1 = map.unproject(L.point(lx,ly), z);
    const L2 = map.unproject(L.point(rx,ry), z);
    L.polyline([B,L1], { color: colorCSS, weight:4, opacity:0.95, interactive:false }).addTo(markLines);
    L.polyline([B,L2], { color: colorCSS, weight:4, opacity:0.95, interactive:false }).addTo(markLines);
  }

  /* State */
  let activeSetupData = { items:[], columns:{dock:[], cols:[]}, blinds:[], geo:{} };
  let unsubSetups = null, unsubSetupDoc = null;

  function renderTabs(){
    tabsEl.innerHTML = '';
    setupsMeta.sort((a,b)=>(a.order??0)-(b.order??0)).forEach((m, idx)=>{
      const b = document.createElement('button');
      b.className = 'tab' + (m.id===activeSetupId ? ' active' : '');
      b.textContent = m.name || `Setup ${idx+1}`;
      b.addEventListener('click', ()=> setActiveSetup(m.id));
      tabsEl.appendChild(b);
    });
  }

  function renderAllArrows() {
    markLines.clearLayers();
    const marksPlaced = activeSetupData.geo?.marks || {};
    const cols = Array.isArray(activeSetupData.columns?.cols) ? activeSetupData.columns.cols : [];
    const groupOf = (id)=>{ for (let i=0;i<cols.length;i++){ if ((cols[i].items||[]).includes(id)) return i; } return 0; };
    activeSetupData.items.forEach(it => {
      const g = marksPlaced[it.id]; if (!g) return;
      const color = GROUP_BLUES[groupOf(it.id) % GROUP_BLUES.length];
      const A = L.latLng(g.lat, g.lng);
      const H = g.handle ? L.latLng(g.handle.lat, g.handle.lng) : destPoint(A, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);
      drawArrow(A, H, color);
    });
    renderRays();
  }

  /* Desktop drag + Mobile touch drag + Tap-to-place */
  let touchDrag = null;
  let justDidTouchDrop = false;

  function startTouchDrag(chip, data, touch){
    justDidTouchDrop = false;
    const ghost = document.createElement('div');
    ghost.className = 'chip-ghost';
    ghost.textContent = chip.textContent.trim();
    document.body.appendChild(ghost);
    positionGhost(ghost, touch.clientX, touch.clientY);
    try { map.dragging.disable(); map.touchZoom.disable(); map.boxZoom.disable(); map.doubleClickZoom.disable(); map.scrollWheelZoom.disable(); } catch {}
    touchDrag = { data, ghost };
  }
  function positionGhost(ghost, x, y){ ghost.style.left = x + 'px'; ghost.style.top = y + 'px'; }
  async function endTouchDrag(touch){
    if (!touchDrag) return;
    const { data, ghost } = touchDrag;
    touchDrag = null;
    ghost.remove();
    try { map.dragging.enable(); map.touchZoom.enable(); map.boxZoom.enable(); map.doubleClickZoom.enable(); map.scrollWheelZoom.enable(); } catch {}
    const rect = map.getContainer().getBoundingClientRect();
    const inside = touch.clientX>=rect.left && touch.clientX<=rect.right && touch.clientY>=rect.top && touch.clientY<=rect.bottom;
    if (!inside) return;
    const pt = L.point(touch.clientX-rect.left, touch.clientY-rect.top);
    const ll = map.containerPointToLatLng(pt);
    await placeItem(data, ll);
    justDidTouchDrop = true;
  }

  function wireDockChips(container){
    container.querySelectorAll('.chip').forEach(ch => {
      const data = { type: ch.dataset.type, id: ch.dataset.id, color: ch.dataset.color };
      ch.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', JSON.stringify(data)); e.dataTransfer.effectAllowed = 'copy'; });
      ch.addEventListener('touchstart', e => { if (e.touches && e.touches[0]) { e.preventDefault(); startTouchDrag(ch, data, e.touches[0]); } }, { passive:false });
      ch.addEventListener('click', e => {
        if (justDidTouchDrop) { justDidTouchDrop=false; return; }
        e.preventDefault(); pendingPlacement = data;
        const label = ch.textContent.trim(); showPlacingMsg(label || (pendingPlacement.type==='trainer' ? 'TR' : 'Item'));
      }, { passive:true });
    });
  }
  window.addEventListener('touchmove', e => { if (!touchDrag) return; e.preventDefault(); if (e.touches && e.touches[0]) positionGhost(touchDrag.ghost, e.touches[0].clientX, e.touches[0].clientY); }, { passive:false });
  window.addEventListener('touchend', e => { if (!touchDrag) return; const t = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0] : null; if (t) endTouchDrag(t); }, { passive:false });
  window.addEventListener('touchcancel', () => { if (touchDrag){ touchDrag.ghost.remove(); touchDrag=null; } }, { passive:true });

  /* Dock building */
  function buildDock(){
    const dock = $('#dock');
    dock.innerHTML = '';

    if (!activeSetupData.items.length && !activeSetupData.blinds.length && activeSetupData.geo?.trainer) {
      dock.innerHTML = '<div class="muted">Everything is placed.</div>';
      return;
    }

    // Trainer chip if not placed
    if (!activeSetupData.geo?.trainer){
      const tBox = document.createElement('div');
      tBox.className = 'group';
      tBox.innerHTML = `<h4><span class="swatch" style="background:var(--trainer)"></span>Trainer</h4>
                        <div class="chips">
                          <div class="chip" draggable="true" data-type="trainer" data-id="TR" data-color="var(--trainer)">TR</div>
                        </div>`;
      dock.appendChild(tBox);
    }

    // Groups
    const cols = Array.isArray(activeSetupData.columns?.cols) ? activeSetupData.columns.cols : [];
    cols.forEach((col, gi) => {
      const color = GROUP_BLUES[gi % GROUP_BLUES.length];
      const box = document.createElement('div');
      box.className = 'group';
      box.innerHTML = `<h4><span class="swatch" style="background:${color}"></span>Group ${gi+1}</h4><div class="chips"></div>`;
      const chips = box.querySelector('.chips');

      (col.items||[]).forEach(id=>{
        if (activeSetupData.geo?.marks?.[id]) return;
        const idx = activeSetupData.items.findIndex(i=>i.id===id);
        const chip = document.createElement('div');
        chip.className='chip'; chip.draggable=true; const suffix = idx >= 0 ? qualSuffix(activeSetupData.items[idx]) : '';
chip.textContent = `M${idx >= 0 ? idx+1 : '?'}${suffix}`;

        chip.dataset.type='mark'; chip.dataset.id=id; chip.dataset.color=color;
        chips.appendChild(chip);
      });

      if (chips.children.length) dock.appendChild(box);
    });

    // Ungrouped
    const groupedIds = new Set((Array.isArray(activeSetupData.columns?.cols)?activeSetupData.columns.cols:[]).flatMap(c => c.items||[]));
    const ungroup = activeSetupData.items.filter(m => !groupedIds.has(m.id)).map(m => m.id);
    if (ungroup.length){
      const color = GROUP_BLUES[0];
      const box = document.createElement('div');
      box.className = 'group';
      box.innerHTML = `<h4><span class="swatch" style="background:${color}"></span>Ungrouped Marks</h4><div class="chips"></div>`;
      const chips = box.querySelector('.chips');
      ungroup.forEach(id=>{
        if (activeSetupData.geo?.marks?.[id]) return;
        const idx = activeSetupData.items.findIndex(i=>i.id===id);
        const chip = document.createElement('div');
        chip.className='chip'; chip.draggable=true; const suffix = idx >= 0 ? qualSuffix(activeSetupData.items[idx]) : '';
chip.textContent = `M${idx >= 0 ? idx+1 : '?'}${suffix}`;

        chip.dataset.type='mark'; chip.dataset.id=id; chip.dataset.color=color;
        chips.appendChild(chip);
      });
      if (chips.children.length) dock.appendChild(box);
    }

    // Blinds
    const bBox = document.createElement('div');
    bBox.className = 'group blind-group';
    bBox.innerHTML = `<h4><span class="swatch"></span>Blinds</h4><div class="chips"></div>`;
    const bChips = bBox.querySelector('.chips');
    (activeSetupData.blinds||[]).forEach((b,i)=>{
      if (activeSetupData.geo?.blinds?.[b.id]) return;
      const chip = document.createElement('div');
      chip.className='chip'; chip.draggable=true; chip.textContent=`B${i+1}`;
      chip.dataset.type='blind'; chip.dataset.id=b.id; chip.dataset.color=getComputedStyle(document.documentElement).getPropertyValue('--blind').trim();
      bChips.appendChild(chip);
    });
    if (bChips.children.length) dock.appendChild(bBox);

    wireDockChips(dock);
  }

async function placeItem(data, ll){
if (data.type === 'mark') {
  const heading = (currentHeading != null ? currentHeading : DEFAULT_ARROW_BRG);
  const hLL = destPoint(ll, heading, DEFAULT_ARROW_LEN);
  await setDoc(setupDoc(), { geo: { marks: { [data.id]: { lat: ll.lat, lng: ll.lng, handle: { lat: hLL.lat, lng: hLL.lng } } } } }, { merge:true });
  await writeMarkDistance(data.id, L.latLng(ll.lat, ll.lng));
}
 else if (data.type === 'blind') {
    await setDoc(setupDoc(), { geo: { blinds: { [data.id]: { lat: ll.lat, lng: ll.lng } } } }, { merge:true });
    await writeBlindDistance(data.id, L.latLng(ll.lat, ll.lng));          // <—
  } else if (data.type === 'trainer') {
    await setDoc(setupDoc(), { geo: { trainer: { lat: ll.lat, lng: ll.lng } } }, { merge:true });
    await writeAllDistancesFromTrainer(L.latLng(ll.lat, ll.lng));         // <—
  }
}


  /* Desktop drop target */
  const mapEl = map.getContainer();
  mapEl.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
  mapEl.addEventListener('drop', async e => {
    e.preventDefault();
    const data = JSON.parse(e.dataTransfer.getData('text/plain')||'{}');
    if (!data || !data.id || !data.type) return;
    const rect = mapEl.getBoundingClientRect();
    const pt = L.point(e.clientX-rect.left, e.clientY-rect.top);
    const ll = map.containerPointToLatLng(pt);
    await placeItem(data, ll);
  });

  /* Tap-to-place fallback */
  map.on('click', async (e) => {
    if (!pendingPlacement) return;
    const ll = e.latlng;
    try { await placeItem(pendingPlacement, ll); }
    finally { pendingPlacement = null; clearPlacingMsg(); }
  });
  window.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && pendingPlacement){ pendingPlacement=null; clearPlacingMsg(); } });

  /* Render map from activeSetupData */
  function renderMap(){
    markPins.clearLayers(); markLines.clearLayers(); markDots.clearLayers();
    blindPins.clearLayers(); trainerLay.clearLayers(); raysLayer.clearLayers(); distLabels.clearLayers();

    const geo = activeSetupData.geo || {};
    const marksPlaced = geo.marks || {};
    const blindsPlaced = geo.blinds || {};

    // Trainer
    if (geo.trainer){
      const t = L.marker(geo.trainer, { draggable:true, autoPan:false, icon: iconPill('TR','var(--trainer)') })
        .addTo(trainerLay)
        .bindPopup('<div><strong>Trainer</strong><div class="row" style="margin-top:6px;"><button class="btn warn" id="delTrainer">Redock</button></div></div>')
        .on('dragend', async e => {
          const ll = e.target.getLatLng();
          await setDoc(setupDoc(), { geo: { trainer: { lat:ll.lat, lng:ll.lng } } }, { merge:true });
		  await writeAllDistancesFromTrainer(L.latLng(ll.lat, ll.lng));
        });

      t.on('popupopen', ev=>{
        ev.popup.getElement().querySelector('#delTrainer')?.addEventListener('click', async ()=>{
          try { await updateDoc(setupDoc(), { 'geo.trainer': deleteField() }); } catch(err){ alert('Could not redock trainer'); }
        }, { once:true });
      });
    }

    const cols = Array.isArray(activeSetupData.columns?.cols) ? activeSetupData.columns.cols : [];
    const groupOf = (id)=>{ for (let i=0;i<cols.length;i++){ if ((cols[i].items||[]).includes(id)) return i; } return 0; };

   // Marks
activeSetupData.items.forEach((it, idx) => {
  const geoM = marksPlaced[it.id]; if (!geoM) return;
  const gi = groupOf(it.id);
  const color = GROUP_BLUES[gi % GROUP_BLUES.length];
  const A = L.latLng(geoM.lat, geoM.lng);
  let H = geoM.handle ? L.latLng(geoM.handle.lat, geoM.handle.lng) : destPoint(A, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);

  // label with qualifier suffix
  const label = `M${idx+1}${qualSuffix(it)}`;

  const base = L.marker(A, {
    draggable:true,
    autoPan:false,
    riseOnHover:true,
    zIndexOffset:500,
    icon: iconPill(label, color)
  }).addTo(markPins);
  sizeMarkerPill(base);

  // keep the marker icon interactive (fix for some Leaflet builds)
  base.on('add', () => { if (base._icon) base._icon.style.pointerEvents = 'auto'; });

  let dragBrg = 0, dragDist = MIN_ARROW_VISIBLE;
  base.on('dragstart', () => {
    dragBrg = bearing(A, H);
    dragDist = Math.max(distanceMeters(A, H), MIN_ARROW_VISIBLE);
  });
  base.on('drag', e => {
    const newA = e.target.getLatLng();
    A.lat=newA.lat; A.lng=newA.lng;
    H = destPoint(newA, dragBrg, dragDist);
    dot.setLatLng(H);
    redraw();
  });
base.on('dragend', async e => {
  const ll = e.target.getLatLng();
  await setDoc(setupDoc(), {
    geo: { marks: { [it.id]: { lat: ll.lat, lng: ll.lng, handle: { lat:H.lat, lng:H.lng } } } }
  }, { merge:true });

  await writeMarkDistance(it.id, L.latLng(ll.lat, ll.lng));   // <— add this
});


  const dot = L.marker(H, {
    draggable:true,
    autoPan:false,
    icon: handleIcon(color),
    zIndexOffset:1000
  }).addTo(markDots);

  dot.on('drag', e => { H = e.target.getLatLng(); redraw(); });
  dot.on('dragend', async e => {
    H = e.target.getLatLng();
    await setDoc(setupDoc(), {
      geo: { marks: { [it.id]: { lat: A.lat, lng: A.lng, handle: { lat:H.lat, lng:H.lng } } } }
    }, { merge:true });
  });

  function redraw(){
    markLines.clearLayers();
    const mp = activeSetupData.geo?.marks || {};
    activeSetupData.items.forEach(it2 => {
      if (it2.id === it.id) return;
      const g = mp[it2.id]; if (!g) return;
      const color2 = GROUP_BLUES[groupOf(it2.id) % GROUP_BLUES.length];
      const A2 = L.latLng(g.lat, g.lng);
      const H2 = g.handle ? L.latLng(g.handle.lat, g.handle.lng) : destPoint(A2, DEFAULT_ARROW_BRG, DEFAULT_ARROW_LEN);
      drawArrow(A2, H2, color2);
    });
    drawArrow(A, H, color);
    renderRays();
  }

  drawArrow(A, H, color);

  base.bindPopup(
    `<div>
       <strong>Mark ${label}</strong>
       <div class="row" style="margin-top:6px;">
         <button class="btn warn" id="redock">Redock</button>
       </div>
     </div>`
  );

  base.on('popupopen', ev=>{
    ev.popup.getElement().querySelector('#redock')?.addEventListener('click', async ()=>{
      try {
        await updateDoc(setupDoc(), { [`geo.marks.${it.id}`]: deleteField() });
      } catch(err){
        alert('Could not redock this mark');
      }
    }, { once:true });
  });
});


    // Blinds
    (activeSetupData.blinds||[]).forEach((b, i)=>{
      const g = blindsPlaced[b.id]; if (!g) return;
      const B = L.latLng(g.lat, g.lng);
      const pin = L.marker(B, { draggable:true, autoPan:false, icon: iconPill(`B${i+1}`, 'var(--blind)') }).addTo(blindPins);
      pin.on('dragend', async e=>{
        const ll = e.target.getLatLng();
        await setDoc(setupDoc(), { geo: { blinds: { [b.id]: { lat: ll.lat, lng: ll.lng } } } }, { merge:true });
		await writeBlindDistance(b.id, L.latLng(ll.lat, ll.lng)); 
      });
      pin.bindPopup(`<div><strong>Blind B${i+1}</strong><div class="row" style="margin-top:6px;"><button class="btn warn" id="redockB">Redock</button></div></div>`);
      pin.on('popupopen', ev=>{
        ev.popup.getElement().querySelector('#redockB')?.addEventListener('click', async ()=>{
          try { await updateDoc(setupDoc(), { [`geo.blinds.${b.id}`]: deleteField() }); }
          catch(err){ alert('Could not redock this blind'); }
        }, { once:true });
      });
    });

    renderRays();
  }

  function renderRays(){
    raysLayer.clearLayers(); distLabels.clearLayers();
    if (!$('#raysChk').checked) return;
    const t = activeSetupData.geo?.trainer; if (!t) return;
    const T = L.latLng(t.lat, t.lng);

    function ray(toLL, colorCSS){
      L.polyline([T,toLL], { color:'var(--ray)', weight:2, opacity:.85, dashArray:'6,6', interactive:false }).addTo(raysLayer);
      const mid = L.latLng((T.lat+toLL.lat)/2, (T.lng+toLL.lng)/2);
      const yardsTxt = fmtYards(distanceMeters(T, toLL));
      L.marker(mid, {
  pane: 'distPane',
  icon: L.divIcon({
    className: 'mk',
    html: `<div class="dist-label" style="border-color:${colorCSS}">${yardsTxt}</div>`
  }),
  interactive: false,
  zIndexOffset: 10000 // (optional) belt-and-suspenders
}).addTo(distLabels);

    }

    const marksPlaced = activeSetupData.geo?.marks || {};
    const blindsPlaced = activeSetupData.geo?.blinds || {};
    const cols = activeSetupData.columns?.cols || [];
    const groupOf = (id)=>{ for(let i=0;i<cols.length;i++){ if ((cols[i].items||[]).includes(id)) return i; } return 0; };

    activeSetupData.items.forEach(it=>{
      const g = marksPlaced[it.id]; if (!g) return;
      const color = GROUP_BLUES[groupOf(it.id) % GROUP_BLUES.length];
      ray(L.latLng(g.lat, g.lng), color);
    });
    (activeSetupData.blinds||[]).forEach(b=>{
      const g = blindsPlaced[b.id]; if (!g) return;
      ray(L.latLng(g.lat, g.lng), 'var(--blind)');
    });
  }

  /* Listeners: setups + docs */
  async function attachSetupsListener(){
    if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups=null; }
    const qy = query(setupsColl(), orderBy('order'));
    unsubSetups = onSnapshot(qy, snap=>{
      const arr=[]; snap.forEach(d=>{ const data=d.data()||{}; arr.push({ id:d.id, name:data.name||'Setup', order: typeof data.order==='number'?data.order:9999 }); });
      setupsMeta = arr;
      if (!activeSetupId && setupsMeta.length) activeSetupId = setupsMeta[0].id;
      renderTabs();
      attachSetupDocListener();
    });
  }

  function attachSetupDocListener(){
    if (!activeSetupId) return;
    if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc=null; }

    unsubSetupDoc = onSnapshot(setupDoc(), snap=>{
      const d = snap.data()||{};
      let colsShape = d.columns || { dock:[], cols:[{items:[]},{items:[]}] };
      if (Array.isArray(colsShape.cols) && colsShape.cols.every(el=>Array.isArray(el))) {
        colsShape = { dock: Array.isArray(colsShape.dock) ? colsShape.dock : [], cols: colsShape.cols.map(a => ({ items: a.slice() })) };
      }

      activeSetupData = {
        items: Array.isArray(d.items) ? d.items.map(x => ({ ...x, id: x.id, dist: typeof x.dist==='number' ? x.dist : 0 })) : [],

        columns: { dock: colsShape.dock||[], cols: colsShape.cols||[] },
        blinds: Array.isArray(d.blinds) ? d.blinds.map(x => ({ id:x.id, dist: typeof x.dist==='number'?x.dist:0 })) : [],
        geo: d.geo || {}
      };
	  
	  if (DEBUG_DIST) {
  console.log('[DIST] snapshot -> activeSetupData',
    {
      items: (activeSetupData.items||[]).map(i => ({ id:i.id, dist:i.dist })),
      blinds: (activeSetupData.blinds||[]).map(b => ({ id:b.id, dist:b.dist })),
      hasTrainer: !!activeSetupData.geo?.trainer
    }
  );
}

      buildDock();
      renderMap();
      renderAllArrows();
	  
	  const docExists = snap.exists();  // add this at the top of the callback

// ... your existing code that sets activeSetupData, buildDock(), renderMap(), etc.

checkForObjectivesAndPrompt(docExists); // ⬅️ call this after activeSetupData is ready


      if (!hasAutoCentered) {
        const firstPlaced =
          Object.values(activeSetupData.geo?.marks || {})[0] ||
          Object.values(activeSetupData.geo?.blinds || {})[0] ||
          activeSetupData.geo?.trainer;
        if (firstPlaced) {
          map.setView([firstPlaced.lat, firstPlaced.lng], Math.min(MAX_COMFORT_ZOOM, START_ZOOM_PLACED));
          hasAutoCentered = true;
        }
      }

      updateHudHeightVar();
    });
  }

  async function setActiveSetup(id){
    activeSetupId = id;
    hasAutoCentered = false;
    renderTabs();
    attachSetupDocListener();
  }

  async function switchDay(key){
    currentDateKey = key;
    if (unsubSetups) { try{unsubSetups();}catch{} unsubSetups=null; }
    if (unsubSetupDoc) { try{unsubSetupDoc();}catch{} unsubSetupDoc=null; }
    setupsMeta=[]; activeSetupId=null; activeSetupData={ items:[], columns:{dock:[], cols:[]}, blinds:[], geo:{} };
    renderTabs(); buildDock(); renderMap();
    hasAutoCentered = false;
    if (trainerId) attachSetupsListener();
	if (trainerId) checkForSetupAndPrompt();
  }

  /* Fit + Locate */
$('#fitBtn').addEventListener('click', ()=>{
  const g = activeSetupData.geo || {};
  const raw = [];

  const add = (p) => {
    if (p && typeof p.lat !== 'undefined' && typeof p.lng !== 'undefined') {
      raw.push({ lat: +p.lat, lng: +p.lng });
    }
  };

  add(g.trainer);
  Object.values(g.marks  || {}).forEach(m => add({ lat: m.lat, lng: m.lng })); // ignore handles for fit
  Object.values(g.blinds || {}).forEach(add);

  // Keep only sane, clustered points
  const pts = filterFitPoints(raw);
  if (!pts.length) return;

  if (pts.length === 1) {
    map.flyTo(pts[0], Math.min(MAX_COMFORT_ZOOM, START_ZOOM_PLACED), { duration: 0.45 });
    return;
  }

  const bounds  = L.latLngBounds(pts);
  const padding = L.point(FIT_PADDING[0], FIT_PADDING[1]);

  // base zoom that fits with padding
  const zFit   = map.getBoundsZoom(bounds, true, padding);
  const center = bounds.getCenter();

  // try one level tighter (but cap at max)
  const zTry = Math.min(MAX_COMFORT_ZOOM, zFit + 1);

  // check that all points still fit at zTry with the same padding
  const size  = map.getSize();
  const halfW = size.x / 2 - padding.x;
  const halfH = size.y / 2 - padding.y;
  const cPx   = map.project(center, zTry);

  const fitsAtZTry = pts.every(p => {
    const px = map.project(p, zTry);
    return Math.abs(px.x - cPx.x) <= halfW && Math.abs(px.y - cPx.y) <= halfH;
  });

  const zTarget = fitsAtZTry ? zTry : zFit;
  map.flyTo(center, zTarget, { duration: 0.45 });
});




function isValidLL(p){
  return p && typeof p.lat === 'number' && typeof p.lng === 'number' &&
         isFinite(p.lat) && isFinite(p.lng) &&
         p.lat >= -90 && p.lat <= 90 && p.lng >= -180 && p.lng <= 180 &&
         !(Math.abs(p.lat) < 1e-6 && Math.abs(p.lng) < 1e-6); // reject (0,0)
}

const median = arr => {
  const s = [...arr].sort((a,b)=>a-b);
  const m = Math.floor(s.length/2);
  return s.length % 2 ? s[m] : (s[m-1] + s[m]) / 2;
};

/** Keep only the main cluster (drops accidental outliers far away) */
function filterFitPoints(pts){
  const clean = pts.filter(isValidLL);
  if (clean.length < 3) return clean;

  const latMed = median(clean.map(p=>p.lat));
  const lngMed = median(clean.map(p=>p.lng));
  const C = L.latLng(latMed, lngMed);

  const LIMIT = FIT_MAX_CLUSTER_KM * 1000;
  return clean.filter(p => map.distance(C, p) <= LIMIT);
}



  $('#locBtn').addEventListener('click', ()=>{
    if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
    navigator.geolocation.getCurrentPosition(
      pos => {
        const { latitude, longitude } = pos.coords;
        map.flyTo([latitude, longitude], MAX_COMFORT_ZOOM, { duration: 3 });


      },
      err => alert('Could not get your location'),
      { enableHighAccuracy:true, timeout:10000, maximumAge:30000 }
    );
  });

  /* -------- Place at me -------- */
function getGPS(){
  return new Promise((resolve, reject)=>{
    if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
    navigator.geolocation.getCurrentPosition(
      p => resolve({ lat:p.coords.latitude, lng:p.coords.longitude }),
      err => reject(err),
      { enableHighAccuracy:true, timeout:12000, maximumAge:5000 }
    );
  });
}

/* tweak these to taste (meters); south is positive here via bearing 180° */
const PLACE_AT_ME_OFFSET_SOUTH_M = 2;   // e.g. nudge 2 m south
const PLACE_AT_ME_OFFSET_EAST_M  = 0;   // optional: positive = east, negative = west

function applyPlaceOffset(ll){
  // move south first (bearing 180), then east/west (bearing 90)
  let out = ll;
  if (PLACE_AT_ME_OFFSET_SOUTH_M) out = destPoint(out, 180, PLACE_AT_ME_OFFSET_SOUTH_M);
  if (PLACE_AT_ME_OFFSET_EAST_M)  out = destPoint(out,  90, PLACE_AT_ME_OFFSET_EAST_M);
  return out;
}


// FAB open/close behavior
const fab     = document.getElementById('fab');
const fabMenu = document.getElementById('fabMenu');

function closeFab(){ fabMenu.classList.remove('open'); fabMenu.setAttribute('aria-hidden','true'); }

fab.addEventListener('click', (e)=>{
  e.stopPropagation();
  const open = !fabMenu.classList.contains('open');
  if (open){
    fabMenu.classList.add('open');
    fabMenu.setAttribute('aria-hidden','false');
    updateFabLinks(); // ensure links include current trainer
  updateFabDockLabel();

  } else {
    closeFab();
  }
});

// click-away + Esc to close
document.addEventListener('click', (e)=>{
  if (!fabMenu.contains(e.target) && e.target !== fab) closeFab();
});
window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeFab(); });



 $('#placeBtn').addEventListener('click', ()=>{
  const list = $('#placeList'); 
  list.innerHTML = '';

  // Gather unplaced
  const marksPlaced  = activeSetupData.geo?.marks  || {};
  const blindsPlaced = activeSetupData.geo?.blinds || {};
  const unplacedMarks  = (activeSetupData.items  || []).map((m,idx)=>({m,idx})).filter(({m})=>!marksPlaced[m.id]);
  const unplacedBlinds = (activeSetupData.blinds || []).map((b,idx)=>({b,idx})).filter(({b})=>!blindsPlaced[b.id]);
  const trainerUnplaced = !activeSetupData.geo?.trainer;

  // Helper to make a button
  const makeBtn = (label, classes='btn') => {
    const b = document.createElement('button');
    b.className = classes;
    b.textContent = label;
    return b;
  };

  // Helper to place an existing item at GPS
  const wirePlaceExisting = (payload, btn, originalLabel) => {
    btn.addEventListener('click', async ()=>{
      try{
        btn.disabled = true; btn.textContent = 'Placing…';
        const p = await getGPS();
        const P = applyPlaceOffset(p);
        await placeItem(payload, L.latLng(P.lat, P.lng));
        placeOverlay.classList.remove('open');
        map.flyTo([p.lat, p.lng], Math.min(MAX_COMFORT_ZOOM, 18), { duration:0.6 });
      }catch(e){
        alert('Unable to get your location.');
        btn.disabled = false; btn.textContent = originalLabel;
      }
    }, { once:true });
  };

  // ---------- ROW 1: Trainer (if available), + Mark, + Blind ----------
  const row1 = document.createElement('div');
  row1.className = 'overlay-actions';

  if (trainerUnplaced){
    const tBtn = makeBtn('Trainer (TR)', 'btn');
    wirePlaceExisting({ type:'trainer', id:'TR', label:'Trainer (TR)' }, tBtn, 'Trainer (TR)');
    row1.appendChild(tBtn);
  }

  // + Mark (blue)
  const addMarkBtn = makeBtn('+ Mark', 'btn primary');
  addMarkBtn.addEventListener('click', async ()=>{
    try{
      await ensureActiveSetupExists();
      openGroupPicker({
        onPick: async ({ index }) => {
          const newId = await appendSetupItem({ kind:'mark', groupIndex:index });
          try {
            await placeNewlyAdded('mark', newId);
            placeOverlay.classList.remove('open');
          }catch(e){
            alert('Added Mark to setup, but could not get your location to place it.');
          }
        }
      });
    }catch(e){ alert('Could not add mark'); }
  });
  row1.appendChild(addMarkBtn);

  // + Blind (blue)
  const addBlindBtn = makeBtn('+ Blind', 'btn primary');
  addBlindBtn.addEventListener('click', async ()=>{
    try{
      await ensureActiveSetupExists();
      openGroupPicker({
        onPick: async ({ index }) => {
          const newId = await appendSetupItem({ kind:'blind', groupIndex:index });
          try {
            await placeNewlyAdded('blind', newId);
            placeOverlay.classList.remove('open');
          }catch(e){
            alert('Added Blind to setup, but could not get your location to place it.');
          }
        }
      });
    }catch(e){ alert('Could not add blind'); }
  });
  row1.appendChild(addBlindBtn);

  list.appendChild(row1);

  // ---------- ROW 2: all unplaced Marks ----------
  if (unplacedMarks.length){
    const rowM = document.createElement('div');
    rowM.className = 'overlay-actions';
    unplacedMarks.forEach(({m,idx})=>{
      const label = `Mark M${idx+1}${qualSuffix(m)}`;
      const btn = makeBtn(label, 'btn');
      wirePlaceExisting({ type:'mark', id:m.id, label }, btn, label);
      rowM.appendChild(btn);
    });
    list.appendChild(rowM);
  }

  // ---------- ROW 3: all unplaced Blinds ----------
  if (unplacedBlinds.length){
    const rowB = document.createElement('div');
    rowB.className = 'overlay-actions';
    unplacedBlinds.forEach(({b,idx})=>{
      const label = `Blind B${idx+1}`;
      const btn = makeBtn(label, 'btn');
      wirePlaceExisting({ type:'blind', id:b.id, label }, btn, label);
      rowB.appendChild(btn);
    });
    list.appendChild(rowB);
  }

  placeOverlay.classList.add('open');
});


  $('#raysChk').addEventListener('change', renderRays);

// Long-press to set trainer (desktop) — ignore if press starts on a marker or handle
let pressTimer = null;
map.on('mousedown', (e) => {
  const t = e.originalEvent?.target;
  if (t && (t.closest?.('.leaflet-marker-icon') || t.closest?.('.handle-hit'))) return; // don't hijack marker drags
pressTimer = setTimeout(async () => {
  await setDoc(setupDoc(), { geo: { trainer: { lat: e.latlng.lat, lng: e.latlng.lng } } }, { merge: true });
  await writeAllDistancesFromTrainer(e.latlng);                            // <— add this
}, 20000);

});
map.on('mouseup',  () => clearTimeout(pressTimer));
map.on('mouseout', () => clearTimeout(pressTimer));

// Change trainer — reuse the existing "change user" logic
document.getElementById('fabChangeTrainer')?.addEventListener('click', (e) => {
  e.preventDefault();
  closeFab();
  document.getElementById('changeUserLink')?.click();   // triggers your existing handler
});

// Load setup — open the date picker like clicking the calendar
document.getElementById('fabLoadSetup')?.addEventListener('click', (e) => {
  e.preventDefault();
  closeFab();
  const dp = document.getElementById('dayPicker');
  if (!dp) return;
  if (typeof dp.showPicker === 'function') {
    dp.showPicker();           // modern browsers
  } else {
    dp.focus();                // fallback
    dp.click();                // some browsers open the picker on click
  }
});
	


  /* HUD outside map on mobile */
  const hudEl = document.getElementById('hud');
  function updateHudHeightVar(){
    const mobile = window.matchMedia('(max-width: 820px)').matches;
    if (!mobile) { document.body.classList.remove('hud-outside'); document.documentElement.style.setProperty('--hud-h','0px'); return; }
    document.body.classList.add('hud-outside');
    requestAnimationFrame(()=> {
      document.documentElement.style.setProperty('--hud-h', hudEl.offsetHeight + 'px');
    });
  }
  window.addEventListener('resize', updateHudHeightVar);
  updateHudHeightVar();
  if ('ResizeObserver' in window) new ResizeObserver(updateHudHeightVar).observe(hudEl);

document.getElementById('fitBtn').style.display = 'none';


  /* Boot */
  async function boot(){
    if (!trainerId) return showTrainerPrompt();
    ctxEl.textContent = `Trainer: ${trainerId}`;
updateFabDockLabel();   // <-- add here
await switchDay(dayPicker.value);

  }
  if (trainerId) boot(); else showTrainerPrompt();
  
  
</script>
</body>
</html>


