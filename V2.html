<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Deck Table — V2 (mobile portrait first)</title>

<link rel="stylesheet" href="mana-master/css/mana.min.css">



<style>
:root{
  --bg:#0e1015; --fg:#e7e9ee; --muted:#9aa3b2; --accent:#6aa9ff;
  --ok:#42d392; --warn:#ffb84d; --danger:#ff6b6b;
  --topbar-h:64px;
  --life-h:40px;
  --card-w:223px; --card-h:310px;
  --zone-w:223px; --zone-h:310px;

  /* raise overlays so the settings panel beats the hand & toolbar */
  --z-tooltip:20; 
  --z-hand:35; 
  --z-toolbar:40; 
  --z-zoom:45; 
  --z-actions:36; 
  --z-overlays:10000;

  --hand-scale: .88;
  --flip-rot: 0deg;
  --tap-rot: 0deg;
  --world-zoom: 1;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{ margin:0; background:var(--bg); color:var(--fg); font:14px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; -webkit-tap-highlight-color:transparent; overflow:hidden; }
button{ font:inherit; color:inherit; cursor:pointer; background:none; border:0; }
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:8px; }

/* Top bar */
.topbar{ position:sticky; top:0; z-index:10; display:grid; grid-template-columns:auto 1fr; align-items:center; gap:10px; height:var(--topbar-h); padding:10px 12px; border-bottom:1px solid #1f2738; background:linear-gradient(180deg,#10141b,#0c1117); }
.cog{ width:42px; height:42px; border-radius:12px; border:1px solid #24324a; background:#111826; display:grid; place-items:center; font-weight:900; }
.life-strip{ display:flex; gap:8px; align-items:center; }
.life-tile{
  background:#0f141c; border:1px solid #2b3344; border-radius:12px;
  min-width:90px; padding:6px 10px;
  display:flex; align-items:center;
  justify-content:flex-start;   /* was space-between */
  gap:10px;                     /* adds clear space between “P1” and the life */
}

.life-main{ color:#ff6b6b; font-weight:800; }
.life-cmd{ color:#e7e9ee; background:#000; border-radius:8px; padding:0 6px; margin-left:8px; font-weight:700; }

/* Drawer */
.drawer-wrap{ overflow:hidden; transition:max-height .25s ease; border-bottom:1px solid #1f2738; }
.drawer-wrap.collapsed{ max-height:0; border-bottom-color:transparent; }
.drawer-wrap.expanded{ max-height:420px; }
.drawer{ padding:12px; background:#0b0f15; display:grid; gap:10px; }
.row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.pill{ background:#1b2a47; color:#d8e7ff; font-weight:700; padding:9px 12px; border-radius:12px; border:1px solid #24324a; }
select.pill{ padding:8px 10px; }
textarea.deck-in{ width:100%; height:140px; resize:vertical; padding:10px; border-radius:12px; border:1px solid #24304a; background:#0a0f16; color:var(--fg); font:13px/1.45 ui-monospace,Menlo,Consolas,monospace; }

/* Table */
.table{ position:relative; height:calc(100% - var(--topbar-h)); background:linear-gradient(180deg,#0d3a1e,#0a2716 40%, #092113); }
.worldWrap{ position:absolute; inset:0; overflow:hidden; cursor:grab; touch-action:none; }
.worldWrap.panning{ cursor:grabbing; }
.worldScale{ position:relative; transform-origin:0 0; will-change:transform; }
.world{ position:relative; min-width:100%; min-height:100%; padding:24px; }

/* Zones */
.zone{ position:absolute; width:var(--zone-w); height:var(--zone-h); border:2px dashed rgba(255,255,255,.2); border-radius:12px; background:rgba(0,0,0,.12); display:grid; place-items:center; user-select:none; }
.zone .label{ color:#d0d6e4; font-weight:700; pointer-events:none; }
#deckZone{ background:#000 url('https://i.imgur.com/LdOBU1I.jpeg') center/cover no-repeat; border:1px solid #2b3344; }
#deckZone .label{ display:none; }
#deckZone{ left:24px; top:24px; }
#cmdZone{ left:24px; top:calc(24px + var(--zone-h) + 12px); }
#graveyard{ left:calc(24px + var(--zone-w) + 16px); top:24px; }
#exileZone{ left:calc(24px + var(--zone-w) + 16px); top:calc(24px + var(--zone-h) + 12px); }

/* Card shells */
.card{ position:absolute; width:var(--card-w); height:var(--card-h); border-radius:14px; box-shadow:0 10px 26px rgba(0,0,0,.5); touch-action:none; perspective:1000px; transition: width .18s ease, height .18s ease; overflow:visible; }
.card.tapped{ width:var(--card-h); height:var(--card-w); }

/* Inner 3D flipper */
.cardInner{
  position:absolute; left:50%; top:50%; width:100%; height:100%; border-radius:14px;
  transform-style: preserve-3d; /* CRITICAL: render front/back as real faces */
  transform-origin:center center;
  transform: translate(-50%,-50%) rotateZ(var(--tap-rot)) rotateY(var(--flip-rot));
  transition: transform .35s ease, width .18s ease, height .18s ease;
}
.cardTooltip{ z-index: calc(var(--z-actions) + 1); }

.card.tapped .cardInner{ width:var(--card-w); height:var(--card-h); }

.card.selected{ outline:2px solid var(--accent); outline-offset:2px; }

/* Faces */
.face{
  position:absolute; inset:0; border-radius:14px;
  backface-visibility:hidden;  /* hide reverse of each face */
  background:#1a1f2a center/cover no-repeat;
}
.face.back{ transform: rotateY(180deg); } /* back is pre-rotated to face forward when parent flips */

.card .pt{ position:absolute; right:6px; bottom:6px; background:rgba(0,0,0,.7); color:#e7f0ff; border-radius:8px; padding:2px 6px; font-weight:800; z-index:2; }

/* Quick actions */
.cardActions{ position:absolute; z-index:var(--z-actions); display:flex; flex-direction:column; gap:8px; }
.cardActions .qa{ width:42px; height:42px; border-radius:50%; background:#0f1725; color:#cfe1ff; border:1px solid #2b3f63; display:grid; place-items:center; font-weight:900; box-shadow:0 8px 20px rgba(0,0,0,.35); }

/* Tooltip */
.cardTooltip{
  position:absolute; z-index:var(--z-actions); display:block; min-width:220px; max-width:min(420px,92vw);
  background:#0b1220; color:#e7efff; border:1px solid #263a5f; border-radius:12px; box-shadow:0 14px 36px rgba(0,0,0,.55);
  padding:10px 12px; font-size:13px; line-height:1.35; white-space:normal; overflow-wrap:anywhere; word-break:break-word;
  transform-origin: bottom center; transform: translateX(-50%) scale(calc(1 / var(--world-zoom)));
}
.cardTooltip h3{ margin:0 0 6px 0; font-size:15px; line-height:1.25; }
.cardTooltip .typeLine{ color:#9fb4d9; margin-bottom:6px; }
.cardTooltip .oracle{ white-space:pre-wrap; }

/* Hand */
.hand{ position:fixed; left:0; right:0; bottom:56px; z-index:var(--z-hand); display:grid; place-items:center; height:calc(var(--card-h) * .9); pointer-events:none; }
.handTrack{ position:relative; width:100%; height:100%; }
.handCard{ --dx:0px; --rot:0deg; position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--dx)), -50%) scale(var(--hand-scale)) rotate(var(--rot)); transition: transform .18s ease, opacity .18s ease; pointer-events:auto; }
.handCard.far { opacity:.35; transform: translate(calc(-50% + var(--dx)), -50%) scale(calc(var(--hand-scale) * .78)) rotate(var(--rot)); }
.handCard.mid { opacity:.7;  transform: translate(calc(-50% + var(--dx)), -50%) scale(calc(var(--hand-scale) * .88)) rotate(var(--rot)); }
.handCard.focus{ opacity:1; transform: translate(calc(-50% + var(--dx)), -50%) scale(1) rotate(0deg); z-index:2; }
.handCard .card{ position:relative; }
.hand.swiping .handCard{ transition:none !important; }

/* Toolbar */
.toolbar{ position:fixed; left:0; right:0; bottom:0; z-index:var(--z-toolbar); display:grid; grid-auto-flow:column; justify-content:center; gap:12px; padding:8px 10px calc(8px + env(safe-area-inset-bottom,0px)); background:linear-gradient(180deg, rgba(12,18,28,0), rgba(12,18,28,.88)); border-top:1px solid rgba(255,255,255,.08); }
.fab{ width:50px; height:50px; border-radius:50%; background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63; display:grid; place-items:center; font-size:20px; box-shadow:0 8px 20px rgba(106,169,255,.18); }

/* Zoom */
.zoomWrap{ position:fixed; left:8px; top:calc(var(--topbar-h) + 8px); z-index:var(--z-zoom); width:32px; height:220px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:12px; display:flex; align-items:center; justify-content:center; overflow:hidden; }
#zoom{ position:relative; transform: rotate(-90deg); transform-origin:center; width:180px; height:32px; -webkit-appearance:none; appearance:none; background:transparent; outline:none; }
#zoom::-webkit-slider-runnable-track{ height:6px; border-radius:4px; background:#23324d; }
#zoom::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:#6aa9ff; border:2px solid #0a1426; transform:translateY(-5px); }

/* Overlays */
.scrim{ position:fixed; inset:0; background:rgba(6,10,16,.6); display:none; z-index:var(--z-overlays); }
.panel{ position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); width:min(720px,94vw); max-height:80vh; overflow:auto; background:rgba(12,18,28,.98); border:1px solid #24324a; border-radius:14px; padding:12px; }
.zoneGrid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:10px; }
.thumb{ width:100%; padding-top:140%; border-radius:10px; background:#1a1f2a center/cover no-repeat; position:relative; overflow:hidden; cursor:pointer; }

/* Mobile tweaks */
@media (max-width: 768px){
  :root{ --card-w:180px; --card-h:250px; --zone-w:180px; --zone-h:250px; --hand-scale:.86; }
  .drawer-wrap.expanded{ max-height:360px; }
}
@media (max-width: 420px){
  :root{ --card-w:160px; --card-h:220px; --zone-w:160px; --zone-h:220px; --hand-scale:.84; }
}

/* Game picker */
.gamePicker{ display:flex; gap:8px; }
.gameBtn{ background:#1b2a47; color:#d8e7ff; font-weight:800; padding:8px 12px; border-radius:999px; border:1px solid #24324a; opacity:.85; }
.gameBtn.active{ background:#314a7d; border-color:#3d5ba0; opacity:1; box-shadow:0 6px 16px rgba(49,74,125,.35) inset; }

/* Mana icon sizing inside tooltip */
.cardTooltip i.ms{
  font-size:18px;
  line-height:1;
  display:inline-block;
  vertical-align:-2px;
  margin:0 2px;
}
.cardTooltip .cost i.ms{ font-size:20px; }
.cardTooltip .ms.ms-cost{ margin:0 1px; } /* tiny spacing tweak */

/* Smooth motion + hide actions while viewing another player */
.viewing-opponent .card {
  transition: left .22s ease, top .22s ease, width .18s ease, height .18s ease;
  cursor: default;
}
.viewing-opponent .cardActions { display:none; }

.fab svg{
  width:22px;
  height:22px;
  display:block; /* centers nicely in the grid container */
}

/* Buttons to the immediate left of the deck (vertically centered) */
.deck-actions{
  position: absolute;
  left: calc(var(--DECK_X) - 64px);
  top:  calc(var(--DECK_TOP) + (var(--ZONE_H) / 2) - 28px);
  display: flex;
  flex-direction: column;
  gap: 14px;
  z-index: var(--z-controls);
}
/* Only the three buttons next to the deck */
.deck-actions .sbtn{
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background:#1a2a45;
  color:#cfe1ff;
  border:1px solid #2b3f63;
  font-weight:900;
  font-size:20px;
  display:inline-flex;align-items:center;justify-content:center;line-height:1;
  box-shadow:0 8px 20px rgba(106,169,255,.18);
}
.deck-actions .sbtn:active{ transform:scale(.98); }


.chatOverlay{
  position:fixed; inset:0; display:none; z-index:60;
  background:rgba(6,10,16,.65);
}
.chatPanel{
  position:absolute; left:50%; top:50%;
  transform:translate(-50%,-50%);
  width:min(980px,94vw); max-height:82vh; overflow:auto;
  background:#0b1220; color:#e7efff; border:1px solid #2b3f63;
  border-radius:14px; padding:12px;
}
.chatHeader{
  display:flex; justify-content:space-between; align-items:center;
  gap:8px; margin-bottom:10px; font-weight:800;
}
.chatClose{ background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63;
  border-radius:10px; padding:6px 10px; }
.btn.sm{
  background:#142136; color:#e9f2ff; border:1px solid #35527d;
  border-radius:10px; padding:6px 10px; font-weight:800;
}

.deck-actions,
.deck-actions .sbtn{
  touch-action: auto;
}

/* ==== Stack preview arrow ============================================== */
.stackArrow{
  position:absolute; z-index:var(--z-tooltip);
  display:none; pointer-events:none;
  padding:6px 10px; border-radius:999px;
  background:rgba(20,33,54,.92); border:1px solid #35527d;
  box-shadow:0 10px 26px rgba(0,0,0,.45);
  transform: translate(-50%,-50%) scale(calc(1 / var(--world-zoom)));
  gap:8px; align-items:center; font-weight:800; color:#e9f2ff;
}
.stackArrow svg{ width:22px; height:22px; display:block; }
.stackArrow.dir-right svg{ transform:rotate(0deg); }
.stackArrow.dir-left  svg{ transform:rotate(180deg); }
.stackArrow.dir-up    svg{ transform:rotate(-90deg); }

/* === Mulligan overlay (top-center prompt) =============================== */
.mulliganOverlay{
  position:fixed; left:50%; top:10px; transform:translateX(-50%);
  z-index: var(--z-overlays);
  display:none; pointer-events:none;
}
.mullPanel{
  pointer-events:auto;
  background:rgba(12,18,28,.98);
  border:1px solid #24324a;
  border-radius:12px;
  padding:10px 12px;
  display:flex; align-items:center; gap:10px;
  box-shadow:0 10px 26px rgba(0,0,0,.45);
  font-weight:800; color:#e9f2ff;
}
.mullPanel .btn{
  background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63;
  border-radius:10px; padding:6px 12px; font-weight:900;
}
.mullPanel .btn:active{ transform:scale(.98); }

/* === Card Settings overlay ============================================= */
#cardSettings.scrim{ display:none; }
.cardSettingsPanel{
  position:absolute; left:50%; top:50%;
  transform:translate(-50%,-50%); width:min(820px,94vw); max-height:80vh; overflow:auto;
  background:rgba(12,18,28,.98); border:1px solid #24324a; border-radius:14px; padding:12px;
}
.cs-header{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px; }
.cs-row{ display:grid; grid-template-columns:140px 1fr; gap:10px; align-items:start; margin-bottom:10px; }
.cs-row .lbl{ color:#9fb4d9; font-weight:800; padding-top:6px; }
.cs-input, .cs-textarea, .cs-chipinput{ width:100%; background:#0a0f16; color:#e7efff; border:1px solid #24324a; border-radius:10px; padding:8px 10px; }
.cs-textarea{ min-height:90px; resize:vertical; }
.cs-chips{ display:flex; gap:6px; flex-wrap:wrap; }
.cs-chip{ background:#1b2a47; border:1px solid #2b3f63; color:#d8e7ff; border-radius:999px; padding:6px 10px; font-weight:800; }
.cs-minirow{ display:flex; gap:8px; align-items:center; margin-bottom:6px; }
.cs-minirow input{ background:#0a0f16; color:#e7efff; border:1px solid #24324a; border-radius:8px; padding:6px 8px; }
.cs-actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
.cs-btn{ background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63; border-radius:10px; padding:8px 12px; font-weight:900; }
.cs-btn.warn{ background:#2a1730; border-color:#5e2a6a; }

/* Counters list */
.countersWrap{ display:flex; flex-direction:column; gap:6px; }
.counterRow{ display:grid; grid-template-columns:1fr 90px 34px; gap:8px; }
.counterRow input{ background:#0a0f16; color:#e7efff; border:1px solid #24324a; border-radius:8px; padding:6px 8px; }
.counterRow .addBtn, .counterRow .delBtn{
  background:#142136; color:#e9f2ff; border:1px solid #35527d; border-radius:10px; width:34px; height:34px; font-weight:900;
}

/* === Under-card anchor badge =========================================== */
.cardBadge{
  position:absolute; z-index:var(--z-tooltip);
  background:rgba(20,33,54,.92); border:1px solid #35527d; color:#e7f2ff;
  border-radius:10px; padding:6px 8px; display:flex; gap:8px; align-items:center;
  transform: translate(-50%, 0) scale(calc(1 / var(--world-zoom)));
  pointer-events:none;
}
.cardBadge .bchip{
  background:#1b2a47; border:1px solid #2b3f63; border-radius:8px; padding:2px 6px; font-weight:800;
}
.cardBadge .notes{ max-width:260px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; opacity:.9; }

.deck-actions{ pointer-events: none; }         /* wrapper ignores hits */
.deck-actions .sbtn{ pointer-events: auto; }   /* buttons still clickable */

/* Deck Top/Bottom/Shuffle/Cancel popup */
#deckChoice{
  position: fixed;               /* align with viewport coords we compute */
  z-index: var(--z-overlays);    /* above cards/tooltips/scrims */
  transform: translate(-50%, -8px);  /* center above the deck, with a tiny gap */
}


</style>
</head>
<body>

<!-- Top bar -->
<div class="topbar">
  <button class="cog" id="cogBtn">⚙️</button>
  <div class="life-strip">
    <div class="life-tile"><span>P1</span><span><span class="life-main">40</span> <span class="life-cmd">20</span></span></div>
    <div class="life-tile"><span>P2</span><span><span class="life-main">40</span> <span class="life-cmd">20</span></span></div>
    <div class="life-tile"><span>P3</span><span><span class="life-main">40</span> <span class="life-cmd">20</span></span></div>
  </div>
</div>

<!-- Drawer -->
<div id="drawerWrap" class="drawer-wrap expanded">
  <div class="drawer">
    <div class="row">
      <label class="pill">Players
        <select class="pill" id="playerCount">
          <option>1</option><option selected>2</option><option>3</option>
        </select>
      </label>
      <label class="pill">I am
        <select class="pill" id="mySeat">
          <option>1</option><option selected>2</option><option>3</option>
        </select>
      </label>
      <button class="pill" id="lifeEditBtn">Edit Life</button>
    </div>
    <textarea class="deck-in" id="deckIn" placeholder="Paste your deck list..."></textarea>
    <div class="row">
      <button class="pill" id="loadBtn">Load Deck</button>
      <button class="pill" id="resetBtn" title="Resets THIS player only">Reset (me)</button>
    </div>
    <div class="row">
      <div class="gamePicker" id="gamePicker">
        <button class="gameBtn" data-game="game1">Game 1</button>
        <button class="gameBtn" data-game="game2">Game 2</button>
        <button class="gameBtn" data-game="game3">Game 3</button>
      </div>
    </div>
  </div>
</div>

<!-- Table -->
<div class="table" id="table">
  <div class="worldWrap" id="worldWrap">
    <div class="worldScale" id="worldScale" style="transform:translate(0px,0px) scale(1);">
      <div class="world" id="world">
        <div class="zone" id="deckZone"><div class="label">Deck</div></div>
		<!-- Left-of-deck actions (🔍 ＋ …) -->
<div class="deck-actions" id="deckActions">
  <button class="sbtn" id="deckSearchBtn" title="Search Deck">🔍</button>
  <button class="sbtn" id="deckAddBtn"    title="Add card / token">＋</button>
  <button class="sbtn" id="deckMoreBtn"   title="Deck Tools">…</button>
</div>

        <div class="zone" id="cmdZone"><div class="label">Commander</div></div>
        <div class="zone" id="graveyard"><div class="label">Graveyard</div></div>
        <div class="zone" id="exileZone"><div class="label">Exile</div></div>
      </div>
    </div>
  </div>
</div>

<!-- Hand -->
<div class="hand" id="hand"><div class="handTrack" id="handTrack"></div></div>

<!-- Toolbar -->
<div class="toolbar">
  <button class="fab" id="battleBtn" title="Battle">⚔️</button>
  <button class="fab" id="endTurnBtn" title="End Turn">⏭</button>
  <button class="fab" id="viewEyeBtn" title="View Player">👁</button>
  <button class="fab" id="turnInfoBtn" title="Turn Info" aria-label="Turn Info">
  <svg viewBox="0 0 24 24" fill="none"
       stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
       aria-hidden="true">
    <circle cx="12" cy="12" r="10"></circle>
    <path d="M12 16v-4"></path>
    <path d="M12 8h.01"></path>
  </svg>
</button>

</div>

<!-- Zoom -->
<div class="zoomWrap"><input type="range" id="zoom" min="40" max="160" value="100"/></div>

<!-- Overlays -->
<div class="scrim" id="zoneOverlay">
  <div class="panel">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <strong id="overlayTitle">Zone</strong>
      <button class="pill" id="overlayClose">Close</button>
    </div>
    <div class="zoneGrid" id="overlayGrid"></div>
  </div>
</div>

<div class="deckChoice" id="deckChoice" style="display:none; left:0; top:0;">
  <button class="pill" data-choice="top">Top</button>
  <button class="pill" data-choice="bottom">Bottom</button>
  <button class="pill" data-choice="shuffle">Shuffle</button>
  <button class="pill" data-choice="cancel">Cancel</button>
</div>


<!-- Card Settings (⚙️) -->
<div class="scrim" id="cardSettings">
  <div class="cardSettingsPanel">
    <div class="cs-header">
      <strong id="csTitle">Card Settings</strong>
      <button class="cs-btn" id="csClose">Close</button>
    </div>

    <div class="cs-row">
      <div class="lbl">Additional Types</div>
      <div>
        <div class="cs-chips" id="csTypesChips"></div>
        <input class="cs-input" id="csTypesInput" placeholder="Type a type and press Enter (e.g., Wizard)" />
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Additional Effects</div>
      <div>
        <div class="cs-chips" id="csEffectsChips"></div>
        <input class="cs-input" id="csEffectsInput" placeholder="Type an effect and press Enter (e.g., Vigilance)" />
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Chosen Type</div>
      <input class="cs-input" id="csChosenType" placeholder="e.g., Angel, Wizard, Beast..." />
    </div>

    <div class="cs-row">
      <div class="lbl">P/T Mod</div>
      <div class="cs-minirow">
        <label>Power ± <input type="number" id="csPowMod" style="width:80px" value="0"></label>
        <label>Toughness ± <input type="number" id="csTghMod" style="width:80px" value="0"></label>
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Counters</div>
      <div>
        <div class="countersWrap" id="csCounters"></div>
        <div class="counterRow">
          <input id="csNewCounterName" placeholder="counter name (e.g., +1/+1)" />
          <input id="csNewCounterQty" type="number" placeholder="qty" value="1" />
          <button class="addBtn" id="csAddCounter">＋</button>
        </div>
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Notes</div>
      <textarea class="cs-textarea" id="csNotes" placeholder="Anything else..."></textarea>
    </div>

    <div class="cs-actions">
      <button class="cs-btn warn" id="csClear">Clear</button>
      <button class="cs-btn" id="csSave">Save</button>
    </div>
  </div>
</div>


<!-- Mulligan overlay (friendly: always draw 7 again) -->
<div class="mulliganOverlay" id="mulliganOverlay">
  <div class="mullPanel">
    <span>Mulligan?</span>
    <button class="btn" id="mullYesBtn">Yes</button>
    <button class="btn" id="mullNoBtn">No</button>
  </div>
</div>

<!-- put this early in the page -->
<!-- put this BEFORE any scripts that use StorageAPI -->
<script type="module" src="./modules/env.supabase.js"></script>


<script type="module">
import { startCombatPoller, wireBattleFab } from './modules/combat.ui.js';
import {
  initStorage,
  savePlayerStateDebounced,
  loadPlayerState,
  loadMeta,
  saveMeta,
  startPlayerPollers,
  startMetaPoller,
  deletePlayerState,
  wipePlayerState,
  // add these:
  ensureCombatRow,
  readCombat, writeCombat, resetCombat,
  saveAttacks, saveBlocks, writeCombatInitiated,
  saveTurnState, readTurnState, startTurnWatcher, snapshotAllSeatsToTable
} from './modules/env.supabase.js';
// before anything that used to import firebase
window.firebase = { initializeApp(){}, getApp(){ return {}; } };

const CARD_BACK_URL = 'https://i.imgur.com/LdOBU1I.jpeg';

const state = {
  gameId: null,
  mySeat: 2,
  playerCount: 2,
  turn: null,
  zoom: 1, panX: 0, panY: 0,
  hand: [], table: [], gy: [], exile: [], deck: [],
    _mulliganPending: false,
  _mulliganAutoDrawing: false,
  _hasShownOpeningMull: false,

  scryCache: new Map(),
  selectedCardId: null
};

// expose shared app state so other <script type="module"> blocks can access it
window.AppState = state;

(async function bootLastGameIfAny(){
    try{
      const last = localStorage.getItem('lastGameId');
      if (!last) {
        console.log('[boot] no lastGameId');
        return;
      }

      console.log('[boot] restoring lastGameId:', last);
      await waitForStorageReady();
      await loadGameIntoUI(last);
      await ensureTurnSeatMeta();
      await hydrateTurnSeatNow();
      await ensureCombatWiring();  // <-- attaches the detailed battle click logger
    } catch (e){
      console.warn('[boot] restore failed', e);
    }
  })();

/* ---------- VIEWER MODE STATE ---------- */
state.viewSeat = state.mySeat;         // which seat we’re currently viewing
state.viewReadOnly = false;            // true when viewing an opponent
state.viewPoller = null;               // interval handle
state._oppSnapshot = null;             // last remote doc for diffing (opponent)

let currentTurnSeat = 0; // single source of truth

const viewEyeBtn = document.getElementById('viewEyeBtn');
const zoomWrapEl = document.querySelector('.zoomWrap');
const cogBtn = document.getElementById('cogBtn');
const drawerWrap = document.getElementById('drawerWrap');
const worldScaleEl = document.getElementById('worldScale');
const worldWrap = document.getElementById('worldWrap');
const worldEl = document.getElementById('world');
const handTrack = document.getElementById('handTrack');
const deckZone = document.getElementById('deckZone');
const cmdZone = document.getElementById('cmdZone');
const gyZone = document.getElementById('graveyard');
const exileZone = document.getElementById('exileZone');
const zoomInput = document.getElementById('zoom');
const deckChoice = document.getElementById('deckChoice');
const zoneOverlay = document.getElementById('zoneOverlay');
const overlayGrid = document.getElementById('overlayGrid');
const overlayTitle = document.getElementById('overlayTitle');
const gamePicker = document.getElementById('gamePicker');

const endTurnBtn = document.getElementById('endTurnBtn');

// keep an up-to-date turn seat via your existing meta poller


// --- CLICK LOGGING: deck button cluster ---
['deckSearchBtn','deckAddBtn','deckMoreBtn','endTurnBtn','viewEyeBtn'].forEach(id=>{
  const el = document.getElementById(id);
  if (!el) { console.warn('[wire] missing button:', id); return; }
  el.addEventListener('click', ()=> console.log(`[click] #${id}`));
});


endTurnBtn?.addEventListener('click', async ()=>{
  const gid = String(window.AppState?.gameId || '');
  if (!gid) { alert('Pick a Game first.'); return; }

  const mySeat = Number(window.AppState?.mySeat || 1);
  const playerCount = Number(window.AppState?.playerCount || 2);

  // Determine next seat in rotation
  const metaNow = await window.StorageAPI.loadMeta(gid);
  const cur = Number(metaNow?.TurnSeat || mySeat);
  const next = (cur % playerCount) + 1;

  // 1) Untap all permanents for the NEXT player (persist to that player's state)
  await untapAllCardsForSeat(gid, next);

  // 2) Reset combat (fresh doc; pollers will re-hydrate)
  try { await window.StorageAPI.resetCombat(gid); } catch(e){ console.warn('[end turn] resetCombat failed', e); }

// 3) Advance the turn seat in meta (timewarp bumps TurnIndex & meta.Backups)
await window.StorageAPI.saveMeta(gid, { TurnSeat: next });

// 4) Read the freshly-bumped index from meta
const metaAfter = await window.StorageAPI.loadMeta(gid);
const turnIndex = Number(metaAfter?.TurnIndex || 0);

// 5) Save LIVE turn to table + append snapshots for this turn
await saveTurnState(gid, { turnSeat: next, turnIndex });
await snapshotAllSeatsToTable(gid, turnIndex);

// 6) Local optimism (optional; watcher will repaint everyone anyway)
currentTurnSeat = next;
paintBattleFab();
showToast?.(`Turn passed to Player ${next}.`);

  await refreshWorldFromStorage();

});

// --- Helpers: untap next player's board + battle FAB + small toast ---
async function untapAllCardsForSeat(gameId, seat){
  try {
    const doc = await window.StorageAPI.loadPlayerState(gameId, seat);
    if (!doc) return;

    const next = { ...(doc||{}) };
    const table = Array.isArray(next.Table) ? next.Table : (Array.isArray(next.table)? next.table : []);
    if (Array.isArray(table) && table.length){
      for (const c of table) {
        c.tapped = false;
      }
    }

    // Persist back to that seat (keeps keys as-is; we favor your existing shape)
    await window.StorageAPI.savePlayerStateDebounced(gameId, seat, next);

    // If the viewer is looking at that seat, also force local DOM to reflect untap now
    if (Number(window.AppState?.viewSeat || 0) === Number(seat)) {
      document.querySelectorAll('#world .card.tapped').forEach(cardEl=>{
        cardEl.classList.remove('tapped');
        const inner = cardEl.querySelector('.cardInner');
        inner?.style?.setProperty('--tap-rot', '0deg');
      });
    }
  } catch(e){
    console.warn('[untapAllCardsForSeat]', e);
  }
}

// --- Hard refresh of visible cards from storage (table + commander) ---
async function refreshWorldFromStorage(){
  try{
    const gid  = String(window.AppState?.gameId || '');
    if (!gid) return;

    // whichever seat you’re currently *viewing* (own or opponent)
    const seat = Number(window.AppState?.viewSeat || window.AppState?.mySeat || 1);
    const doc  = await window.StorageAPI.loadPlayerState(gid, seat);
    if (!doc) return;

    const nextTable = Array.isArray(doc.Table) ? doc.Table
                    : (Array.isArray(doc.table) ? doc.table : []);
    const nextCom   = doc.Commander ?? doc.tableCommander ?? null;

    // build lookup by id
    const byId = new Map();
    (nextTable||[]).forEach(c => byId.set(String(c.id), c));
    if (nextCom) byId.set(String(nextCom.id), nextCom);

    // walk visible cards and re-apply tapped/face + badge/PT
    document.querySelectorAll('#world .card').forEach(el=>{
      const id = el.dataset.id;
      const nxt = byId.get(String(id));
      if (!nxt) return;

      const ref = el.__cardRef || {};
      ref.tapped = !!nxt.tapped;
      ref.face   = nxt.face || 'front';
      el.__cardRef = nxt;             // keep pointer aligned for later updates
      updateCardDom(ref);             // <- does PT, flip, tap class, images, badges
    });
  }catch(e){
    console.warn('[refreshWorldFromStorage]', e);
  }
}



// Tiny toast helper (reuses your window.showToast if present)
function showToast(msg){
  if (typeof window.showToast === 'function') return window.showToast(msg);
  console.log('[toast]', msg);
  
}




const lifeBtn = document.getElementById('lifeEditBtn');
lifeBtn?.addEventListener('click', async ()=>{
  const gid = String(window.AppState?.gameId || '');
  if (!gid) { alert('Pick a Game first.'); return; }

  // Simple prompt flow: choose seat, then enter +/- delta or absolute
  const seatStr = prompt('Which player? (seat number)', String(window.AppState?.mySeat || 1));
  const seat = parseInt(seatStr||'0',10);
  if (!Number.isFinite(seat) || seat <= 0) return;

  const meta = await window.StorageAPI.loadMeta(gid) || {};
  const life = Object.assign({},
    (meta.lifeMain || {})
  );

  const current = Number(life[seat] ?? 40);
  const valStr = prompt(`Life for Player ${seat} (enter +N / -N or an absolute number)`, `+0`);
  if (valStr == null) return;

  let nextVal = current;
  if (/^[+\-]\d+$/.test(valStr.trim())){
    nextVal = current + parseInt(valStr,10);
  } else {
    const abs = parseInt(valStr,10);
    if (Number.isFinite(abs)) nextVal = abs;
  }
  if (!Number.isFinite(nextVal)) return;

  life[seat] = nextVal;
  await window.StorageAPI.saveMeta(gid, { lifeMain: life });
  showToast?.(`Player ${seat} life → ${nextVal}`);
});







// ---------- HOT SWAP: Reset (me) with full logging ----------
function resetLog(title, data){
  try{
    console.log(
      `%c[reset] ${title}`,
      'background:#1b2538;color:#d4e0ff;border-radius:6px;padding:2px 8px;margin:2px 0',
      data ?? ''
    );
  }catch{ console.log(`[reset] ${title}`); }
}

document.getElementById('resetBtn').addEventListener('click', async ()=>{
  const gameId =
    state.gameId ||
    document.querySelector('#gamePicker .selected')?.dataset?.gameId ||
    document.querySelector('[data-game-id].selected')?.dataset?.gameId ||
    null;

  const mySeat = Number(document.getElementById('mySeat')?.value || state.mySeat || 1);

  if (!gameId){ alert('Pick Game 1/2/3 first.'); return; }

  console.groupCollapsed('[reset] BEGIN');
  resetLog('inputs', { gameId, mySeat });

  try{
    // 1) Wipe THIS player’s state
    if (typeof resetPlayerOnly === 'function'){
      await resetPlayerOnly({ hard:true, seat: mySeat });
      resetLog('resetPlayerOnly ✓');
    } else if (window.StorageAPI?.wipePlayerState){
      await window.StorageAPI.wipePlayerState(gameId, mySeat);
      resetLog('wipePlayerState ✓');
    } else if (window.StorageAPI?.deletePlayerState){
      await window.StorageAPI.deletePlayerState(gameId, mySeat);
      resetLog('deletePlayerState ✓');
    } else {
      resetLog('NO wipe function found (skipped)');
    }

    // 2) Force P1 attacker (merge-safe) + verify
    const metaAfter = await window.StorageAPI.saveMeta(gameId, m => ({
      ...m,
      TurnSeat: 1,
      TurnIndex: (m?.TurnIndex ?? 0) + 1, // nudge for painter/pollers
    }));
    resetLog('meta after save', metaAfter);

    const metaVerify = await window.StorageAPI.loadMeta(gameId);
    resetLog('meta verify', metaVerify);

    const turnSeat = Number(metaVerify?.TurnSeat ?? metaVerify?.turnSeat ?? metaVerify?.turn?.seat ?? 0);
    const isAttacker = Number(mySeat) === turnSeat;
    resetLog('computed isAttacker', { mySeat, turnSeat, isAttacker });

currentTurnSeat = Number(turnSeat);   // keep the single source of truth in sync
paintBattleFab(); 

    // 3) Ensure combat row exists + clear any stale combat data
    if (window.StorageAPI?.ensureCombatRow){
      await window.StorageAPI.ensureCombatRow(gameId);
      resetLog('ensureCombatRow ✓');
    }
    if (window.StorageAPI?.resetCombat){
      await window.StorageAPI.resetCombat(gameId);
      resetLog('resetCombat ✓');
    }
    if (window.StorageAPI?.readCombat){
      const combatAfter = await window.StorageAPI.readCombat(gameId);
      resetLog('combat after reset', combatAfter);
    }

    // 4) Local view + UI refresh
    state.mySeat = mySeat;
    if (state.viewSeat !== mySeat) await setViewSeat(mySeat);
    await loadGameIntoUI(gameId);

    resetLog('DONE');
    console.groupEnd();

  }catch(err){
    console.error('[reset] ERROR', err);
    console.groupEnd();
    alert('Reset failed — see console.');
  }
});
// ---------- /HOT SWAP ----------



function nextSeat(cur, total){
  return (cur % total) + 1; // 1→2→3→1
}

async function setViewSeat(seat){
  if (!state.gameId) { alert('Pick Game 1/2/3 first.'); return; }

  // stop any running poller
  if (state.viewPoller){ clearInterval(state.viewPoller); state.viewPoller = null; }

  state.viewSeat = seat;
  state.viewReadOnly = (seat !== state.mySeat);
  document.body.classList.toggle('viewing-opponent', state.viewReadOnly);

  clearSelection();

  if (!state.viewReadOnly){
    // Back to self: load my data and render normally (hand visible, drag enabled)
    await loadGameIntoUI(state.gameId);
    renderHand();
    return;
  }

  // Viewing an opponent: hydrate once and start the 100ms poller
  const first = await window.window.StorageAPI.loadPlayerState(state.gameId, state.viewSeat);
  await hydrateOpponentIntoView(first || { Deck:[], Hand:[], Table:[], Graveyard:[], Exile:[], Commander:null });
  startViewPoller();
}

viewEyeBtn.addEventListener('click', async ()=>{
  const target = nextSeat(state.viewSeat, state.playerCount);
  await setViewSeat(target);
});


async function ensureTurnSeatMeta(){
  if (!state.gameId) return;
  const m = await window.window.StorageAPI.loadMeta(state.gameId);
  if (!m || !m.TurnSeat){
    // First person in sets it to themself (or pick 1 if you prefer)
    await window.window.StorageAPI.saveMeta(state.gameId, { TurnSeat: state.mySeat });
  }
}





const playerCountSel = document.getElementById('playerCount');
const mySeatSel      = document.getElementById('mySeat');

// Initialize from selects (or localStorage if you want the choice to persist)
const savedSeat = Number(localStorage.getItem('mySeat') || mySeatSel.value);
const savedCount = Number(localStorage.getItem('playerCount') || playerCountSel.value);
mySeatSel.value = String(savedSeat);
playerCountSel.value = String(savedCount);
state.mySeat = savedSeat;
state.playerCount = savedCount;

// React to changes
mySeatSel.addEventListener('change', async (e) => {
  state.mySeat = Number(e.target.value);
  localStorage.setItem('mySeat', String(state.mySeat));
  if (state.gameId) {
    // reload the current game for the newly selected seat
    await loadGameIntoUI(state.gameId);
  }
});

playerCountSel.addEventListener('change', (e) => {
  state.playerCount = Number(e.target.value);
  localStorage.setItem('playerCount', String(state.playerCount));
});

document.addEventListener('keydown', (e)=>{
  // ignore while typing or in read-only view
  const tag = (document.activeElement && document.activeElement.tagName) || '';
  if (/(INPUT|TEXTAREA|SELECT)/.test(tag) || state.viewReadOnly) return;

  const id = state.selectedCardId;
  if (!id) return;
  const card = getCardById(id);
  if (!card) return;

  if (e.key === 't' || e.key === 'T'){ e.preventDefault(); toggleTap(card); }
  else if (e.key === 'f' || e.key === 'F'){ e.preventDefault(); toggleFlip(card); }
});


/* Deck back preload */
(function ensureDeckBack(){
  const img = new Image();
  img.onload = ()=>{ deckZone.style.backgroundImage = `url("${CARD_BACK_URL}")`; };
  img.onerror = ()=>{ setTimeout(ensureDeckBack, 800); };
  img.referrerPolicy = 'no-referrer';
  img.src = CARD_BACK_URL;
  deckZone.style.backgroundImage = `url("${CARD_BACK_URL}")`;
})();

/* Drawer toggle */
cogBtn.addEventListener('click', ()=>{
  const open = !drawerWrap.classList.contains('expanded');
  drawerWrap.classList.toggle('collapsed', !open);
  drawerWrap.classList.toggle('expanded', open);
  zoomWrapEl.style.display = open ? 'none' : 'flex';
});

/* Pan/Zoom */
function positionDeckActions(){
  const deck = document.getElementById('deckZone');
  const da   = document.getElementById('deckActions');
  if (!deck || !da) return;

  const wr = document.getElementById('world').getBoundingClientRect();
  const zr = deck.getBoundingClientRect();

  const x = (zr.left - wr.left) - 64;               // 64px to the left
  const y = (zr.top  - wr.top)  + (zr.height/2) - 28; // vertically centered

  da.style.position = 'absolute';
  da.style.left = x + 'px';
  da.style.top  = y + 'px';
}

function applyWorldTransform(){
  worldScaleEl.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
  worldScaleEl.style.setProperty('--world-zoom', state.zoom);
  repositionUIOverlays();
  positionAllBadges();
  positionDeckActions();            // ← add this line
}


function repositionUIOverlays(){
  const selId = state.selectedCardId;
  if(!selId) return;
  const el = worldEl.querySelector(`.card[data-id="${selId}"]`);
  if(!el) return;
  positionActions(el);
  if (tooltipEl) positionTooltip(el);
}
zoomInput.addEventListener('input', (e)=>{ state.zoom = Number(e.target.value)/100; applyWorldTransform(); });
let draggingCard = false;

// --- pan state ---
let panning = false, panStartX = 0, panStartY = 0, panBaseX = 0, panBaseY = 0;

// --- pinch state ---
const activeTouches = new Map(); // pointerId -> {x,y}
let pinchActive = false, pinchStartDist = 0, pinchStartZoom = 1;

function getMidAndDist() {
  const pts = [...activeTouches.values()];
  if (pts.length < 2) return null;
  const ax = pts[0].x, ay = pts[0].y, bx = pts[1].x, by = pts[1].y;
  const mx = (ax + bx) / 2, my = (ay + by) / 2;
  const dx = bx - ax, dy = by - ay;
  const dist = Math.hypot(dx, dy);
  return { mx, my, dist };
}

worldWrap.addEventListener('pointerdown', (e) => {
  const t = e.target;
  if (
    draggingCard ||
    t.closest('.card') ||
    t.closest('.zone') ||
    t.closest('.zoomWrap') ||
    t.closest('.toolbar') ||
    t.closest('.deck-actions')
  ) return;

  // track this pointer
  activeTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });
  try { worldWrap.setPointerCapture(e.pointerId); } catch(_) {}

  const two = getMidAndDist();
  if (two && activeTouches.size === 2) {
    // start pinch
    pinchActive   = true;
    pinchStartDist = two.dist;
    pinchStartZoom = state.zoom;
    panning = false; // disable one-finger pan while pinching
    worldWrap.classList.add('panning'); // reuse the cursor style
  } else if (activeTouches.size === 1) {
    // start one-finger pan
    panning   = true;
    panStartX = e.clientX; panStartY = e.clientY;
    panBaseX  = state.panX; panBaseY  = state.panY;
    worldWrap.classList.add('panning');
  }
});

worldWrap.addEventListener('pointermove', (e) => {
  // keep the latest point for this pointer
  if (activeTouches.has(e.pointerId)) {
    activeTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });
  }

  // pinch zoom?
  if (pinchActive && activeTouches.size >= 2) {
    e.preventDefault();
    const two = getMidAndDist();
    if (!two) return;

    // scale around pinch midpoint
    const r = worldScaleEl.getBoundingClientRect();
    const mx = two.mx - r.left, my = two.my - r.top;

    // world coords of the anchor BEFORE zoom change
    const wx = (mx - state.panX) / state.zoom;
    const wy = (my - state.panY) / state.zoom;

    const k = two.dist / pinchStartDist;
    const newZoom = clamp(pinchStartZoom * k, 0.4, 1.6);

    state.zoom = newZoom;
    state.panX = mx - wx * state.zoom;
    state.panY = my - wy * state.zoom;

    zoomInput.value = Math.round(state.zoom * 100);
    applyWorldTransform();
    return;
  }

  // one-finger pan
  if (panning && activeTouches.size === 1) {
    e.preventDefault();
    state.panX = panBaseX + (e.clientX - panStartX);
    state.panY = panBaseY + (e.clientY - panStartY);
    applyWorldTransform();
  }
}, { passive:false });

function endPointer(e) {
  if (activeTouches.has(e.pointerId)) activeTouches.delete(e.pointerId);

  if (pinchActive && activeTouches.size < 2) {
    // end pinch
    pinchActive = false;
  }
  if (panning && activeTouches.size === 0) {
    panning = false;
    worldWrap.classList.remove('panning');
  }
}
worldWrap.addEventListener('pointerup', endPointer);
worldWrap.addEventListener('pointercancel', endPointer);


/* Wheel zoom */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
worldWrap.addEventListener('wheel', (e)=>{
  if (e.ctrlKey) return; e.preventDefault();
  const k = Math.pow(1.0015, -e.deltaY * (e.deltaMode === 1 ? 12 : 1));
  const newZoom = clamp(state.zoom * k, 0.4, 1.6);
  const r = worldScaleEl.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  const wx = (mx - state.panX) / state.zoom, wy = (my - state.panY) / state.zoom;
  state.zoom = newZoom; state.panX = mx - wx * state.zoom; state.panY = my - wy * state.zoom;
  zoomInput.value = Math.round(state.zoom * 100); applyWorldTransform();
},{passive:false});

/* Utils */
/* ==== Stacking detection + preview ==================================== */
let _stackPreviewEl = null;  // single reusable arrow
let _stackPreview = null;    // { targetId, dir } during drag

function getCardElById(id){ return document.querySelector(`.card[data-id="${id}"]`); }
function cardRect(el){ return el.getBoundingClientRect(); }

// pick the card we overlap the MOST, return {el, dir|null}
function findBestOverlapDir(dragEl){
  const a = cardRect(dragEl);
  let best = null, bestArea = 0;

  document.querySelectorAll('#world .card').forEach(el=>{
    if (el === dragEl) return;
    const b = cardRect(el);
    const ox = Math.max(0, Math.min(a.right,b.right) - Math.max(a.left,b.left));
    const oy = Math.max(0, Math.min(a.bottom,b.bottom) - Math.max(a.top,b.top));
    const area = ox * oy;
    if (area > bestArea){ bestArea = area; best = el; }
  });

  if (!best) return null;
  // require a meaningful overlap (~10% of card area)
  const minArea = (a.width * a.height) * 0.10;
  if (bestArea < minArea) return null;

  const br = cardRect(best);
  const cx = (a.left + a.right)/2;
  const cy = (a.top  + a.bottom)/2;
  const rx = (cx - br.left) / br.width;   // 0..1
  const ry = (cy - br.top)  / br.height;  // 0..1

  // your rule: top half => "up", left/right vertical edges => left/right
  let dir = null;
  if (ry < 0.35) dir = 'up';
  else if (rx < 0.32) dir = 'left';
  else if (rx > 0.68) dir = 'right';

  return dir ? { el: best, dir } : null;
}

function ensureStackArrow(){
  if (_stackPreviewEl) return _stackPreviewEl;
  const d = document.createElement('div');
  d.className = 'stackArrow';
  d.innerHTML = `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
         stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M5 12h14M13 5l7 7-7 7"></path>
    </svg>
    <span class="lbl"></span>`;
  document.getElementById('world').appendChild(d);
  _stackPreviewEl = d;
  return d;
}

function showStackArrow(targetEl, dir){
  const arrow = ensureStackArrow();
  arrow.classList.remove('dir-left','dir-right','dir-up');
  arrow.classList.add('dir-' + dir);
  arrow.querySelector('.lbl').textContent =
    dir === 'up' ? 'Stack Up' : ('Stack ' + (dir === 'left' ? 'Left' : 'Right'));

  // ← Always position ABOVE the target card’s center
  const wr = document.getElementById('world').getBoundingClientRect();
  const tr = targetEl.getBoundingClientRect();
  const ax = tr.left + tr.width / 2 - wr.left;
  const ay = tr.top - wr.top - 22;  // a little above the top edge

  arrow.style.left = ax + 'px';
  arrow.style.top  = ay + 'px';
  arrow.style.display = 'flex';
}

function hideStackArrow(){
  if (_stackPreviewEl) _stackPreviewEl.style.display = 'none';
  _stackPreview = null;
}

// apply stack on drop
async function applyStackDrop(dragCard, dragEl, baseCard, dir){
  const cs = getComputedStyle(document.documentElement);
  const cardW = parseFloat(cs.getPropertyValue('--card-w')) || 223;
  const cardH = parseFloat(cs.getPropertyValue('--card-h')) || 310;

  const baseEl = getCardElById(baseCard.id);
  const bx = baseCard.x ?? (baseEl ? parseFloat(baseEl.style.left)||0 : 0);
  const by = baseCard.y ?? (baseEl ? parseFloat(baseEl.style.top)||0 : 0);

  // helper: guarantee z ordering (drag under base)
  const baseZ = parseInt(baseEl?.style.zIndex || '1000', 10);
  if (baseEl) baseEl.style.zIndex = String(baseZ);
  dragEl.style.zIndex = String(baseZ - 1);

  if (dir === 'left' || dir === 'right'){
    // Keep columns far enough apart for tapped (sideways) cards:
    // gap >= card height (plus a hair).
    const gap = Math.round(cardH * 1.02);
    const nx = bx + (dir === 'right' ? gap : -gap);
    const ny = by + 6; // tiny vertical tidy

    dragEl.style.left = (dragCard.x = nx) + 'px';
    dragEl.style.top  = (dragCard.y = ny) + 'px';

    // row stacks are not coupled
    delete dragCard.stackId;

    if (state.table.find(c=>c.id===dragCard.id)) await writeTableMove(dragCard, dragEl);
    else                                         await writeTableAdd(dragCard);

    // keep the base on top visually
    if (baseEl) selectCard(baseCard.id, baseEl);
    return;
  }

  // dir === 'up' → coupled stack (pile)
  const stackId = baseCard.stackId || ('stack_' + (baseCard.id || Math.random().toString(36).slice(2)));
  baseCard.stackId = stackId;
  dragCard.stackId = stackId;

  // offset so the new card tucks UNDER the base one
  const offsetY = Math.round(cardH * 0.55);
  const nx = bx;
  const ny = by - offsetY;

  dragEl.style.left = (dragCard.x = nx) + 'px';
  dragEl.style.top  = (dragCard.y = ny) + 'px';

  if (state.table.find(c=>c.id===dragCard.id)) await writeTableMove(dragCard, dragEl);
  else                                         await writeTableAdd(dragCard);

  // keep the base selected so it stays visually on top
  if (baseEl) selectCard(baseCard.id, baseEl);
}


function rectsOverlap(a,b){ return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom); }
function zoneHit(el){
  const r = el.getBoundingClientRect();
  const cx = (r.left + r.right) / 2;
  const cy = (r.top  + r.bottom) / 2;
  const hits = [];
  for (const z of [deckZone, cmdZone, gyZone, exileZone]){
    const zr = z.getBoundingClientRect();
    if (cx >= zr.left && cx <= zr.right && cy >= zr.top && cy <= zr.bottom){
      hits.push(z);
    }
  }
  return hits;
}

function clientToWorld(x, y){ const r = worldScaleEl.getBoundingClientRect(); return { x: (x - r.left) / state.zoom, y: (y - r.top) / state.zoom }; }
function elementCenterWorld(el){ const rr = el.getBoundingClientRect(); return clientToWorld(rr.left + rr.width/2, rr.top + rr.height/2); }
function getHandSlotCenterWorld(index){
  const slot = handTrack.querySelector(`.handCard[data-index="${index}"]`);
  if(!slot){ const hr = document.getElementById('hand').getBoundingClientRect(); return clientToWorld(hr.left + hr.width/2, hr.top + hr.height*0.25); }
  const rr = slot.getBoundingClientRect(); return clientToWorld(rr.left + rr.width/2, rr.top + rr.height/2);
}

/* —— IMAGE PIPELINE: NEVER MIRROR FRONT —— */
function pickFaceImages(card){
  const faces = Array.isArray(card?._faces) ? card._faces : [];
  const front = faces[0]?.image || card?.frontImg || '';
  const back  = faces[1]?.image || ''; // STRICT: never fall back to front for DFC
  return { front, back };
}
function normalizeCardImages(card){
  const faces = Array.isArray(card?._faces) ? card._faces : [];
  const { front, back } = pickFaceImages(card);
  card.frontImg = front || '';
  // If card is truly single-faced, leave back empty so renderer uses MTG back.
  card.backImg  = (faces.length > 1) ? (back || '') : '';
  // Guardrail: if multi-faced and we still don't have a distinct back, warn loudly (but do not mirror)
  if (faces.length > 1 && (!card.backImg || card.backImg === card.frontImg)){
    console.error('[DFC BACK MISSING] Refusing to mirror front art. Card:', card.name, {front:card.frontImg, back:card.backImg, faces});
  }
}
function applyFaceImages(cardEl, card){
  const faces = Array.isArray(card?._faces) ? card._faces : [];
  const frontEl = cardEl.querySelector('.face.front');
  const backEl  = cardEl.querySelector('.face.back');
  if (frontEl) frontEl.style.backgroundImage = card.frontImg ? `url("${card.frontImg}")` : '';
  if (backEl){
    if (faces.length > 1){
      // DFC: use only the real back art; do NOT mirror front
      backEl.style.backgroundImage = card.backImg ? `url("${card.backImg}")` : '';
    }else{
      // Single-faced: show MTG card back
      backEl.style.backgroundImage = `url("${CARD_BACK_URL}")`;
    }
  }
}

/* Card DOM */
function makeCardEl(card){
  normalizeCardImages(card);
  const el = document.createElement('div'); el.className='card'; if (card.tapped) el.classList.add('tapped'); el.__cardRef = card;
  el.style.left = (card.x ?? 300) + 'px'; el.style.top  = (card.y ?? 120) + 'px'; el.dataset.id = card.id;

  const inner = document.createElement('div'); inner.className='cardInner';
  inner.style.setProperty('--flip-rot', card.face === 'back' ? '180deg' : '0deg');
  inner.style.setProperty('--tap-rot',  card.tapped ? '90deg' : '0deg');

  const front = document.createElement('div'); front.className='face front';
  const back  = document.createElement('div'); back.className='face back';
  inner.appendChild(front); inner.appendChild(back); el.appendChild(inner);

  applyFaceImages(el, card);

const pt = document.createElement('div');
pt.className = 'pt';
pt.textContent = computePT(card);
el.appendChild(pt);

  el.addEventListener('pointerdown', (ev)=>{ ev.stopPropagation(); selectCard(card.id, el); });
  return el;
}

/* Selection + actions */
let actionsEl = null, tooltipEl = null;
function clearSelection(){
  if(!state.selectedCardId && !tooltipEl) return;
  const prev = worldEl.querySelector('.card[data-id="'+state.selectedCardId+'"]'); if(prev){ prev.classList.remove('selected'); prev.style.zIndex=''; }
  state.selectedCardId = null; if(actionsEl){ actionsEl.remove(); actionsEl=null; } hideTooltip();
}
function getCardWorldBox(cardEl){
  const x = parseFloat(cardEl.style.left)||0, y = parseFloat(cardEl.style.top)||0;
  const cs = getComputedStyle(cardEl); const w = parseFloat(cs.width)||223; const h = parseFloat(cs.height)||310; return {x,y,w,h};
}
function positionActions(el){
  if(!actionsEl) return; const {x,y,w}=getCardWorldBox(el); actionsEl.style.left=(x+w+8)+'px'; actionsEl.style.top=(y+6)+'px'; positionTooltip(el);
}
function hideTooltip(){ if(tooltipEl){ tooltipEl.remove(); tooltipEl=null; } }

function ensureOrUpdateCardBadge(card){
  // Only show when there is something to show
  const hasCounters = Array.isArray(card._counters) && card._counters.length > 0;
  const hasNotes    = !!(card._notes && card._notes.trim().length);
  if (!hasCounters && !hasNotes){ removeCardBadge(card.id); return; }

  let el = document.querySelector(`.cardBadge[data-id="${card.id}"]`);
  if (!el){
    el = document.createElement('div');
    el.className = 'cardBadge';
    el.dataset.id = card.id;
    document.getElementById('world').appendChild(el);
  }

  // Build chips + note snippet
  const chips = (card._counters || [])
    .filter(c=>c && c.name && c.qty)
    .map(c=>`<span class="bchip">${c.name}: ${c.qty}</span>`)
    .join('');
  const note  = card._notes ? `<span class="notes">${escapeHtml(card._notes)}</span>` : '';

  el.innerHTML = chips + note;
  positionCardBadgeFor(card);
}

function removeCardBadge(cardId){
  const el = document.querySelector(`.cardBadge[data-id="${cardId}"]`);
  if (el) el.remove();
}

function positionCardBadgeFor(card){
  const cardEl = getCardElById(card.id);
  const badge  = document.querySelector(`.cardBadge[data-id="${card.id}"]`);
  if (!cardEl || !badge) return;

  // Use the same world-space anchor math as positionActions()
  const { x, y, w, h } = getCardWorldBox(cardEl);
  // bottom-center, with a tiny gap
  badge.style.left = (x + (w / 2)) + 'px';
  badge.style.top  = (y + h + 6) + 'px';
}


function positionAllBadges(){
  document.querySelectorAll('.cardBadge').forEach(b=>{
    const id = b.dataset.id;
    const card = getCardById(id);
    if (card) positionCardBadgeFor(card);
  });
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g,m=>({ '&':'&nbsp;&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]||m));
}


/* --- mana-master helpers: turn {W}{U}{2/R}{T} into <i class="ms ..."> --- */
function manaClassForToken(tok){
  if (tok === 'T') return 'tap';
  if (tok === 'Q') return 'untap';
  if (tok === '1/2') return '1-2';

  const simple = {
    '0':'0','1':'1','2':'2','3':'3','4':'4','5':'5','6':'6','7':'7','8':'8','9':'9','10':'10',
    '11':'11','12':'12','13':'13','14':'14','15':'15','16':'16','17':'17','18':'18','19':'19','20':'20',
    'X':'x','Y':'y','Z':'z','E':'e','C':'c','S':'s','L':'l','∞':'infinity'
  };
  if (tok in simple) return simple[tok];

  // Hybrids / Phyrexian / 2-color / 2-or-color / C-hybrids
  if (tok.includes('/')){
    const parts = tok.split('/');
    if (parts.length === 2 && parts.includes('P')) {
      const color = parts[0] === 'P' ? parts[1] : parts[0];
      return 'p' + color.toLowerCase();       // pw, pu, pb, pr, pg
    }
    if (parts.length === 2 && /^[WUBRG]$/.test(parts[0]) && /^[WUBRG]$/.test(parts[1])) {
      return parts[0].toLowerCase() + parts[1].toLowerCase(); // wu, br, etc.
    }
    if (parts.length === 2 && parts.includes('C')) {
      const other = (parts[0] === 'C' ? parts[1] : parts[0]).toLowerCase();
      return 'c' + other;                      // cw, cu, cb, cr, cg
    }
    if (parts.length === 2 && parts[0] === '2' && /^[WUBRG]$/.test(parts[1])) {
      return '2' + parts[1].toLowerCase();     // 2w, 2u, etc.
    }
  }

  const colors = {W:'w',U:'u',B:'b',R:'r',G:'g'};
  if (tok in colors) return colors[tok];

  return tok.toLowerCase(); // best-effort fallback
}

function renderManaFromBraces(str, { asCost = false } = {}){
  if (!str) return '';
  return str.replace(/\{([^}]+)\}/g, (_, inside) => {
    const tok = inside.trim().toUpperCase();
    const cls = manaClassForToken(tok);
    const extra = asCost ? ' ms-cost' : '';
    return `<i class="ms ms-${cls}${extra}"></i>`;
  });
}

// We’ll use the *colored* style both for cost and body, per your preference
const renderManaCost   = (s) => renderManaFromBraces(s, { asCost:true });
const renderOracleMana = (s) => renderManaFromBraces(s, { asCost:true });


function buildTooltipFor(card, anchorEl){
  // clear previous
  if (typeof hideTooltip === 'function') hideTooltip();

  // If we’re showing a plain back (no alt face), don’t show tooltip
  if (card.face === 'back' && !(card._faces && card._faces.length > 1)) return;

  const face     = (card._faces && card._faces.length > 1)
                    ? (card.face === 'back' ? card._faces[1] : card._faces[0])
                    : (card._faces?.[0] || {});
  const name     = face.name || card.name || 'Unknown';
  const typeLine = face.type_line || '';
// Find oracle text from multiple sources so tooltips work on opponent cards too
const oracleRaw =
  (face.oracle_text) ||
  (card._faces?.map(f => f.oracle_text).filter(Boolean).join('\n')) ||
  (card._scry?.oracle_text) ||
  (card._scry?.faces?.map(f => f.oracle_text).filter(Boolean).join('\n')) ||
  '';

const oracle = oracleRaw.trim();
  const manaCost = face.mana_cost || card._scry?.mana_cost || '';
const pt = computePT(card);
  const div = document.createElement('div');
  div.className = 'cardTooltip';
  div.style.position = 'absolute';
  div.style.left = '50%';
  div.style.bottom = 'calc(100% + 8px)';

  div.innerHTML = `
    <h3>${name}</h3>
    ${manaCost ? `<div class="cost" style="margin-bottom:6px;">${renderManaCost(manaCost)}</div>` : ''}
    ${typeLine ? `<div class="typeLine">${typeLine}</div>` : ''}
    ${oracle ? `<div class="oracle">${renderOracleMana(oracle)}</div>` : ''}
    ${pt       ? `<div class="pt">${pt}</div>` : ''}
  `;

  (anchorEl || document.getElementById('world')).appendChild(div);
  tooltipEl = div;
}

function positionTooltip(anchorEl){
  if(!tooltipEl) return; const p = tooltipEl.parentElement; if (p && p.classList.contains('card')) return;
  if (anchorEl){ const r = anchorEl.getBoundingClientRect(); const wr = worldEl.getBoundingClientRect(); const x=(r.left+r.width/2)-wr.left; const y=r.top-wr.top; tooltipEl.style.left=(x - tooltipEl.offsetWidth/2)+'px'; tooltipEl.style.top=(y - tooltipEl.offsetHeight - 8)+'px'; }
}
function buildActionsFor(card, anchorEl){
  if(actionsEl) actionsEl.remove();
  const wrap = document.createElement('div'); wrap.className='cardActions';
  wrap.innerHTML = `<button class="qa" data-act="settings" title="Settings">⚙️</button><button class="qa" data-act="tap" title="Tap">T</button><button class="qa" data-act="flip" title="Flip">F</button>`;
  wrap.addEventListener('click',(e)=>{ e.stopPropagation(); const btn=e.target.closest('.qa'); if(!btn) return; const act=btn.dataset.act;
    if(act==='tap') toggleTap(card);
    else if(act==='flip') toggleFlip(card);
    else if(act==='settings') openCardSettings(card);
  });
  worldEl.appendChild(wrap); actionsEl=wrap; positionActions(anchorEl);
}
function selectCard(id, el){
  if(state.selectedCardId && state.selectedCardId !== id){
    const prev = worldEl.querySelector('.card[data-id="'+state.selectedCardId+'"]');
    if(prev){ prev.classList.remove('selected'); prev.style.zIndex=''; }
  }
  state.selectedCardId = id;
  el.classList.add('selected');
  el.style.zIndex = '9999';

  const card = getCardById(id) || el.__cardRef;
  if(!card) return;

  // When viewing an opponent: tooltip only, no quick actions
  if (state.viewReadOnly){
    buildTooltipFor(card, el);
    return;
  }

  buildActionsFor(card, el);
  buildTooltipFor(card, el);
}

document.addEventListener('pointerdown',(e)=>{ if(!e.target.closest('.card') && !e.target.closest('.cardActions') && !e.target.closest('.toolbar') && !e.target.closest('.drawer')){ clearSelection(); } });

/* Tap/Flip */
function getCardById(id){ return state.table.find(c=>c.id===id) || state.hand.find(c=>c.id===id); }
function updateCardDom(card){
  const el = worldEl.querySelector(`.card[data-id="${card.id}"]`); if(!el) return;
  const ptEl = el.querySelector('.pt');
if (ptEl) ptEl.textContent = computePT(card);

  const inner = el.querySelector('.cardInner');
  inner.style.setProperty('--flip-rot', card.face === 'back' ? '180deg' : '0deg');
  inner.style.setProperty('--tap-rot',  card.tapped ? '90deg' : '0deg');
  el.classList.toggle('tapped', !!card.tapped);

  normalizeCardImages(card);           // refresh from _faces
  applyFaceImages(el, card);           // re-apply DOM images (NO mirroring)
ensureOrUpdateCardBadge(card);       // (re)build if needed
positionCardBadgeFor(card);          // keep badge glued to the card

  reanchorDuringTransition(el); positionActions(el); if (tooltipEl) positionTooltip(el);
}
let _reanchorRAF=null;
function reanchorDuringTransition(cardEl, durationMs=420){
  if(!cardEl) return; const start=performance.now(); if(_reanchorRAF) cancelAnimationFrame(_reanchorRAF);
  const tick=(now)=>{ positionActions(cardEl); if(tooltipEl) positionTooltip(cardEl); if(now-start<durationMs && state.selectedCardId){ _reanchorRAF=requestAnimationFrame(tick); } };
  _reanchorRAF=requestAnimationFrame(tick);
}

function persistCardState(card){
  if (!state.gameId) return;

  let changed = false;

  // Table card
  const ti = state.table.findIndex(c => c.id === card.id);
  if (ti > -1){
    state.table[ti].tapped = !!card.tapped;
    state.table[ti].face   = card.face || 'front';
    changed = true;
  }

  // Commander card
  if (state.tableCommander && state.tableCommander.id === card.id){
    state.tableCommander.tapped = !!card.tapped;
    state.tableCommander.face   = card.face || 'front';
    changed = true;
  }

  if (changed){
    window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state);
  }
}


function toggleTap(card){
  card.tapped = !card.tapped;
  updateCardDom(card);
  if (!state.viewReadOnly) persistCardState(card);
}

function toggleFlip(card){
  card.face = (card.face === 'front') ? 'back' : 'front';
  updateCardDom(card);
  if (!state.viewReadOnly) persistCardState(card);
}

document.addEventListener('keydown',(e)=>{
  const tag=(document.activeElement&&document.activeElement.tagName)||''; if(/(INPUT|TEXTAREA|SELECT)/.test(tag)) return;
  const id=state.selectedCardId; if(!id) return; const card=getCardById(id); if(!card) return;
  if(e.key==='t'||e.key==='T'){ e.preventDefault(); toggleTap(card); }
  else if(e.key==='f'||e.key==='F'){ e.preventDefault(); toggleFlip(card); }
});
let _csEditingId = null;

/* ========= DEBUG HELPERS: exact “where” + per-field lines ========== */
function __docPath(gameId, seat){
  // If your storage.js uses a different shape, tweak this string.
  return `games/${gameId} / players/${seat}`;
}

// make it visible to other <script type="module"> blocks
window.__docPath = window.__docPath || __docPath;


function __locateCardInState(card){
  const id = String(card?.id||'');
  const zones = [
    ['Table',       state.table],
    ['Hand',        state.hand],
    ['Deck',        state.deck],
    ['Graveyard',   state.gy],
    ['Exile',       state.exile],
  ];
  for (const [zoneName, arr] of zones){
    const idx = Array.isArray(arr) ? arr.findIndex(c => String(c?.id) === id) : -1;
    if (idx > -1) return { zone: zoneName, index: idx, basePath: `${zoneName}[${idx}]` };
  }
  if (state.tableCommander && String(state.tableCommander.id) === id){
    return { zone: 'Commander', index: null, basePath: 'Commander' };
  }
  return { zone: 'Unknown', index: null, basePath: '(not found in state)' };
}

function __logField(where, label, basePath, persisted, runtime){
  // One line per field with the *exact* field path under the player doc
  const fieldPath = `${basePath}.ext.${label}`;
  console.log(
    `[${where}] ${__docPath(state.gameId, state.mySeat)}  →  ${fieldPath}`,
    '\n  persisted:', persisted,
    '\n  runtime  :', runtime
  );
}

function __logCardSettingsProbe(card, when='CS OPEN'){
  const loc = __locateCardInState(card);
  const base = loc.basePath;

  // persisted (what’s in the object that will be written) vs runtime (what UI uses)
  const ext = card.ext || {};
  __logField(when, 'effects',     base, ext.effects ?? [],   card._extraEffects ?? []);
  __logField(when, 'types',       base, ext.types ?? [],     card._extraTypes ?? []);
  __logField(when, 'chosenType',  base, ext.chosenType ?? '',card._chosenType ?? '');
  __logField(when, 'ptMod',       base, ext.ptMod ?? {p:0,t:0}, card._ptMod ?? {p:0,t:0});
  __logField(when, 'counters',    base, ext.counters ?? [],  card._counters ?? []);
  __logField(when, 'notes',       base, ext.notes ?? '',     card._notes ?? '');

  // A short “summary” line to anchor the block
  console.info(`[${when}] card: ${card.name || '(unknown)'}  id=${card.id}  zone=${loc.zone} index=${loc.index}`);
}


function openCardSettings(card){
  if (!card) return;
  __logCardSettingsProbe(card, 'CS OPEN');
  _csEditingId = card.id;

  // ensure storage buckets on the card object
  card._extraTypes   = Array.isArray(card._extraTypes) ? card._extraTypes : [];
  card._extraEffects = Array.isArray(card._extraEffects) ? card._extraEffects : [];
  card._chosenType   = card._chosenType || '';
  card._ptMod        = card._ptMod || { p:0, t:0 };
  card._counters     = Array.isArray(card._counters) ? card._counters : []; // [{name, qty}]
  card._notes        = card._notes || '';

  // fill UI
  document.getElementById('csTitle').textContent = `Card Settings — ${card.name || 'Unknown'}`;
  fillChips('csTypesChips', card._extraTypes);
  fillChips('csEffectsChips', card._extraEffects);
  document.getElementById('csTypesInput').value   = '';
  document.getElementById('csEffectsInput').value = '';
  document.getElementById('csChosenType').value   = card._chosenType;
  document.getElementById('csPowMod').value       = Number(card._ptMod.p||0);
  document.getElementById('csTghMod').value       = Number(card._ptMod.t||0);
  renderCountersList(card._counters);
  document.getElementById('csNewCounterName').value = '';
  document.getElementById('csNewCounterQty').value  = 1;
  document.getElementById('csNotes').value        = card._notes || '';

  // show overlay
  document.getElementById('cardSettings').style.display = 'block';
}

function closeCardSettings(){
  document.getElementById('cardSettings').style.display = 'none';
  _csEditingId = null;
}

// helpers for chips
function fillChips(chipsId, arr){
  const host = document.getElementById(chipsId);
  host.innerHTML = '';
  (arr||[]).forEach((txt, i)=>{
    const span = document.createElement('span');
    span.className = 'cs-chip';
    span.textContent = txt;
    span.title = 'Click to remove';
    span.addEventListener('click', ()=>{
      arr.splice(i,1);
      fillChips(chipsId, arr);
    });
    host.appendChild(span);
  });
}

function pushChip(inputId, chipsId, targetArr){
  const v = (document.getElementById(inputId).value || '').trim();
  if (!v) return;
  targetArr.push(v);
  document.getElementById(inputId).value = '';
  fillChips(chipsId, targetArr);

  const card = getCardById(_csEditingId);
  if (card) { persistCardExt(card); } // bake + write now
}


// counters UI
function renderCountersList(list){
  const host = document.getElementById('csCounters');
  host.innerHTML = '';
  (list||[]).forEach((c, idx)=>{
    const row = document.createElement('div');
    row.className = 'counterRow';
    row.innerHTML = `
      <input value="${c.name || ''}" placeholder="name"/>
      <input type="number" value="${Number(c.qty||0)}" placeholder="qty"/>
      <button class="delBtn">−</button>
    `;
    const [nameEl, qtyEl, delBtn] = row.children;

    nameEl.addEventListener('input', ()=>{
      c.name = nameEl.value.trim();
      const card = getCardById(_csEditingId);
      if (card) { persistCardExt(card); }
    });

    qtyEl.addEventListener('input', ()=>{
      c.qty  = Number(qtyEl.value||0);
      const card = getCardById(_csEditingId);
      if (card) { persistCardExt(card); }
    });

    delBtn.addEventListener('click', ()=>{
      list.splice(idx,1);
      renderCountersList(list);
      const card = getCardById(_csEditingId);
      if (card) { persistCardExt(card); }
    });

    host.appendChild(row);
  });
}


// wire inputs
(function wireCardSettingsOnce(){
  const cs = document.getElementById('cardSettings');
  if (!cs) return;

  // close
  document.getElementById('csClose').addEventListener('click', closeCardSettings);

  // chip inputs
  document.getElementById('csTypesInput').addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){
      const card = getCardById(_csEditingId); if (!card) return;
      pushChip('csTypesInput', 'csTypesChips', card._extraTypes);
    }
  });
  document.getElementById('csEffectsInput').addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){
      const card = getCardById(_csEditingId); if (!card) return;
      pushChip('csEffectsInput', 'csEffectsChips', card._extraEffects);
    }
  });

  // add counter
  document.getElementById('csAddCounter').addEventListener('click', ()=>{
    const card = getCardById(_csEditingId); if (!card) return;
    const name = (document.getElementById('csNewCounterName').value || '').trim();
    const qty  = Number(document.getElementById('csNewCounterQty').value || 1);
    if (!name) return;
    card._counters.push({ name, qty: isFinite(qty) ? qty : 1 });
    document.getElementById('csNewCounterName').value = '';
    document.getElementById('csNewCounterQty').value  = 1;
    renderCountersList(card._counters);
  });

  // clear
document.getElementById('csClear').addEventListener('click', ()=>{
  const card = getCardById(_csEditingId); if (!card) return;
  card._extraTypes = [];
  card._extraEffects = [];
  card._chosenType = '';
  card._ptMod = { p:0, t:0 };
  card._counters = [];
  card._notes = '';
  fillChips('csTypesChips', card._extraTypes);
  fillChips('csEffectsChips', card._extraEffects);
  renderCountersList(card._counters);
  document.getElementById('csChosenType').value = '';
  document.getElementById('csPowMod').value = 0;
  document.getElementById('csTghMod').value = 0;
  document.getElementById('csNotes').value = '';

  persistCardExt(card);  // bake + write now
});


// save
document.getElementById('csSave').addEventListener('click', async ()=>{
  const card = getCardById(_csEditingId); if (!card) return;

  // 1) Scalars
  card._chosenType = (document.getElementById('csChosenType').value || '').trim();
  card._ptMod = {
    p: Number(document.getElementById('csPowMod').value || 0),
    t: Number(document.getElementById('csTghMod').value || 0),
  };
  card._notes = (document.getElementById('csNotes').value || '').trim();

  // 2) Types/Effects — also commit any pending chip text the user typed
  const tPend = (document.getElementById('csTypesInput').value || '').trim();
  if (tPend) { card._extraTypes = Array.isArray(card._extraTypes) ? card._extraTypes : []; card._extraTypes.push(tPend); }
  document.getElementById('csTypesInput').value = '';

  const ePend = (document.getElementById('csEffectsInput').value || '').trim();
  if (ePend) { card._extraEffects = Array.isArray(card._extraEffects) ? card._extraEffects : []; card._extraEffects.push(ePend); }
  document.getElementById('csEffectsInput').value = '';

  // 3) Counters — read existing rows AND include the “new counter” inputs if filled
  const rows = [...document.querySelectorAll('#csCounters .counterRow')];
  const freshCounters = [];

  for (const row of rows){
    const nameEl = row.querySelector('input[placeholder="name"]') || row.querySelector('input:not([type="number"])');
    const qtyEl  = row.querySelector('input[type="number"]');
    const name = (nameEl?.value || '').trim();
    const qty  = Number(qtyEl?.value || 0);
    if (name) freshCounters.push({ name, qty: Number.isFinite(qty) ? qty : 0 });
  }

  // also capture the single “new” row if user didn’t press ＋
  const newName = (document.getElementById('csNewCounterName')?.value || '').trim();
  const newQty  = Number(document.getElementById('csNewCounterQty')?.value || 0);
  if (newName) freshCounters.push({ name: newName, qty: Number.isFinite(newQty) ? newQty : 0 });

  card._counters = freshCounters;

  // 4) Normalize/dedupe arrays
  card._extraTypes   = Array.isArray(card._extraTypes)   ? Array.from(new Set(card._extraTypes.map(s => String(s).trim()).filter(Boolean))) : [];
  card._extraEffects = Array.isArray(card._extraEffects) ? Array.from(new Set(card._extraEffects.map(s => String(s).trim()).filter(Boolean))) : [];
  card._counters     = Array.isArray(card._counters)
    ? card._counters
        .map(c => ({ name: String(c.name||'').trim(), qty: Number(c.qty||0) }))
        .filter(c => c.name)
    : [];

  // 5) Persist + refresh UI
  await persistCardExt(card);
  updateCardDom(card);
  ensureOrUpdateCardBadge(card);
  closeCardSettings();
});





})();


// ---- DeckBridge: called by modules/deck.tools.js so actions affect live UI ----
window.DeckBridge = {
  moveOneFromDeckByName(name, dest){
    if (!state || !Array.isArray(state.deck)) return false;
    const idx = state.deck.findIndex(c => (c?.name || '').toLowerCase() === String(name).toLowerCase());
    if (idx < 0) { console.warn('[DeckBridge] not in deck:', name); return false; }

    const [card] = state.deck.splice(idx, 1);

    if (dest === 'hand'){
      state.hand.push(card);
      renderHand();
    } else if (dest === 'table'){
      const el = makeCardEl(card);
      worldEl.appendChild(el);
      enableDrag(el, card, {staged:false});
      if (!state.table.find(c => c.id === card.id)) state.table.push(card);
    } else if (dest === 'graveyard'){
      state.gy.unshift(card);
    } else if (dest === 'exile'){
      state.exile.unshift(card);
    } else {
      console.warn('[DeckBridge] unknown dest:', dest);
      return false;
    }

    // persist
    try { window.StorageAPI?.savePlayerStateDebounced?.(state.gameId, state.mySeat, state); }
    catch(e){ console.warn('[DeckBridge] save failed', e); }

    console.log(`[DeckBridge] ${name} -> ${dest}`);
    return true;
  }
};


/* Hand */
let handIndex=0, handSwipeEnabled=false;
function renderHand(){
  handTrack.innerHTML='';
  state.hand.forEach((card, i)=>{
    const slot=document.createElement('div'); slot.className='handCard'; slot.dataset.index=String(i);
    const cEl=document.createElement('div'); cEl.className='card'; cEl.style.position='relative'; cEl.style.width='var(--card-w)'; cEl.style.height='var(--card-h)'; cEl.dataset.id=card.id;

    normalizeCardImages(card);
    const inner=document.createElement('div'); inner.className='cardInner';
    inner.style.setProperty('--flip-rot', card.face === 'back' ? '180deg' : '0deg');
    inner.style.setProperty('--tap-rot',  card.tapped ? '90deg'   : '0deg');
    const front=document.createElement('div'); front.className='face front';
    const back=document.createElement('div'); back.className='face back';
    inner.appendChild(front); inner.appendChild(back); cEl.appendChild(inner);

    applyFaceImages(cEl, card);

    if(card.__ghost){ cEl.style.visibility='hidden'; }
    cEl.addEventListener('click',(ev)=>{ ev.stopPropagation(); handTrack.querySelectorAll('.card').forEach(n=>n.classList.remove('selected')); cEl.classList.add('selected'); buildTooltipFor(card, cEl); });
    cEl.addEventListener('touchstart',(e)=>{ const t=e.changedTouches[0]; cEl.__startForStage={x:t.clientX,y:t.clientY}; },{passive:true});
    cEl.addEventListener('touchend',(e)=>{ const t=e.changedTouches[0]; const st=cEl.__startForStage||null; if(!st) return; const dy=st.y - t.clientY; const isFocused=(i===handIndex); if(isFocused && dy>40){ stageFromHand(state.hand[handIndex]); } cEl.__startForStage=null; },{passive:true});

    slot.appendChild(cEl); handTrack.appendChild(slot);
  });
  const focused=state.hand[handIndex]; if(focused){ const slotCard=handTrack.querySelector(`.handCard[data-index="${handIndex}"] .card`); if(slotCard) buildTooltipFor(focused, slotCard); }
  layoutHandAt(handIndex);
}
function layoutHandAt(cx){
  const spacing=70; const cards=handTrack.querySelectorAll('.handCard');
  cards.forEach((slot)=>{ const i=Number(slot.dataset.index); const d=i-cx; const abs=Math.abs(d);
    let cls='handCard'; if(abs===0) cls+=' focus'; else if(abs===1||abs===2) cls+=' mid'; else cls+=' far';
    if(slot.className!==cls) slot.className=cls; slot.style.setProperty('--dx', `${d*spacing}px`); slot.style.setProperty('--rot', `${Math.max(-6, Math.min(6, d*1.5))}deg`); slot.style.zIndex=String(1000-abs);
  });
}
function enableHandSwipe(){
  if(handSwipeEnabled) return; handSwipeEnabled=true;
  let startX=null, startY=null, startIndex=0, lastAppliedIndex=0; const STEP_PX=35;
  handTrack.addEventListener('touchstart',(e)=>{ const t=e.changedTouches[0]; startX=t.clientX; startY=t.clientY; startIndex=handIndex; lastAppliedIndex=handIndex; document.getElementById('hand').classList.add('swiping'); layoutHandAt(handIndex); },{passive:true});
  handTrack.addEventListener('touchmove',(e)=>{ if(startX===null) return; const t=e.changedTouches[0]; const dx=t.clientX-startX; const dy=t.clientY-startY; if(Math.abs(dy)>Math.abs(dx)+10) return; e.preventDefault();
    const steps=Math.trunc((-dx)/STEP_PX); let target=startIndex+steps; target=Math.max(0, Math.min(state.hand.length-1, target));
    if(target!==lastAppliedIndex){ handIndex=target; lastAppliedIndex=target; layoutHandAt(target); const focused=state.hand[handIndex]; const slotCard=handTrack.querySelector(`.handCard[data-index="${handIndex}"] .card`); if(focused && slotCard){ buildTooltipFor(focused, slotCard); } }
  },{passive:false});
  handTrack.addEventListener('touchend',()=>{ startX=null; startY=null; },{passive:true});
  handTrack.addEventListener('touchcancel',()=>{ startX=null; startY=null; },{passive:true});
}
function stageFromHand(card){
  // If mulligan prompt is up and user starts playing, cancel it
  if (state._mulliganPending && !state._mulliganAutoDrawing){
    hideMulliganOverlay();
  }

  const hi=state.hand.findIndex(c=>c.id===card.id);
  if(hi>-1){ state.hand.splice(hi,1); handIndex=Math.max(0, Math.min(handIndex, state.hand.length-1)); renderHand(); }


  const cx=window.innerWidth/2, cy=window.innerHeight/2; const centerW=clientToWorld(cx,cy);
  const cardW=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))||223;
  const cardH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))||310;
  const staged={ ...card, x:centerW.x - cardW/2, y:centerW.y - cardH/2 };
  const el=makeCardEl(staged); worldEl.appendChild(el); enableDrag(el, staged, {staged:true});
  handTrack.querySelectorAll('.card').forEach(n=>n.classList.remove('selected')); selectCard(staged.id, el);
}

window.stageFromHand = stageFromHand;  // expose swipe-up behavior

async function returnToHand(card, el){
  try { if (el && el.remove) el.remove(); } catch(_) {}

  // Remove any existing copy of this id from table state
  const tbl = Array.isArray(state.table) ? state.table : (state.table = []);
  const idx = tbl.findIndex(c => String(c.id) === String(card.id));
  if (idx > -1) tbl.splice(idx, 1);

  // Append to end of hand
  const hand = Array.isArray(state.hand) ? state.hand : (state.hand = []);
  // If this card id already exists in hand, remove old one first
  const hIdx = hand.findIndex(c => String(c.id) === String(card.id));
  if (hIdx > -1) hand.splice(hIdx, 1);
  hand.push(card);

  // Re-render hand immediately and persist
  renderHand();
  try { window.StorageAPI?.savePlayerStateDebounced?.(state.gameId, state.mySeat, state); } catch(_){}
}
// (optional but useful) make your hand renderer callable from modules
window.__rerenderHand = renderHand;

function renderOpponentHand(count){
  handTrack.innerHTML = '';
  for (let i = 0; i < count; i++){
    const slot = document.createElement('div');
    slot.className = 'handCard';
    slot.dataset.index = String(i);

    const cEl = document.createElement('div');
    cEl.className = 'card';
    cEl.style.position='relative';
    cEl.style.width='var(--card-w)';
    cEl.style.height='var(--card-h)';

    const inner = document.createElement('div');
    inner.className = 'cardInner';
    inner.style.setProperty('--flip-rot', '180deg'); // show the back face

    const front = document.createElement('div'); front.className='face front';
    const back  = document.createElement('div');  back.className='face back';
    back.style.backgroundImage = `url("${CARD_BACK_URL}")`; // ⟵ add this line

    inner.appendChild(front);
    inner.appendChild(back);
    cEl.appendChild(inner);
    slot.appendChild(cEl);
    handTrack.appendChild(slot);
  }
  layoutHandAt(Math.min(handIndex, Math.max(0, count - 1)));
}


async function hydrateOpponentIntoView(doc){
  worldEl.querySelectorAll('.card').forEach(n=>n.remove());

  state.deck   = doc.Deck  ?? doc.deck  ?? [];
  state.hand   = []; // hidden
  state.table  = doc.Table ?? doc.table ?? [];
  state.gy     = doc.Graveyard ?? doc.gy ?? doc.graveyard ?? [];
  state.exile  = doc.Exile ?? doc.exile ?? [];
  state.tableCommander = doc.Commander ?? doc.tableCommander ?? doc.commander ?? null;

  [ ...state.table, state.tableCommander ].filter(Boolean).forEach(applyExtToRuntimeFields);

  if (state.tableCommander){
    const el = makeCardEl(state.tableCommander);
    worldEl.appendChild(el);
  }
  state.table.forEach(c=>{
    const el = makeCardEl(c);
    worldEl.appendChild(el);
  });

  // Hand backs only
  renderOpponentHand((doc.Hand ?? doc.hand ?? []).length);

  state._oppSnapshot = {
    Table: (state.table || []).map(c => ({...c})),
    Commander: state.tableCommander ? {...state.tableCommander} : null,
    Graveyard: (state.gy || []).slice(),
    Exile: (state.exile || []).slice(),
    HandCount: (doc.Hand ?? doc.hand ?? []).length
  };
}


function idMap(arr){ const m=new Map(); (arr||[]).forEach(c=>m.set(c.id, c)); return m; }

function patchOpponentView(nextDoc){
  // --- normalize once (supports both naming styles) ---
  const nd = {
    Table:     nextDoc.Table     ?? nextDoc.table     ?? [],
    Commander: nextDoc.Commander ?? nextDoc.tableCommander ?? null,
    Graveyard: nextDoc.Graveyard ?? nextDoc.gy        ?? nextDoc.graveyard ?? [],
    Exile:     nextDoc.Exile     ?? nextDoc.exile     ?? [],
    Hand:      nextDoc.Hand      ?? nextDoc.hand      ?? []
  };

  // Zones + hand count
  state.gy    = nd.Graveyard;
  state.exile = nd.Exile;
  const nextHandCount = nd.Hand.length;
  if (state._oppSnapshot.HandCount !== nextHandCount){
    renderOpponentHand(nextHandCount);
  }

  // Commander
  const prevCom = state._oppSnapshot.Commander;
  const nextCom = nd.Commander;
  if (!!prevCom !== !!nextCom || (prevCom && nextCom && prevCom.id !== nextCom.id)){
    // replace commander node
    if (prevCom){
      const oldEl = worldEl.querySelector(`.card[data-id="${prevCom.id}"]`);
      if (oldEl) oldEl.remove();
    }
    if (nextCom){
      const el = makeCardEl(nextCom);
      worldEl.appendChild(el);
    }
  } else if (prevCom && nextCom){
    // same id — animate changes
    const el = worldEl.querySelector(`.card[data-id="${nextCom.id}"]`);
    if (el){
      const px = parseFloat(el.style.left)||0, py = parseFloat(el.style.top)||0;
      if (px !== (nextCom.x||0) || py !== (nextCom.y||0)){
        el.style.left = (nextCom.x || 0) + 'px';
        el.style.top  = (nextCom.y || 0) + 'px';
      }
      const same = el.__cardRef || {};
      same.tapped = !!nextCom.tapped;
      same.face   = nextCom.face || 'front';
      updateCardDom(same);
      el.__cardRef = nextCom;
    }
  }

  // Table diff
  const prevMap = idMap(state._oppSnapshot.Table || []);
  const nextMap = idMap(nd.Table || []);

  // remove
  for (const [id, prev] of prevMap){
    if (!nextMap.has(id)){
      const el = worldEl.querySelector(`.card[data-id="${id}"]`);
      if (el) el.remove();
    }
  }
  // add/update
  for (const [id, next] of nextMap){
    let el = worldEl.querySelector(`.card[data-id="${id}"]`);
    if (!el){
      el = makeCardEl(next);
      worldEl.appendChild(el);
    }
    // movement
    const px = parseFloat(el.style.left)||0, py = parseFloat(el.style.top)||0;
    if (px !== (next.x||0) || py !== (next.y||0)){
      el.style.left = (next.x || 0) + 'px';
      el.style.top  = (next.y || 0) + 'px';
    }
    // tap/flip
    const same = el.__cardRef || {};
    same.tapped = !!next.tapped;
    same.face   = next.face || 'front';
    updateCardDom(same);
    el.__cardRef = next;
  }

  // refresh snapshot for next tick
  state._oppSnapshot = {
    Table: nd.Table.map(c=>({...c})),
    Commander: nextCom ? {...nextCom} : null,
    Graveyard: nd.Graveyard.slice(),
    Exile: nd.Exile.slice(),
    HandCount: nd.Hand.length
  };

  // keep local state aligned so tooltips/select/badges work in RO mode too
  state.table = nd.Table.map(c => ({...c}));
  state.table.forEach(applyExtToRuntimeFields);
  state.tableCommander = nextCom ? {...nextCom} : null;
  if (state.tableCommander) applyExtToRuntimeFields(state.tableCommander);

  // ensure badges (counters/notes) show on opponent view
  [ ...nd.Table, nextCom ].filter(Boolean).forEach(ensureOrUpdateCardBadge);
}


function startViewPoller(){
  if (state.viewPoller) clearInterval(state.viewPoller);
  state.viewPoller = setInterval(async ()=>{
    if (!state.viewReadOnly || !state.gameId) return;
    const doc = await window.window.StorageAPI.loadPlayerState(state.gameId, state.viewSeat);
    if (!doc) return;
    patchOpponentView(doc);
  }, 100);
}


/* Drag/Drop */
function enableDrag(el, card, opts={}){
  if (state.viewReadOnly) return;
  let dragging=false, offX=0, offY=0;
  el.style.touchAction='none';
  el.addEventListener('pointerdown',(e)=>{ dragging=true; draggingCard=true; el.setPointerCapture?.(e.pointerId); const wp=clientToWorld(e.clientX,e.clientY); const left=parseFloat(el.style.left)||0; const top=parseFloat(el.style.top)||0; offX=wp.x-left; offY=wp.y-top; if(state.selectedCardId===card.id) positionActions(el); });
  // ==== live stack preview while dragging
const hint = findBestOverlapDir(el);
if (hint) {
  _stackPreview = { targetId: hint.el.dataset.id, dir: hint.dir };
  showStackArrow(hint.el, hint.dir);
} else {
  hideStackArrow();
}

  el.addEventListener('pointermove',(e)=>{
  if(!dragging) return;
  const wp=clientToWorld(e.clientX,e.clientY);
  el.style.left=(wp.x-offX)+'px';
  el.style.top =(wp.y-offY)+'px';

  if(state.selectedCardId===card.id){
    positionActions(el);
    if(tooltipEl) positionTooltip(el);
  }

positionCardBadgeFor(card); 

  // ---- STACK PREVIEW WHILE DRAGGING ----
  const hint = findBestOverlapDir(el);
  if (hint){
    _stackPreview = { targetId: hint.el.dataset.id, dir: hint.dir };
    showStackArrow(hint.el, hint.dir);
  } else {
    hideStackArrow();
  }
},{passive:false});

  async function finishDrag(){
  // ==== drop into a stack if a preview is active
if (_stackPreview && _stackPreview.targetId) {
  const targetEl = getCardElById(_stackPreview.targetId);
  const targetCard = getCardById(_stackPreview.targetId) || (targetEl && targetEl.__cardRef);
  const dir = _stackPreview.dir;
  hideStackArrow();

  if (targetCard && dir) {
    await applyStackDrop(card, el, targetCard, dir);
    // if this was a staged-from-hand drop, make sure we don’t re-add twice
    opts.staged = false;
        // keep base on top after stacking
    if (targetEl) selectCard(targetCard.id, targetEl);

    return; // stacked → stop normal zone handling
  }
}

    if(!dragging) return; dragging=false; draggingCard=false;
    if (hitHand(el)){ await returnToHand(card, el); return; }
    const hits=zoneHit(el);
    if(hits.length){
      const z=hits[0].id;
      if(z==='graveyard'){ await moveToZone(card,'graveyard',el); return; }
      if(z==='exileZone'){ await moveToZone(card,'exile',el); return; }
      if(z==='cmdZone'){ await snapToCommander(card,el); return; }
      if(z==='deckZone'){ showDeckChoice(card, el, opts.staged === true); return; }

    }
    if(opts.staged){ await writeTableAdd(card); opts.staged=false; selectCard(card.id, el); }
    else{ await writeTableMove(card, el); }
  }
  el.addEventListener('pointerup',finishDrag); el.addEventListener('pointercancel',finishDrag);
}
function hitHand(el){
  const handEl=document.getElementById('hand'); const r=el.getBoundingClientRect(); const hr=handEl.getBoundingClientRect();
  const minOverlapY=Math.min(r.bottom,hr.bottom)-Math.max(r.top,hr.top); return minOverlapY > (r.height * 0.25);
}

/* Zones */
async function moveToZone(card, zone, el){ el.remove(); clearSelection(); await removeFromTable(card); await appendToZone(card, zone); }
async function snapToCommander(card, el){
  const zr=cmdZone.getBoundingClientRect(); const tl=clientToWorld(zr.left,zr.top); const inset=6;
  el.style.left=(tl.x+inset)+'px'; el.style.top=(tl.y+inset)+'px'; card.x=tl.x+inset; card.y=tl.y+inset; await writeCommander(card); positionActions(el);
}
function showDeckChoice(card, el, wasStaged){
  if (tooltipEl) hideTooltip();                         // ← add this line
  const zr = deckZone.getBoundingClientRect();
  deckChoice.style.left = (zr.left + zr.width/2) + 'px';
  deckChoice.style.top  = (zr.top) + 'px';
  deckChoice.style.display = 'flex';

  deckChoice.onclick = async (ev)=>{
    const btn = ev.target.closest('.pill'); 
    if (!btn) return;

    const choice = btn.dataset.choice;
    deckChoice.style.display = 'none';

    // === CANCEL: leave the card on the table where it is ===
    if (choice === 'cancel'){
      // If this drag came from the hand and was not yet persisted,
      // add it to the table now; otherwise persist its new x/y.
      try{
        if (wasStaged) {
          await writeTableAdd(card); // creates the table entry
        } else {
          await writeTableMove(card, el); // updates x/y
        }
      }catch(e){}
      // restore selection/handles and bail – NO removal, NO deck ops
      selectCard(card.id, el);
      positionActions(el);
      return;
    }

    // For non-cancel choices, proceed with the original behavior:
    // remove from table, then perform the chosen deck operation
    el.remove();
    clearSelection();
    await removeFromTable(card);

    if (choice === 'top'){
      await deckPutTop(card);
    } else if (choice === 'bottom'){
      await deckPutBottom(card);
    } else if (choice === 'shuffle'){
      await deckPutTop(card);
      await deckShuffle();
    }
  };
}


/* Overlays */
gyZone.addEventListener('click', ()=> openZoneOverlay('graveyard', state.gy));
exileZone.addEventListener('click', ()=> openZoneOverlay('exile', state.exile));
document.getElementById('overlayClose').addEventListener('click', ()=>{ zoneOverlay.style.display='none'; clearSelection(); });
function openZoneOverlay(kind, arr){
  overlayTitle.textContent = (kind==='graveyard'?'Graveyard':'Exile');
  overlayGrid.innerHTML='';
  arr.forEach(card=>{
    const t=document.createElement('div'); t.className='thumb';
    if(card.frontImg) t.style.backgroundImage=`url("${card.frontImg}")`;
    t.title = card.name || '';

    if (!state.viewReadOnly){
      // original interactive behavior
      t.addEventListener('click', async ()=>{
        await removeFromZone(card, kind);
        const el = makeCardEl(card); worldEl.appendChild(el); enableDrag(el, card, {staged:false});
        await writeTableAdd(card);
        zoneOverlay.style.display='none';
      });
    } else {
      // read-only: clicking just highlights for tooltip
      t.addEventListener('click', ()=>{
        hideTooltip();
        const ghost = makeCardEl(card);
        ghost.style.left = '0px'; ghost.style.top = '0px'; // anchor not used
        buildTooltipFor(card, ghost);
      });
    }
    overlayGrid.appendChild(t);
  });
  zoneOverlay.style.display='block';
}


/* Hydrate */
async function hydrateFromDoc(data){
  // Clear DOM
  worldEl.querySelectorAll('.card').forEach(n=>n.remove());

  // Accept BOTH shapes: Deck/Hand/Table... and deck/hand/table...
  const pick = (obj, ...keys) => {
    for (const k of keys) if (obj && obj[k] != null) return obj[k];
    return undefined;
  };

  state.deck  = pick(data, 'Deck','deck') || [];
  state.hand  = pick(data, 'Hand','hand') || [];
  state.table = pick(data, 'Table','table') || [];
  state.gy    = pick(data, 'Graveyard','gy','graveyard') || [];
  state.exile = pick(data, 'Exile','exile') || [];
  state.tableCommander = pick(data, 'Commander','tableCommander','commander') || null;

  /* inflate persisted ext into runtime _… fields */
  [...state.deck, ...state.hand, ...state.table, ...state.gy, ...state.exile].forEach(c=>{
    applyExtToRuntimeFields(c);
    normalizeCardImages(c);
  });
  if (state.tableCommander){
    applyExtToRuntimeFields(state.tableCommander);
    normalizeCardImages(state.tableCommander);
  }

  // Spawn on table
  state.table.forEach(c=>{
    const el = makeCardEl(c);
    worldEl.appendChild(el);
    enableDrag(el, c, { staged:false });
  });
  if (state.tableCommander){
    const el = makeCardEl(state.tableCommander);
    worldEl.appendChild(el);
    enableDrag(el, state.tableCommander, { staged:false });
  }
  [state.tableCommander, ...state.table].filter(Boolean).forEach(ensureOrUpdateCardBadge);

  renderHand();
}


function isEmptyDoc(d){
  if (!d) return true;
  const deck  = d.Deck  ?? d.deck  ?? [];
  const hand  = d.Hand  ?? d.hand  ?? [];
  const table = d.Table ?? d.table ?? [];
  const gy    = d.Graveyard ?? d.gy ?? d.graveyard ?? [];
  const exile = d.Exile ?? d.exile ?? [];
  const commander = d.Commander ?? d.tableCommander ?? d.commander ?? null;
  return !(deck.length || hand.length || table.length || gy.length || exile.length || commander);
}

function closeDrawerNow(){
  drawerWrap.classList.add('collapsed');
  drawerWrap.classList.remove('expanded');
  zoomWrapEl.style.display = 'flex';
}


async function loadGameIntoUI(gameId) {
 state.gameId = gameId;
  const data = await window.window.StorageAPI.loadPlayerState(state.gameId, state.mySeat);
  if (data) {
    await hydrateFromDoc(data);
    if (!isEmptyDoc(data)) closeDrawerNow();   // ← add this line
  } else {
    // nothing in Firestore → keep everything empty locally
    worldEl.querySelectorAll('.card').forEach(n => n.remove());
    state.deck = []; state.hand = []; state.table = [];
    state.gy = []; state.exile = []; state.tableCommander = null;
    renderHand();
  }
}


/* Drawer actions */
document.getElementById('loadBtn').addEventListener('click', async ()=>{
  const btn = document.getElementById('loadBtn');
  btn.disabled = true;
  showBusy('Loading deck…');
  try{
    const txt = document.getElementById('deckIn').value;
    const { deckCards, commanderCard } = await buildDeckFromText(txt);
    await writeDeckForPlayer(deckCards); await ensureTurn0();
    state.deck=[...deckCards]; state.hand=[]; state.table=[]; state.gy=[]; state.exile=[]; renderHand();
    if (commanderCard){
      await writeCommander(commanderCard);
      const el = makeCardEl({...commanderCard, x: cmdZone.offsetLeft+8, y: cmdZone.offsetTop+8});
      worldEl.appendChild(el); enableDrag(el, commanderCard, {staged:false});
    }
    closeDrawerNow();
  }catch(err){
    console.error(err); alert('Failed to load deck (see console).');
  }finally{
    hideBusy();
    btn.disabled = false;
  }
});

// --- tiny loading overlay ---
let __busy;
function showBusy(msg='Loading…'){
  if (!__busy){
    __busy = document.createElement('div');
    __busy.id = 'busyOverlay';
    __busy.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(8,12,20,.72);z-index:99999';
    __busy.innerHTML = `
      <div style="display:flex;gap:10px;align-items:center;background:#0b1220;border:1px solid #24324a;border-radius:12px;padding:14px 18px;font-weight:800">
        <span style="width:18px;height:18px;border:3px solid #2c3e5a;border-top-color:#8fb3ff;border-radius:50%;animation:spin .9s linear infinite"></span>
        <span id="busyTxt"></span>
      </div>`;
    const kf = document.createElement('style');
    kf.textContent = '@keyframes spin{to{transform:rotate(360deg)}}';
    document.head.appendChild(kf);
  }
  __busy.querySelector('#busyTxt').textContent = msg;
  document.body.appendChild(__busy);
}
function hideBusy(){ __busy?.remove(); }



/* Draw animation */
function animateDrawIntoIndex(imgUrl, index){
  const startW=elementCenterWorld(deckZone), endW=getHandSlotCenterWorld(index);
  const cardW=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-w'));
  const cardH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-h'));
  const ghost=document.createElement('div'); ghost.className='card';
  ghost.style.left=`${startW.x - cardW/2}px`; ghost.style.top=`${startW.y - cardH/2}px`;
  const inv=1/state.zoom; ghost.style.transform=`scale(${0.6*inv})`; ghost.style.transition='transform .28s ease, left .28s ease, top .28s ease';
  ghost.style.background='#000 center/cover no-repeat'; ghost.style.backgroundImage=`url("${imgUrl || CARD_BACK_URL}")`;
  worldEl.appendChild(ghost);
  requestAnimationFrame(()=>{ ghost.style.left = `${endW.x - cardW/2}px`; ghost.style.top  = `${endW.y - cardH/2}px`; ghost.style.transform = `scale(${0.9*inv})`; });
  setTimeout(()=>ghost.remove(),320);
}
async function draw(){
  if (state.viewReadOnly) return;

  const opening = (state.turn === 0);
  const count   = opening ? 7 : 1;

  if (count === 1){
    const drawn = state.deck.splice(0,1);
    const card  = drawn[0];
    if (!card) return;

    const insertAt = Math.min(handIndex+1, state.hand.length);
    state.hand.splice(insertAt,0,{__ghost:true,id:'ghost_'+Math.random().toString(36).slice(2)});
    renderHand();
    animateDrawIntoIndex(card.frontImg || CARD_BACK_URL, insertAt);
    setTimeout(()=>{
      const gi = state.hand.findIndex(c=>c&&c.__ghost);
      if (gi !== -1){
        state.hand.splice(gi,1,card);
        handIndex = gi;
        renderHand();
      }
    },330);

    await writeDrawToServer(drawn);

    // If the mulligan prompt was pending and this draw was user-initiated,
    // drawing a card *cancels* the mulligan.
    if (state._mulliganPending && !state._mulliganAutoDrawing){
      hideMulliganOverlay();
    }

    if (state.turn === 0) state.turn = 1;
    return;
  }

  // Multi-draw (opening 7)
  const drawn = state.deck.splice(0, count);
  for (let k = 0; k < drawn.length; k++){
    const card = drawn[k];
    const insertAt = Math.min(handIndex+1, state.hand.length);
    state.hand.splice(insertAt,0,{__ghost:true,id:'ghost_'+Math.random().toString(36).slice(2)});
    renderHand();
    animateDrawIntoIndex(card.frontImg || CARD_BACK_URL, insertAt);
    await new Promise(r=>setTimeout(r,120));
    const gi = state.hand.findIndex(c=>c&&c.__ghost);
    if (gi !== -1){
      state.hand.splice(gi,1,card);
      handIndex = gi;
      renderHand();
    }
  }
  await writeDrawToServer(drawn);

  if (state.turn === 0) state.turn = 1;

  // Show Mulligan only the first time an opening 7 is completed via draw()
  if (opening && !state._hasShownOpeningMull && !state._mulliganAutoDrawing){
    state._hasShownOpeningMull = true;
    showMulliganOverlay();
  }
}

const mullEl   = document.getElementById('mulliganOverlay');
const mullYes  = document.getElementById('mullYesBtn');
const mullNo   = document.getElementById('mullNoBtn');

function showMulliganOverlay(){
  if (state.viewReadOnly) return; // never show while spectating
  mullEl.style.display = 'block';
  state._mulliganPending = true;
}
function hideMulliganOverlay(){
  mullEl.style.display = 'none';
  state._mulliganPending = false;
}

async function doFriendlyMulligan(){
  // Return all hand cards to top of deck, shuffle, draw 7 again, and show overlay again
  const returning = state.hand.splice(0);
  // Put returned cards back on top to keep it deterministic before shuffle
  state.deck = returning.concat(state.deck);
  renderHand();
  try { window.StorageAPI?.savePlayerStateDebounced?.(state.gameId, state.mySeat, state); } catch(_){}

  // Shuffle + draw 7 *programmatically*
  await deckShuffle();

  // Suppress the “drawing hides overlay” rule during auto-draw
  state._mulliganAutoDrawing = true;

  // Force opening draw path to fire
  const prevTurn = state.turn;
  state.turn = 0;
  await draw();               // will draw 7 because turn===0
  state.turn = 1;             // opening complete again

  state._mulliganAutoDrawing = false;

  // Re-prompt after mulligan draw
  showMulliganOverlay();
}

mullYes?.addEventListener('click', async ()=>{
  if (!state.gameId) { hideMulliganOverlay(); return; }
  await doFriendlyMulligan();
});

mullNo?.addEventListener('click', ()=>{
  hideMulliganOverlay();
});


/* Parse + Scryfall */
function cleanCardName(raw){
  return (raw || '')
    .replace(/^\s*\d+x?\s+/i, '')   // strip leading qty: "1 " or "2x "
    .replace(/\s*\(.*?\)\s*$/, '')  // drop trailing "(set/notes)" if any
    .replace(/\s*\[.*?\]\s*$/, '')  // drop trailing "[set/notes]" if any
    .trim();
}

function parseDeckTextWithCommander(txt){
  const lines = txt.split(/\r?\n/).map(s=>s.trim());

  // find last non-empty line
  let lastNonEmptyIdx = -1;
  for (let i = lines.length - 1; i >= 0; i--){
    if (lines[i]) { lastNonEmptyIdx = i; break; }
  }

  // commander (cleaned!)
  let commanderName = lastNonEmptyIdx >= 0 ? cleanCardName(lines[lastNonEmptyIdx]) : null;

  // sideboard header
  const sbIdx = lines.findIndex(l => /^sideboard\s*:?\s*$/i.test(l));
  const stop = sbIdx === -1 ? (lastNonEmptyIdx >= 0 ? lastNonEmptyIdx : lines.length) : sbIdx;

  const deckNames = [];
  for (let i = 0; i < stop; i++){
    const line = lines[i].trim();
    if (!line) continue;
    const m = line.match(/^(\d+)\s+(.+)$/);
    if (m){
      const qty = Math.max(1, parseInt(m[1],10));
      const name = cleanCardName(m[2]);
      for (let k=0;k<qty;k++) deckNames.push(name);
    } else {
      deckNames.push(cleanCardName(line));
    }
  }
  return { deckNames, commanderName };
}

async function scryfallFetchUnique(namesUnique){
  const chunks=[]; for(let i=0;i<namesUnique.length;i+=75) chunks.push(namesUnique.slice(i,i+75));
  const wantByNorm=new Map(); const have=new Map(); const norm=s=>(s||'').trim().toLowerCase(); namesUnique.forEach(n=>wantByNorm.set(norm(n), n));

  function mapFacesFromCard(c){
    // Use per-face image_uris ONLY for DFCs; parent-level image_uris is for single-faced.
    const faces = (Array.isArray(c.card_faces) && c.card_faces.length)
      ? c.card_faces.map(f=>({
          name: f.name || c.name || '',
          type_line: f.type_line || c.type_line || '',
          oracle_text: f.oracle_text || '',
          power: f.power || '',
          toughness: f.toughness || '',
          mana_cost: f.mana_cost || '',
          image: (f.image_uris?.normal || f.image_uris?.large || f.image_uris?.png || '')
        }))
      : [{
          name: c.name || '',
          type_line: c.type_line || '',
          oracle_text: c.oracle_text || '',
          power: c.power || '',
          toughness: c.toughness || '',
          mana_cost: c.mana_cost || '',
          image: (c.image_uris?.normal || c.image_uris?.large || c.image_uris?.png || '')
        }];
    return faces;
  }

  function cleanCardName(raw){
    return (raw || '')
      .replace(/^\s*\d+x?\s+/i, '')
      .replace(/\s*\(.*?\)\s*$/, '')
      .replace(/\s*\[.*?\]\s*$/, '')
      .trim();
  }

  async function fuzzy(name){
    try{
      const cleaned = cleanCardName(name);
      // Try the cleaned name first
      let res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cleaned)}`);
      if (!res.ok && cleaned.includes('//')) {
        // If it’s a DFC-style string, try just the front face too
        const frontOnly = cleaned.split('//')[0].trim();
        res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(frontOnly)}`);
      }
      if (!res.ok) return null;
      const c = await res.json();
      const faces = mapFacesFromCard(c);
      return {
        scry_id: c.id,
        name: c.name,
        type_line: c.type_line || '',
        oracle_text: c.oracle_text || (c.card_faces?.map(f=>f.oracle_text).filter(Boolean).join('\n')) || '',
        power: c.power || c.card_faces?.[0]?.power || '',
        toughness: c.toughness || c.card_faces?.[0]?.toughness || '',
        keywords: c.keywords || [],
        mana_cost: c.mana_cost || c.card_faces?.[0]?.mana_cost || '',
        faces,
        layout: c.layout || ''
      };
    }catch{ return null; }
  }

  for(const chunk of chunks){
    try{
      const body={ identifiers: chunk.map(name=>({name})) };
      const res=await fetch('https://api.scryfall.com/cards/collection',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
      if(!res.ok){ console.error('Scryfall error', res.status); continue; }
      const data=await res.json();
      for(const c of (data.data||[])){
        const faces=mapFacesFromCard(c);
        const requested=wantByNorm.get(norm(c.name)) || c.name;
        have.set(requested,{ scry_id:c.id, name:c.name, type_line:c.type_line||'', oracle_text:c.oracle_text || (c.card_faces?.map(f=>f.oracle_text).filter(Boolean).join('\n')) || '', power:c.power || c.card_faces?.[0]?.power || '', toughness:c.toughness || c.card_faces?.[0]?.toughness || '', keywords:c.keywords||[], mana_cost:c.mana_cost || c.card_faces?.[0]?.mana_cost || '', faces, layout:c.layout||'' });
      }
    }catch(err){ console.error('Scryfall batch error:', err); }
  }

  const misses=namesUnique.filter(n=>!have.has(n));
  for(const name of misses){
    const f=await fuzzy(name);
    if(f) have.set(name, f);
    else have.set(name, { scry_id:'missing_'+name, name, type_line:'', oracle_text:'', power:'', toughness:'', keywords:[], faces:[{name, image:''}], layout:'' });
  }
  return have;
}

function applyExtToRuntimeFields(card){
  if (!card || !card.ext) return;
  card._extraTypes   = Array.isArray(card.ext.types)   ? [...card.ext.types]   : [];
  card._extraEffects = Array.isArray(card.ext.effects) ? [...card.ext.effects] : [];
  card._chosenType   = card.ext.chosenType || '';
  const pm = card.ext.ptMod || { p:0, t:0 };
  card._ptMod        = { p: Number(pm.p||0), t: Number(pm.t||0) };
  card._counters     = Array.isArray(card.ext.counters)
    ? card.ext.counters.map(c => ({ name: String(c.name||'').trim(), qty: Number(c.qty||0) }))
    : [];
  card._notes        = card.ext.notes || '';
}
function bakeRuntimeFieldsToExt(card){
  if (!card) return;
  card.ext = {
    types:   Array.isArray(card._extraTypes)   ? [...card._extraTypes]   : [],
    effects: Array.isArray(card._extraEffects) ? [...card._extraEffects] : [],
    chosenType: card._chosenType || '',
    ptMod: { p: Number(card._ptMod?.p || 0), t: Number(card._ptMod?.t || 0) },
    counters: Array.isArray(card._counters)
      ? card._counters.map(c => ({ name: String(c.name||'').trim(), qty: Number(c.qty||0) }))
      : [],
    notes: card._notes || ''
  };
}

/* NEW: force-save helper for the cog panel */
async function persistCardExt(card){
  if (!state.gameId) return;
  bakeRuntimeFieldsToExt(card);
  const face = (card._faces && card._faces.length > 1)
    ? (card.face === 'back' ? card._faces[1] : card._faces[0])
    : (card._faces?.[0] || {});
  const baseP = face.power ?? card.power ?? card._scry?.power ?? card._scry?.faces?.[0]?.power ?? '';
  const baseT = face.toughness ?? card.toughness ?? card._scry?.toughness ?? card._scry?.faces?.[0]?.toughness ?? '';
  if (baseP !== '' && baseT !== '') {
    const pm = card._ptMod || { p:0, t:0 };
    const p = Number(baseP) + Number(pm.p || 0);
    const t = Number(baseT) + Number(pm.t || 0);
    if (isFinite(p) && isFinite(t)) {
      card.pt = `${p}/${t}`;             // live snapshot for combat.ui.js
      card.ext = card.ext || {};
      card.ext.pt = card.pt;             // optional: mirror under ext.pt
    }
  }
  try{
    if (window.StorageAPI?.savePlayerState) {
      await window.StorageAPI.savePlayerState(state.gameId, state.mySeat, state);
    } else if (window.StorageAPI?.savePlayerStateDebounced) {
      window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state);
      if (window.StorageAPI.flush) { await window.StorageAPI.flush(); }
      else { await new Promise(r=>setTimeout(r, 200)); }
    }
  }catch(_){}
}



function makeCopyFromScry(rec){
  const uid=`${rec.scry_id}_${crypto.getRandomValues(new Uint32Array(1))[0].toString(16)}_${Math.random().toString(36).slice(2,7)}`;
  const faces=rec.faces||[]; const frontFace=faces[0]||{}; const backFace=faces[1]||null;

  return {
  id: uid,
  name: rec.name,
  frontImg: frontFace.image || '',
  backImg:  (faces.length>1 ? (backFace?.image || '') : ''),
  face: 'front',
  tapped: false,
  pt: (frontFace.power && frontFace.toughness) ? `${frontFace.power}/${frontFace.toughness}` : '',
  _scry: rec,
  _faces: faces,
  ext: { types:[], effects:[], chosenType:'', ptMod:{p:0,t:0}, counters:[], notes:'' }
};

}

function computePT(card){
  const face = getActiveFace(card) || {};
  const baseP =
    face.power ?? card.power ?? card._scry?.power ?? card._scry?.faces?.[0]?.power ?? '';
  const baseT =
    face.toughness ?? card.toughness ?? card._scry?.toughness ?? card._scry?.faces?.[0]?.toughness ?? '';

  if (baseP === '' || baseT === '') return '';

  const pm = card._ptMod || {p:0, t:0};
  const p = Number(baseP) + Number(pm.p || 0);
  const t = Number(baseT) + Number(pm.t || 0);
  // If base values are non-numeric (e.g., "*"), just show raw
  if (!isFinite(p) || !isFinite(t)) return `${baseP}/${baseT}${(pm.p||pm.t) ? ` (${pm.p>=0?'+':''}${pm.p || 0}/${pm.t>=0?'+':''}${pm.t || 0})` : ''}`;
  return `${p}/${t}`;
}



function getActiveFace(card){
  if (card?._faces?.length > 1) return (card.face==='back') ? card._faces[1] : card._faces[0];
  return card?._faces?.[0] || null;
}
async function buildDeckFromText(txt,{includeCommander=true}={}){
  const { deckNames, commanderName } = parseDeckTextWithCommander(txt);
  const needLookup=[...new Set([ ...deckNames, ...(includeCommander && commanderName ? [commanderName] : []) ])];
  const scryMap=await scryfallFetchUnique(needLookup);

  const deckCards=deckNames.map(name=>{
    let rec=scryMap.get(name); if(!rec){ const key=name.toLowerCase(); for(const [k,v] of scryMap) if(k.toLowerCase()===key){ rec=v; break; } }
    if(!rec){ rec={ scry_id:'missing_'+name, name, faces:[{name,image:''}] }; }
    return makeCopyFromScry(rec);
  });

  let commanderCard=null;
  if(includeCommander && commanderName){
    let rec=scryMap.get(commanderName); if(!rec){ const key=commanderName.toLowerCase(); for(const [k,v] of scryMap) if(k.toLowerCase()===key){ rec=v; break; } }
    if(!rec){ rec={ scry_id:'missing_'+commanderName, name:commanderName, faces:[{name:commanderName,image:''}] }; }
    commanderCard=makeCopyFromScry(rec);
  }

  deckCards.concat(commanderCard||[]).forEach(c=>{ if(c.frontImg){ new Image().src=c.frontImg; } if(c.backImg){ new Image().src=c.backImg; } });
  return { deckCards, commanderCard };
}

/* Stubs to wire to storage */
function requireGameSelected(){ if(!state.gameId){ alert('Select a Game (Game 1/2/3).'); return false; } return true; }
async function writeDeckForPlayer(cards){ if(!state.gameId) return alert('Pick Game 1/2/3 first.'); state.deck=cards.slice(); window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state); }
async function ensureTurn0(){ state.turn=0; }
async function writeTableAdd(card){
  if(!state.gameId) return alert('Pick Game 1/2/3 first.');
  const hi=state.hand.findIndex(c=>c.id===card.id);
  if(hi>-1){ state.hand.splice(hi,1); renderHand(); }
  if(!state.table.find(c=>c.id===card.id)) state.table.push(card);
  bakeRuntimeFieldsToExt(card);
  window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state);
}

async function writeTableMove(card, el){
  if(!state.gameId) return;
  card.x=parseFloat(el.style.left)||card.x;
  card.y=parseFloat(el.style.top)||card.y;
  bakeRuntimeFieldsToExt(card);
  window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state);
}

async function removeFromTable(card){ if(!state.gameId) return; const idx=state.table.findIndex(c=>c.id===card.id); if(idx>-1) state.table.splice(idx,1); window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state); }
async function appendToZone(card, zoneKind){ if(!state.gameId) return; if(zoneKind==='graveyard') state.gy.unshift(card); if(zoneKind==='exile') state.exile.unshift(card); window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state); }
async function removeFromZone(card, zoneKind){ if(!state.gameId) return; const arr=(zoneKind==='graveyard')?state.gy:state.exile; const idx=arr.findIndex(c=>c.id===card.id); if(idx>-1) arr.splice(idx,1); window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state); }
async function writeCommander(card){ if(!state.gameId) return; state.tableCommander=card; window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state); }
async function writeDrawToServer(){ if(!state.gameId) return; window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state); }
async function deckPutTop(card){ state.deck.unshift(card); }
async function deckPutBottom(card){ state.deck.push(card); }
async function deckShuffle(){ for(let i=state.deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [state.deck[i],state.deck[j]]=[state.deck[j],state.deck[i]]; } }
async function resetPlayerOnly({ hard = true } = {}) {
  if (!state.gameId) return;

  // 1) Clear local runtime state
  state.deck = [];
  state.hand = [];
  state.table = [];
  state.gy = [];
  state.exile = [];
  state.tableCommander = null;
  state.turn = 0;

  // 2) Clear DOM
  worldEl.querySelectorAll('.card').forEach(n => n.remove());
  clearSelection();
  renderHand();

  // 3) Persist RESET remotely
  try {
    if (hard && window.window.StorageAPI.deletePlayerState) {
      // Hard delete the player doc — safest way to guarantee reload starts clean
      await window.window.StorageAPI.deletePlayerState(state.gameId, state.mySeat);
    } else if (window.window.StorageAPI.wipePlayerState) {
      // Or overwrite with a blank payload
      await window.window.StorageAPI.wipePlayerState(state.gameId, state.mySeat, {
        Deck: [], Hand: [], Table: [], Graveyard: [], Exile: [],
        Commander: null, Turn: 0
      });
    } else {
      // Last-resort: save the blank local state immediately
      window.window.StorageAPI.savePlayerStateDebounced(state.gameId, state.mySeat, state);
    }
  } catch (err) {
    console.error('Reset (remote) failed:', err);
    alert('Reset failed to persist. See console.');
  }
}


const battleBtn = document.getElementById('battleBtn');

let _combatWired = false;

// Wait until the storage module has initialized and exposed window.StorageAPI
async function waitForStorageReady(){
  while (!(window.StorageAPI && window.window.window.StorageAPI.startMetaPoller)) {
    await new Promise(r=>setTimeout(r, 50));
  }
}

function paintBattleFab(){
  if (!battleBtn) return;
  const mine = Number(state.mySeat);
  const icon = (mine === Number(currentTurnSeat)) ? '⚔️' : '🛡️';
  battleBtn.textContent = icon;
  console.log('[paintBattleFab]', {
    mySeat: mine,
    currentTurnSeat,
    icon
  });
}

async function hydrateTurnSeatNow(){
  if (!state.gameId) return;
  try{
    const m = await window.StorageAPI.loadMeta(state.gameId);
    currentTurnSeat = Number(m?.TurnSeat ?? m?.turnSeat ?? m?.turn?.seat ?? 0);
    console.log('[meta.once] TurnSeat =', currentTurnSeat, '(boot/hydrate)');
    paintBattleFab();
  }catch(err){
    console.warn('[meta.once] Failed to hydrate TurnSeat', err);
  }
}



// Ensure we only wire once, after a Game is selected and storage is ready
async function ensureCombatWiring(){
  console.log('[ensureCombatWiring] ENTER', {
    wired: typeof _combatWired !== 'undefined' ? _combatWired : '(unset)',
    gameId: state?.gameId,
    mySeat: state?.mySeat,
    hasBtn: !!document.getElementById('battleBtn')
  });

  // guards
  if (_combatWired) {
    console.log('[ensureCombatWiring] already wired — SKIP');
    return;
  }
  if (!state?.gameId) {
    console.warn('[ensureCombatWiring] ABORT: missing state.gameId');
    return;
  }

  // storage ready + ensure combat row
  try {
    console.log('[ensureCombatWiring] waitForStorageReady()…');
    await waitForStorageReady();
    console.log('[ensureCombatWiring] storage ready ✓');
  } catch(e){
    console.error('[ensureCombatWiring] storage wait FAILED', e);
  }

  try{
    console.log('[ensureCombatWiring] ensureCombatRow…', state.gameId);
    await window.StorageAPI?.ensureCombatRow?.(state.gameId);
    console.log('[ensureCombatWiring] ensureCombatRow ✓');
  }catch(e){
    console.warn('[ensureCombatWiring] ensureCombatRow failed (will continue)', e);
  }
  
  // inside ensureCombatWiring() after meta poller is set up
try{
  if (state.stopTurnWatch) { state.stopTurnWatch(); state.stopTurnWatch = null; }
  console.log('[ensureCombatWiring] startTurnWatcher…');
  state.stopTurnWatch = startTurnWatcher(state.gameId, async (row)=>{
  const prev = Number(currentTurnSeat || 0);
  const next = Number(row?.turn_seat || 0);
  if (!next) return;
  const changed = (prev !== next);
  currentTurnSeat = next;
  paintBattleFab();
  if (changed) {
    const idx = Number(row?.turn_index ?? 0);
    showToast?.(`Player ${next}'s turn. (Turn ${idx})`);
    await refreshWorldFromStorage();     // ← force world re-render here
  }
});

  console.log('[ensureCombatWiring] startTurnWatcher ✓');
}catch(e){
  console.error('[ensureCombatWiring] startTurnWatcher FAILED', e);
}


  // keep TurnSeat live + repaint
  try{
    if (state.stopMeta) {
      console.log('[ensureCombatWiring] stopMeta() previous poller');
      state.stopMeta();
    }
    console.log('[ensureCombatWiring] startMetaPoller…');
    state.stopMeta = window.StorageAPI.startMetaPoller(state.gameId, (meta)=>{
      const prev = Number(currentTurnSeat || 0);
      currentTurnSeat = Number(meta?.TurnSeat ?? meta?.turnSeat ?? meta?.turn?.seat ?? 0);
      const changed = (prev !== currentTurnSeat);
      console.log('[meta] TurnSeat →', { prev, next: currentTurnSeat, changed, meta });
      paintBattleFab();
    });
    console.log('[ensureCombatWiring] startMetaPoller ✓');
  }catch(e){
    console.error('[ensureCombatWiring] startMetaPoller FAILED', e);
  }

  // combat doc poller → cache to window for debugs
  try{
    console.log('[ensureCombatWiring] startCombatPoller…');
    startCombatPoller(state.gameId, state.mySeat, (data)=>{
      window.__combatState = data || null;
      // Keep this quiet unless you need to see every tick:
      // console.log('[combat.poll]', data);
    });
    console.log('[ensureCombatWiring] startCombatPoller ✓');
  }catch(e){
    console.error('[ensureCombatWiring] startCombatPoller FAILED', e);
  }

  const getIsMyTurn = () => Number(state.mySeat) === Number(currentTurnSeat);

  // === Resilient battle button wiring (handles DOM replacement) ===
  const battleBtnSelector = '#battleBtn';
  const hostToWatch =
    document.querySelector('.fabbar') ||
    document.getElementById('fabbar') ||
    document.body;

  function attachBattleHandlers() {
    const btn = document.querySelector(battleBtnSelector);
    if (!btn) { console.warn('[battleBtn] NOT FOUND (will keep watching)'); return false; }

    // avoid duplicate binds on the same node
    if (btn.dataset.wired === '1') {
      // still log what we have
      const listeners = (window.getEventListeners?.(btn)?.click || []).length;
      console.log('[battleBtn] already wired on node', { node: btn, listeners });
      return true;
    }

    // wireBattleFab (attacker/defender chooser)
    try{
      wireBattleFab({
        gameId: state.gameId,
        mySeat: state.mySeat,
        getIsMyTurn,
        btn
      });
    }catch(e){
      console.error('[battleBtn] wireBattleFab FAILED', e);
    }

    // rich click logger (your requested payload)
    btn.addEventListener('click', () => {
      const mine  = Number(state.mySeat);
      const turn  = Number(currentTurnSeat);
      const atk   = (mine === turn);
      const icon  = btn.textContent;
      const cs    = window.__combatState || null;
      console.log('[battle.click]', {
        time: new Date().toISOString(),
        mySeat: mine,
        currentTurnSeat: turn,
        isAttacker: atk,
        btnIcon: icon,
        meta: { gameId: state.gameId, playerCount: state.playerCount },
        combatState: cs
      });
    });

    btn.dataset.wired = '1';
    console.log('[battleBtn] WIRED on node', btn);
    return true;
  }

  // initial attach; if button not there yet, observer will catch it
  attachBattleHandlers();

  // observe host for any DOM swaps that would replace the button
  if (!window.__battleFabObserver) {
    window.__battleFabObserver = new MutationObserver(() => {
      const btn = document.querySelector(battleBtnSelector);
      if (!btn) return;
      if (btn.dataset.wired !== '1') {
        console.warn('[battleBtn] listener LOST — re-attaching');
        attachBattleHandlers();
      }
    });
    window.__battleFabObserver.observe(hostToWatch, { childList: true, subtree: true });
    console.log('[ensureCombatWiring] MutationObserver started on', hostToWatch);
  } else {
    console.log('[ensureCombatWiring] MutationObserver already running');
  }

  // paint once immediately based on currentTurnSeat
  paintBattleFab();

  _combatWired = true;
  console.log('[ensureCombatWiring] DONE ✓', { wired: _combatWired });
}

// expose globally so cross-module calls work
window.ensureCombatWiring = ensureCombatWiring;











// When a game is picked, run wiring shortly after loadGameIntoUI sets state.gameId
gamePicker.addEventListener('click', ()=>{
  // loadGameIntoUI runs in this same handler; schedule wiring next tick
  setTimeout(ensureCombatWiring, 0);
});




gamePicker.addEventListener('click', async (e)=>{
  const btn = e.target.closest('.gameBtn'); if(!btn) return;
  state.mySeat = Number(document.getElementById('mySeat').value);
  gamePicker.querySelectorAll('.gameBtn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');

  localStorage.setItem('lastGameId', btn.dataset.game);

  await waitForStorageReady();
  await loadGameIntoUI(btn.dataset.game);
  await ensureTurnSeatMeta();
  await hydrateTurnSeatNow();          // ← set currentTurnSeat immediately

  // keep TurnSeat live after the one-shot
  if (state.stopMeta) state.stopMeta();
  state.stopMeta = window.StorageAPI.startMetaPoller(state.gameId, (meta)=>{
    currentTurnSeat = Number(meta?.TurnSeat ?? meta?.turnSeat ?? meta?.turn?.seat ?? 0);
    console.log('[meta] TurnSeat →', currentTurnSeat);
    paintBattleFab();
  });

  // wire rest of combat UI next tick
  setTimeout(ensureCombatWiring, 0);
});



/* Startup */
renderHand(); enableHandSwipe(); zoomInput.value=zoomInput.min; state.zoom=Number(zoomInput.min)/100; applyWorldTransform();
deckZone.addEventListener('click', draw); deckZone.addEventListener('dblclick', draw);
// Start with drawer open
drawerWrap.classList.add('expanded');
drawerWrap.classList.remove('collapsed');
zoomWrapEl.style.display = 'none';
// DEBUG: log clicks for the deck button cluster + overlay closes
document.addEventListener('click', (e) => {
  const el = e.target.closest(
    '#deckSearchBtn,#deckAddBtn,#deckMoreBtn,' + 
    '#deckSearchClose,#deckAddAnyClose,#deckToolsClose'
  );
  if (!el) return;
  console.log(
    `[BTN] ${el.id} clicked`,
    { time: new Date().toISOString(), gameId: window.AppState?.gameId, seat: window.AppState?.mySeat }
  );
}, { capture: true });

</script>
<script type="module" src="./modules/turn.timewarp.js"></script>

<!-- Storage module import & init -->
<script type="module">
  import {
  initStorage,
  savePlayerStateDebounced,
  loadPlayerState,
  loadMeta,
  saveMeta,
  startPlayerPollers,
  startMetaPoller,
  deletePlayerState,
  wipePlayerState,
  // add these:
  ensureCombatRow,
  readCombat, writeCombat, resetCombat,
  saveAttacks, saveBlocks, writeCombatInitiated,
  saveTurnState, readTurnState, startTurnWatcher, snapshotAllSeatsToTable
} from './modules/env.supabase.js';





  // pull the shared state created in the first module script
  // (small guard in case execution order ever shifts)
  while (!window.AppState) { await new Promise(r => setTimeout(r, 0)); }
  const state = window.AppState;

// --- Life strip helpers (reflect meta -> UI) ---
function renderLifeFromMeta(m){
  const life = m?.lifeMain || {};
  const tiles = document.querySelectorAll('.life-strip .life-tile');
  tiles.forEach((tile, idx) => {
    const seatNum = idx + 1;
    const val = (seatNum in life) ? life[seatNum] : 40;
    const span = tile.querySelector('.life-main');
    if (span) span.textContent = String(val);
  });
}

// make it callable from other modules
window.renderLifeFromMeta = renderLifeFromMeta;

// tiny helper: reload meta → redraw life strip
window.refreshLifeTotals = async function refreshLifeTotals(){
  try{
    const gid = String(window.AppState?.gameId || '');
    if (!gid || !window.StorageAPI?.loadMeta) return;
    const meta = await window.StorageAPI.loadMeta(gid);
    renderLifeFromMeta(meta || {});
  }catch(e){
    console.warn('[life] refreshLifeTotals failed', e);
  }
};


// Start a meta poller so life totals propagate across clients
(function ensureMetaLifeWatcher(){
  if (!window.StorageAPI?.startMetaPoller) return;
  // Start once we have a game id
  const start = ()=>{
    if (!state.gameId) return;
    try {
      if (state._lifePollerStop) state._lifePollerStop(); // if already running
      state._lifePollerStop = window.StorageAPI.startMetaPoller(state.gameId, (m)=>{
        renderLifeFromMeta(m);
      }, 200); // 5x/sec is fine; adjust if you like
    } catch(_) {}
  };
  // Kick when game is chosen
  const gp = document.getElementById('gamePicker');
  gp?.addEventListener('click', (e)=>{
    const btn = e.target.closest('.gameBtn');
    if (!btn) return;
    setTimeout(start, 50);
  });
  // also try once at boot (in case game already chosen)
  setTimeout(start, 300);
})();


  window.StorageAPI = {
    initStorage,
    savePlayerStateDebounced,
    loadPlayerState,
    loadMeta,
    saveMeta,
    startPlayerPollers,
    startMetaPoller,
    deletePlayerState,
    wipePlayerState,
    // add these so callers can use them via window.StorageAPI
    ensureCombatRow,
    readCombat,
    writeCombat,
    resetCombat,
    saveAttacks,
    saveBlocks,
    // nice alias so UI code can call setCombatInitiated(...)
    setCombatInitiated: writeCombatInitiated
  };
  
  // === DEBUG WRAPPERS for StorageAPI — log exact doc + op =================
(() => {
  const api = window.StorageAPI || {};
  const _save = api.savePlayerStateDebounced;
  const _load = api.loadPlayerState;
  const _wipe = api.wipePlayerState;
  const _del  = api.deletePlayerState;
  const _saveMeta = api.saveMeta;
  const _loadMeta = api.loadMeta;

  if (_save) {
    api.savePlayerStateDebounced = function(gameId, seat, payload){

      // Optional: show where ext fields live for the selected card, if any
      try {
        const sel = window.AppState?.selectedCardId;
        if (sel){
          const all = (payload?.Table||[]).concat(payload?.Hand||[], payload?.Deck||[], payload?.Graveyard||[], payload?.Exile||[], payload?.Commander?[payload.Commander]:[]);
          const card = all.find(c=>String(c.id)===String(sel));
          if (card){
            const loc = __locateCardInState(card);
     
          }
        }
      } catch(_) {}
      return _save.apply(this, arguments);
    };
  }
  if (_load) {
  api.loadPlayerState = async function(gameId, seat){
    const res = await _load.apply(this, arguments);
    return res;
  };
}

  if (_wipe) {
    api.wipePlayerState = function(gameId, seat){
      return _wipe.apply(this, arguments);
    };
  }
  if (_del) {
    api.deletePlayerState = function(gameId, seat){
      return _del.apply(this, arguments);
    };
  }
  if (_saveMeta){
    api.saveMeta = function(gameId, meta){

      return _saveMeta.apply(this, arguments);
    };
  }
  if (_loadMeta){
    api.loadMeta = function(gameId){

      return _loadMeta.apply(this, arguments);
    };
  }
  window.StorageAPI = api;
})();


  await initStorage();
  import { bootDeckTools } from './modules/deck.tools.js';

// Alias for older callers inside deck.tools.js
window.StorageAPI.savePlayerState = window.StorageAPI.savePlayerStateDebounced;

bootDeckTools(); // wire the 3 deck buttons now that StorageAPI exists

  state.viewSeat = state.mySeat;  // start by viewing "me"

</script>
<script type="module">
  import { startCombatPoller } from './modules/combat.ui.js';

  function bootPoller(){
    const gid = String(window.AppState?.gameId || '');
    if (gid) {
      try { startCombatPoller(gid); } catch(e){ console.warn('[poller] start failed', e); }
    }
  }

  // start when page is ready and AppState has a game
  window.addEventListener('load', bootPoller);

  // also re-start whenever user clicks a game button
  document.getElementById('gamePicker')?.addEventListener('click', () => {
    // your existing game-pick code sets AppState.gameId; then:
    setTimeout(bootPoller, 50);
  });
</script>

</body>
</html>
