<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Truck Layouts + Drag Chips</title>
<style>
  :root { --box-h: 64px; --gap: 12px; }
  body { font-family: system-ui, sans-serif; margin: 16px; }
  .row { display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; }
  .controls { display:flex; gap:24px; margin-bottom:12px; flex-wrap:wrap; }
  .controls label { margin-right:12px; cursor:pointer; }
  textarea{ flex:1; min-width:260px; padding:10px; font-size:16px; min-height:80px; }
  button{ padding:10px 14px; font-size:16px; cursor:pointer; }
  .dock {
    display:flex; gap:8px; flex-wrap:wrap;
    padding:8px; border:1px solid #ddd; border-radius:8px; margin-bottom:12px;
    min-height:44px;
  }
  .chip {
    user-select:none;
    padding:8px 10px; border:1px solid #bbb; border-radius:999px;
    background:#f7f7f7; font-size:16px; touch-action:none;
  }
  .grid { display:grid; grid-auto-rows:var(--box-h); gap:var(--gap); }
  .slot {
    position:relative; height:var(--box-h);
    border:1px dashed #bbb; border-radius:6px; background:#fff;
    display:flex; align-items:center; justify-content:center;
    color:#888; font-size:14px;
  }
  .half { transform:translateY(calc(var(--box-h)/2)); z-index:1; }
  .slot .chip { position:static; margin:0; border-radius:6px; width:100%; text-align:center; background:#fff; }
  .drag-ghost { position:fixed; left:0; top:0; pointer-events:none; transform:translate(-9999px,-9999px); z-index:9999; opacity:.95; box-shadow:0 4px 14px rgba(0,0,0,.15); }
  .hint { font-size:12px; color:#666; margin-bottom:8px; }
</style>
</head>
<body>

<div class="controls">
  <div>
    <strong>Truck:</strong>
    <label><input type="radio" name="truck" value="scott" checked> Scott‚Äôs</label>
    <label><input type="radio" name="truck" value="brian"> Brian‚Äôs</label>
    <label><input type="radio" name="truck" value="cody"> Cody‚Äôs</label>
  </div>
  <div>
    <strong>Side:</strong>
    <label><input type="radio" name="sex" value="male" checked> Males</label>
    <label><input type="radio" name="sex" value="female"> Females</label>
  </div>
</div>

<div class="hint">Paste names (commas, semicolons, spaces, newlines, or ‚Äú/n‚Äù all work). Click Add or press Ctrl+Enter.</div>

<div class="row">
  <textarea id="nameInput" placeholder="e.g.&#10;Judge&#10;Duke&#10;Bella&#10;&#10;or: Judge, Duke, Bella&#10;or: Judge; Duke; Bella"></textarea>
  <button id="addBtn">Add</button>
</div>

<div class="dock" id="dock"></div>

<!-- Layout area (rebuilt when radios change) -->
<div class="grid" id="layout"></div>

<div class="chip drag-ghost" id="ghost"></div>

<!-- Save / Clear -->
<div style="margin-top:16px;">
  <button id="saveBtn">üíæ Save</button>
  <button id="clearBtn" style="margin-left:8px;">üóëÔ∏è Clear</button>
</div>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
// ---------- Firebase ----------
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.firebasestorage.app",
  messagingSenderId: "795274673000",
  appId: "1:795274673000:web:0ea07130e45c72384134dd",
  measurementId: "G-VLW5KLY4FF"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ---------- Layout definitions ----------
const LAYOUTS = {
  scott: {
    male:   { cols: 8, r1: ['N','N','I','I','N','N','H','H'], r2: ['N','N','N','N','N','N','I','I'] },
    female: { cols: 8, r1: ['H','H','N','N','I','I','N','N'], r2: ['S','S','N','N','N','N','N','N'] }
  },
  brian: {
    male:   { cols: 5, r1: ['N','N','H','H','N'],             r2: ['N','N','S','S','N']             },
    female: { cols: 5, r1: ['N','H','H','N','N'],             r2: ['N','S','S','N','N']             }
  },
  cody: {
    male:   { cols: 9, r1: ['N','H','H','N','I','H','H','H','I'], r2: ['N','S','S','N','N','S','S','S','N'] },
    female: { cols: 9, r1: ['S','H','H','H','S','N','H','H','N'], r2: ['N','S','S','S','N','N','S','S','N'] }
  }
};

// ---------- Helpers for selection & doc ids ----------
const truckRadios = document.querySelectorAll('input[name="truck"]');
const sexRadios   = document.querySelectorAll('input[name="sex"]');
const dock   = document.getElementById('dock');
const layout = document.getElementById('layout');

function getSelection(){
  const truck = document.querySelector('input[name="truck"]:checked').value;
  const sex   = document.querySelector('input[name="sex"]:checked').value;
  return { truck, sex };
}
function docIdForSelection(){
  const {truck, sex} = getSelection();
  return `${truck}_${sex}_latest`;
}

// ---------- Build layout grid ----------
function buildLayout(){
  const {truck, sex} = getSelection();
  const def = LAYOUTS[truck][sex];
  layout.style.gridTemplateColumns = `repeat(${def.cols}, 1fr)`;
  layout.innerHTML = ''; // clear

  // r1
  def.r1.forEach((cell, idx) => {
    if (cell === 'N' || cell === 'H') {
      const slot = document.createElement('div');
      slot.className = 'slot' + (cell === 'H' ? ' half' : '');
      slot.dataset.slot = `${truck[0].toUpperCase()}_${sex[0].toUpperCase()}_R1C${idx+1}${cell==='H'?'H':''}`;
      slot.style.gridColumn = (idx+1);
      slot.style.gridRow = 1;
      layout.appendChild(slot);
    }
  });
  // r2
  def.r2.forEach((cell, idx) => {
    if (cell === 'N') {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.dataset.slot = `${truck[0].toUpperCase()}_${sex[0].toUpperCase()}_R2C${idx+1}`;
      slot.style.gridColumn = (idx+1);
      slot.style.gridRow = 2;
      layout.appendChild(slot);
    }
    // 'S' or 'I' -> no slot
  });
}

// ---------- Chips & drag (same behavior) ----------
(function(){
  const ghost = document.getElementById('ghost');
  const input = document.getElementById('nameInput');
  const addBtn= document.getElementById('addBtn');

  const currentNames = () =>
    new Set([...document.querySelectorAll('.chip:not(.drag-ghost)')]
      .map(c => (c.dataset.name || c.textContent || '').trim().toLowerCase())
      .filter(Boolean));

  function parseNames(text){
    return text.split(/(?:,|;|\/n|\s)+/g).map(s => s.trim()).filter(Boolean);
  }

  function makeChip(name){
    if (currentNames().has(name.toLowerCase())) return;
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = name;
    chip.dataset.name = name;
    dock.appendChild(chip);
  }
  window.makeChip = makeChip; // used by loadState()

  function addChipsFromInput(){
    const raw = input.value.trim();
    if (!raw) return;
    parseNames(raw).forEach(makeChip);
    input.value = '';
    input.focus();
  }
  addBtn.addEventListener('click', addChipsFromInput);
  input.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); addChipsFromInput(); }
  });

  let dragging=null, offsetX=0, offsetY=0;

  const slots = () => Array.from(layout.querySelectorAll('.slot'));
  function setGhost(text,x,y){ ghost.textContent=text; ghost.style.transform=`translate(${x-offsetX}px,${y-offsetY}px)`; }
  function nearestOverlappingSlot() {
  const r = ghost.getBoundingClientRect();
  const cx = r.left + r.width / 2, cy = r.top + r.height / 2;
  let best = null, bestDist = Infinity;
  for (const s of slots()) {
    const b = s.getBoundingClientRect();
    if (cx < b.left || cx > b.right || cy < b.top || cy > b.bottom) continue;
    // Allow slots with chips now (for swapping)
    const dist = Math.hypot(cx - (b.left + b.right) / 2, cy - (b.top + b.bottom) / 2);
    if (dist < bestDist) { best = s; bestDist = dist; }
  }
  return best;
}

  
  
  function startDrag(chip,x,y){
    dragging=chip;
    const r = chip.getBoundingClientRect();
    offsetX=x-r.left; offsetY=y-r.top;
    setGhost(chip.textContent,x,y);
  }
  
function endDrag() {
  if (!dragging) return;
  const target = nearestOverlappingSlot();
  const oldParent = dragging.parentElement;

  if (target) {
    const existingChip = target.querySelector('.chip:not(.drag-ghost)');

    if (existingChip && oldParent.classList.contains('slot')) {
      // Swap if both from slots
      oldParent.appendChild(existingChip);
      updateQRMapping(oldParent.dataset.slot, existingChip.dataset.name).catch(console.error);
    } else if (existingChip) {
      // Move existing chip back to dock if coming from dock
      dock.appendChild(existingChip);
      updateQRMapping(target.dataset.slot, null).catch(console.error);
    }

    target.appendChild(dragging);
    updateQRMapping(target.dataset.slot, dragging.dataset.name).catch(console.error);

    if (oldParent.classList.contains('slot') && oldParent !== target) {
      updateQRMapping(oldParent.dataset.slot, null).catch(console.error);
    }
  } else {
    dock.appendChild(dragging);
    if (oldParent.classList.contains('slot')) {
      updateQRMapping(oldParent.dataset.slot, null).catch(console.error);
    }
  }

  ghost.style.transform = 'translate(-9999px,-9999px)';
  dragging = null;
}



  layout.addEventListener('click', e => {
    const chip = e.target.closest('.chip');
if (chip && chip.parentElement.classList.contains('slot')) {
    const slotId = chip.parentElement.dataset.slot;
    updateQRMapping(slotId, null).catch(console.error);
    dock.appendChild(chip);
  }
  });
  document.addEventListener('pointerdown', e=>{
    const chip = e.target.closest('.chip'); if(!chip) return;
    e.preventDefault(); chip.setPointerCapture?.(e.pointerId);
    startDrag(chip, e.clientX, e.clientY);
  });
  document.addEventListener('pointermove', e=>{ if(dragging) setGhost(dragging.textContent, e.clientX, e.clientY); });
  document.addEventListener('pointerup',   ()=> endDrag());
})();

// ---------- Save / Load / Clear (per selection) ----------
function getCurrentState(){
  const allChips = [...document.querySelectorAll('.chip:not(.drag-ghost)')];
  const dockNames = allChips.filter(c => c.parentElement.id === 'dock').map(c => c.dataset.name);
  const slotData = {};
  document.querySelectorAll('.slot').forEach(slot=>{
    const chip = slot.querySelector('.chip:not(.drag-ghost)');
    slotData[slot.dataset.slot] = chip ? chip.dataset.name : null;
  });
  const masterNames = [...new Set([...dockNames, ...Object.values(slotData).filter(Boolean)])];
  return { dockNames, slotData, masterNames };
}

async function saveState(){
  try {
    await db.collection('layouts').doc(docIdForSelection()).set(getCurrentState());
    alert('Layout saved!');
  } catch(err){
    console.error('Error saving state:', err);
    alert('Failed to save.');
  }
}

async function updateQRMapping(slotId, dogName) {
  const { truck, sex } = getSelection();
  const layoutDocId = docIdForSelection();

  // update trailerLayouts (compat syntax)
  const ref = db
    .collection("trailerLayouts")
    .doc(`${truck}-${sex}`)
    .collection("slots")
    .doc(slotId);

  let dogId = null;
  if (dogName) {
    try {
      const profileSnap = await db.collection("dogProfiles")
        .where("name", "==", dogName)
        .limit(1)
        .get();
      if (!profileSnap.empty) {
        dogId = profileSnap.docs[0].id;
      }
    } catch (err) {
      console.error(`Error fetching dogId for ${dogName}:`, err);
    }
  }

  await ref.set({
    dogName: dogName || null,
    dogId: dogId || null,
    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
  }, { merge: true });

  // ALSO update layouts doc so loadState() sees it right away
  const current = getCurrentState();
  current.slotData[slotId] = dogName || null;
  await db.collection("layouts").doc(layoutDocId).set(current);
}




async function loadState(){
  try{
    const snap = await db.collection('layouts').doc(docIdForSelection()).get();
    // clear chips and slots first
    document.querySelectorAll('.chip:not(.drag-ghost)').forEach(c=>c.remove());
    document.querySelectorAll('.slot').forEach(s=>s.innerHTML='');

    if (!snap.exists) return;
    const data = snap.data() || {};
    const slotData = data.slotData || {};
    const dockNames = Array.isArray(data.dockNames) ? data.dockNames : [];
    const master = Array.isArray(data.masterNames) ? data.masterNames : [];
    const namesInSlots = Object.values(slotData).filter(Boolean);
    const allNames = [...new Set([ ...master, ...dockNames, ...namesInSlots ])];

    // chips in dock
    allNames.forEach(n => window.makeChip(n));
    // move into slots
    for (const [slotId, name] of Object.entries(slotData)) {
      if (!name) continue;
      const slot = document.querySelector(`.slot[data-slot="${slotId}"]`);
      if (!slot) continue;
      const chip = [...document.querySelectorAll('.chip:not(.drag-ghost)')].find(c=>c.dataset.name===name);
      if (chip) slot.appendChild(chip);
    }
  } catch(err){
    console.error('Error loading state:', err);
  }
}

async function clearState(){
  if (!confirm("Clear this truck/side layout?")) return;
  try { await db.collection('layouts').doc(docIdForSelection()).delete(); } catch(e){ console.warn(e); }
  document.querySelectorAll('.chip:not(.drag-ghost)').forEach(c=>c.remove());
  document.querySelectorAll('.slot').forEach(s=>s.innerHTML='');
}

// ---------- Switcher ----------
function refreshSelection(){
  buildLayout();     // rebuild slots for current radios
  loadState();       // load that selection from Firestore (if any)
}
truckRadios.forEach(r => r.addEventListener('change', refreshSelection));
sexRadios.forEach(r   => r.addEventListener('change', refreshSelection));

// ---------- Hooks ----------
document.getElementById('saveBtn').addEventListener('click', saveState);
document.getElementById('clearBtn').addEventListener('click', clearState);

// Initial
window.addEventListener('DOMContentLoaded', refreshSelection);
</script>
</body>
</html>
