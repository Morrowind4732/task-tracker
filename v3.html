<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Deck Table — V2 (mobile portrait first)</title>

<link rel="stylesheet" href="mana-master/css/mana.min.css">



<style>
:root{
  --bg:#0e1015;
  --fg:#e7e9ee;
  --muted:#9aa3b2;
  --accent:#6aa9ff;

  --ok:#42d392;
  --warn:#ffb84d;
  --danger:#ff6b6b;

  --topbar-h:64px;
  --life-h:40px;

  /* === Primary Sizing Constants === */
  --card-w: var(--cardWidth, 223px);
  --card-h: var(--cardHeight, 310px);

  --zone-w: var(--zoneWidth, 223px);
  --zone-h: var(--zoneHeight, 310px);

  --hand-scale: var(--handScale, 0.88);
  --tooltip-font-size: var(--tooltipFontSize, 13px);
  --tooltip-icon-size: var(--tooltipIconSize, 18px);

  /* === Zoom & Rotation === */
  --world-zoom: var(--worldZoom, 1);
  --flip-rot: var(--flipRot, 0deg);
  --tap-rot: var(--tapRot, 0deg);

  /* === Z-Index Layers === */
  --z-tooltip:20;
  --z-hand:35;
  --z-toolbar:40;
  --z-drawer:60;
  --z-zoom:45;
  --z-actions:36;
  --z-overlays:10000;

  /* === PT Badge Boost (Card Attrs) === */
  --badgeBoost: var(--ptBadgeScale, 1.35);
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{ margin:0; background:var(--bg); color:var(--fg); font:14px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; -webkit-tap-highlight-color:transparent; overflow:hidden; }
button{ font:inherit; color:inherit; cursor:pointer; background:none; border:0; }
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:8px; }

/* Top bar */
.topbar{ position:sticky; top:0; z-index:10; display:grid; grid-template-columns:auto 1fr; align-items:center; gap:10px; height:var(--topbar-h); padding:10px 12px; border-bottom:1px solid #1f2738; background:linear-gradient(180deg,#10141b,#0c1117); }
.cog{ width:42px; height:42px; border-radius:12px; border:1px solid #24324a; background:#111826; display:grid; place-items:center; font-weight:900; }
.life-strip{ display:flex; gap:8px; align-items:center; }
.life-tile{
  background:#0f141c; border:1px solid #2b3344; border-radius:12px;
  min-width:90px; padding:6px 10px;
  display:flex; align-items:center;
  justify-content:flex-start;   /* was space-between */
  gap:10px;                     /* adds clear space between “P1” and the life */
}

.life-main{ color:#ff6b6b; font-weight:800; }
.life-cmd{ color:#e7e9ee; background:#000; border-radius:8px; padding:0 6px; margin-left:8px; font-weight:700; }

/* Drawer */
.drawer-wrap{ position:relative; z-index:var(--z-drawer); overflow:hidden; transition:max-height .25s ease; border-bottom:1px solid #1f2738; }
.drawer-wrap.collapsed{ max-height:0; border-bottom-color:transparent; }
.drawer-wrap.expanded{ max-height:420px; }
.drawer{ position:relative; z-index:inherit; padding:12px; background:#0b0f15; display:grid; gap:10px; }
.row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.pill{ background:#1b2a47; color:#d8e7ff; font-weight:700; padding:9px 12px; border-radius:12px; border:1px solid #24324a; }
select.pill{ padding:8px 10px; }
textarea.deck-in{ width:100%; height:140px; resize:vertical; padding:10px; border-radius:12px; border:1px solid #24304a; background:#0a0f16; color:var(--fg); font:13px/1.45 ui-monospace,Menlo,Consolas,monospace; }

/* Table */
.table{ position:relative; height:calc(100% - var(--topbar-h)); background:linear-gradient(180deg,#0d3a1e,#0a2716 40%, #092113); }
.worldWrap{ position:absolute; inset:0; overflow:hidden; cursor:grab; touch-action:none; }
.worldWrap.panning{ cursor:grabbing; }
.worldScale{ position:relative; transform-origin:0 0; will-change:transform; }
.world{ position:relative; min-width:100%; min-height:100%; padding:24px; }

/* Zones */
.zone{ position:absolute; width:var(--zone-w); height:var(--zone-h); border:2px dashed rgba(255,255,255,.2); border-radius:12px; background:rgba(0,0,0,.12); display:grid; place-items:center; user-select:none; }
.zone .label{ color:#d0d6e4; font-weight:700; pointer-events:none; }
#deckZone{ background:#000 url('https://i.imgur.com/LdOBU1I.jpeg') center/cover no-repeat; border:1px solid #2b3344; }
#deckZone .label{ display:none; }
#deckZone{ left:24px; top:24px; }
#cmdZone{ left:24px; top:calc(24px + var(--zone-h) + 12px); }
#graveyard{ left:calc(24px + var(--zone-w) + 16px); top:24px; }
#exileZone{ left:calc(24px + var(--zone-w) + 16px); top:calc(24px + var(--zone-h) + 12px); }

/* Card shells */
.card{ position:absolute; width:var(--card-w); height:var(--card-h); border-radius:14px; box-shadow:0 10px 26px rgba(0,0,0,.5); touch-action:none; perspective:1000px; transition: width .18s ease, height .18s ease; overflow:visible; }
.card.tapped {
  width: var(--card-w);
  height: var(--card-h);
}

/* Inner 3D flipper */
  .cardInner{
    position:absolute; left:50%; top:50%; width:100%; height:100%; border-radius:14px;
    transform-style: preserve-3d;
    transform-origin:center center;
    transform: translate(-50%,-50%) rotateZ(var(--tap-rot)) rotateY(var(--flip-rot));
    transition: transform .35s ease, width .18s ease, height .18s ease;
  }
  .cardTooltip{ z-index: calc(var(--z-actions) + 1); }

  .card.tapped .cardInner{
    width:var(--card-w);
    height:var(--card-h);
  }

  .card.in-cmd .cardInner{
    /* Commander zone: logically tapped but no visual rotate */
    transform: translate(-50%,-50%) rotateZ(0deg) rotateY(var(--flip-rot));
  }

.card.selected{ outline:2px solid var(--accent); outline-offset:2px; }

/* Faces */
.face{
  position:absolute; inset:0; border-radius:14px;
  backface-visibility:hidden;  /* hide reverse of each face */
  background:#1a1f2a center/cover no-repeat;
}
.face.back{ transform: rotateY(180deg); } /* back is pre-rotated to face forward when parent flips */

/* Hide P/T by default */
.card .pt{
  position:absolute; right:6px; bottom:6px;
  background:rgba(0,0,0,.7); color:#e7f0ff; border-radius:8px;
  padding:2px 6px; font-weight:800; z-index:2;
  transform: scale(calc(var(--overlayScale) * var(--badgeBoost)));
  transform-origin: bottom right;
  display:none;
}

/* Show P/T only for CREATURES (base or OG P/T present) */
.card[data-type_line*="Creature"][data-base-p]:not([data-base-p=""]):not([data-base-p="?"])[data-base-t]:not([data-base-t=""]):not([data-base-t="?"]) .pt,
.card[data-type_line*="Creature"][data-ogpower]:not([data-ogpower=""]):not([data-ogpower="?"])[data-ogtoughness]:not([data-ogtoughness=""]):not([data-ogtoughness="?"]) .pt { display:block; }

/* Planeswalkers still show (loyalty uses same visual spot) */
.card[data-ogloyalty]:not([data-ogloyalty=""]):not([data-ogloyalty="?"]) .pt,
.card[data-loyalty]:not([data-loyalty=""]):not([data-loyalty="?"]) .pt { display:block; }




/* Quick actions */
.cardActions{ position:absolute; z-index:var(--z-actions); display:flex; flex-direction:column; gap:8px; }
.cardActions .qa{ width:42px; height:42px; border-radius:50%; background:#0f1725; color:#cfe1ff; border:1px solid #2b3f63; display:grid; place-items:center; font-weight:900; box-shadow:0 8px 20px rgba(0,0,0,.35); }

/* Tooltip */
.cardTooltip{
  position:absolute; z-index:var(--z-actions); display:block; min-width:220px; max-width:min(420px,92vw);
  background:#0b1220; color:#e7efff; border:1px solid #263a5f; border-radius:12px; box-shadow:0 14px 36px rgba(0,0,0,.55);
  padding:10px 12px; font-size:13px; line-height:1.35; white-space:normal; overflow-wrap:anywhere; word-break:break-word;
  transform-origin: top left; transform: none;
  resize: both;
  overflow: auto;
}
.cardTooltip h3{ margin:0 0 6px 0; font-size:15px; line-height:1.25; }
.cardTooltip .typeLine{ color:#9fb4d9; margin-bottom:6px; }
.cardTooltip .oracle{ white-space:pre-wrap; }

/* Hand */
.hand{ position:fixed; left:0; right:0; bottom:var(--hand-bottom,56px); z-index:var(--z-hand); display:grid; place-items:center; height:calc(var(--card-h) * .9); pointer-events:none; }
.handTrack{ position:relative; width:100%; height:100%; }
.handCard{ --dx:0px; --rot:0deg; position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--dx)), -50%) scale(var(--hand-scale)) rotate(var(--rot)); transition: transform .18s ease, opacity .18s ease; pointer-events:auto; }
.handCard.far { opacity:.35; transform: translate(calc(-50% + var(--dx)), -50%) scale(calc(var(--hand-scale) * .78)) rotate(var(--rot)); }
.handCard.mid { opacity:.7;  transform: translate(calc(-50% + var(--dx)), -50%) scale(calc(var(--hand-scale) * .88)) rotate(var(--rot)); }
.handCard.focus{ opacity:1; transform: translate(calc(-50% + var(--dx)), -50%) scale(var(--hand-scale)) rotate(0deg); z-index:2; }
.handCard .card{ position:relative; }
.hand.swiping .handCard{ transition:none !important; }

/* Toolbar */
.toolbar{ position:fixed; left:0; right:0; bottom:0; z-index:var(--z-toolbar); display:grid; grid-auto-flow:column; justify-content:center; gap:12px; padding:8px 10px calc(8px + env(safe-area-inset-bottom,0px)); background:linear-gradient(180deg, rgba(12,18,28,0), rgba(12,18,28,.88)); border-top:1px solid rgba(255,255,255,.08); }
.fab{ width:50px; height:50px; border-radius:50%; background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63; display:grid; place-items:center; font-size:20px; box-shadow:0 8px 20px rgba(106,169,255,.18); }

/* Zoom */
.zoomWrap{ position:fixed; left:8px; top:calc(var(--topbar-h) + 8px); z-index:var(--z-zoom); width:32px; height:220px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:12px; display:flex; align-items:center; justify-content:center; overflow:hidden; }
#zoom{ position:relative; transform: rotate(-90deg); transform-origin:center; width:180px; height:32px; -webkit-appearance:none; appearance:none; background:transparent; outline:none; }
#zoom::-webkit-slider-runnable-track{ height:6px; border-radius:4px; background:#23324d; }
#zoom::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:#6aa9ff; border:2px solid #0a1426; transform:translateY(-5px); }

/* Overlays */
.scrim{ position:fixed; inset:0; background:rgba(6,10,16,.6); display:none; z-index:var(--z-overlays); }
.panel{ position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); width:min(720px,94vw); max-height:80vh; overflow:auto; background:rgba(12,18,28,.98); border:1px solid #24324a; border-radius:14px; padding:12px; }
.zoneGrid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:10px; }
.thumb{ width:100%; padding-top:140%; border-radius:10px; background:#1a1f2a center/cover no-repeat; position:relative; overflow:hidden; cursor:pointer; }

/* Mobile tweaks */
@media (max-width: 768px){
  :root{ --card-w:180px; --card-h:250px; --zone-w:180px; --zone-h:250px; --hand-scale:.86; }
  .drawer-wrap.expanded{ max-height:360px; }
}
@media (max-width: 420px){
  :root{ --card-w:160px; --card-h:220px; --zone-w:160px; --zone-h:220px; --hand-scale:.84; }
}

:root{
  /* drives overlay & PT badge sizes off the actual card height */
  --overlayScale: calc(var(--card-h) / 310px); --badgeBoost: 1.35; } /* try 1.2–1.6 */


/* Game picker */
.gamePicker{ display:flex; gap:8px; }
.gameBtn{ background:#1b2a47; color:#d8e7ff; font-weight:800; padding:8px 12px; border-radius:999px; border:1px solid #24324a; opacity:.85; }
.gameBtn.active{ background:#314a7d; border-color:#3d5ba0; opacity:1; box-shadow:0 6px 16px rgba(49,74,125,.35) inset; }

/* Mana icon sizing inside tooltip */
.cardTooltip i.ms{
  font-size: var(--tooltip-font-size);
  line-height:1;
  display:inline-block;
  vertical-align:-2px;
  margin:0 2px;
}
.cardTooltip .cost i.ms{ font-size: var(--tooltip-icon-size); }
.cardTooltip .ms.ms-cost{ margin:0 1px; } /* tiny spacing tweak */

/* Smooth motion + hide actions while viewing another player */
.viewing-opponent .card {
  transition: left .22s ease, top .22s ease, width .18s ease, height .18s ease;
  cursor: default;
}
.viewing-opponent .cardActions { display:none; }

.fab svg{
  width:22px;
  height:22px;
  display:block; /* centers nicely in the grid container */
}

/* Buttons to the immediate left of the deck (vertically centered) */
.deck-actions{
  position: absolute;
  left: calc(var(--DECK_X) - 64px);
  top:  calc(var(--DECK_TOP) + (var(--ZONE_H) / 2) - 28px);
  display: flex;
  flex-direction: column;
  gap: 14px;
  z-index: var(--z-controls);
}
/* Only the three buttons next to the deck */
.deck-actions .sbtn{
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background:#1a2a45;
  color:#cfe1ff;
  border:1px solid #2b3f63;
  font-weight:900;
  font-size:20px;
  display:inline-flex;align-items:center;justify-content:center;line-height:1;
  box-shadow:0 8px 20px rgba(106,169,255,.18);
}
.deck-actions .sbtn:active{ transform:scale(.98); }


.chatOverlay{
  position:fixed; inset:0; display:none; z-index:60;
  background:rgba(6,10,16,.65);
}
.chatPanel{
  position:absolute; left:50%; top:50%;
  transform:translate(-50%,-50%);
  width:min(980px,94vw); max-height:82vh; overflow:auto;
  background:#0b1220; color:#e7efff; border:1px solid #2b3f63;
  border-radius:14px; padding:12px;
}
.chatHeader{
  display:flex; justify-content:space-between; align-items:center;
  gap:8px; margin-bottom:10px; font-weight:800;
}
.chatClose{ background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63;
  border-radius:10px; padding:6px 10px; }
.btn.sm{
  background:#142136; color:#e9f2ff; border:1px solid #35527d;
  border-radius:10px; padding:6px 10px; font-weight:800;
}

.deck-actions,
.deck-actions .sbtn{
  touch-action: auto;
}

/* ==== Stack preview arrow ============================================== */
.stackArrow{
  position:absolute; z-index:var(--z-tooltip);
  display:none; pointer-events:none;
  padding:6px 10px; border-radius:999px;
  background:rgba(20,33,54,.92); border:1px solid #35527d;
  box-shadow:0 10px 26px rgba(0,0,0,.45);
  transform: translate(-50%,-50%) scale(calc(1 / var(--world-zoom)));
  gap:8px; align-items:center; font-weight:800; color:#e9f2ff;
}
.stackArrow svg{ width:22px; height:22px; display:block; }
.stackArrow.dir-right svg{ transform:rotate(0deg); }
.stackArrow.dir-left  svg{ transform:rotate(180deg); }
.stackArrow.dir-up    svg{ transform:rotate(-90deg); }

/* === Mulligan overlay (top-center prompt) =============================== */
.mulliganOverlay{
  position:fixed; left:50%; top:10px; transform:translateX(-50%);
  z-index: var(--z-overlays);
  display:none; pointer-events:none;
}
.mullPanel{
  pointer-events:auto;
  background:rgba(12,18,28,.98);
  border:1px solid #24324a;
  border-radius:12px;
  padding:10px 12px;
  display:flex; align-items:center; gap:10px;
  box-shadow:0 10px 26px rgba(0,0,0,.45);
  font-weight:800; color:#e9f2ff;
}
.mullPanel .btn{
  background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63;
  border-radius:10px; padding:6px 12px; font-weight:900;
}
.mullPanel .btn:active{ transform:scale(.98); }

/* === Card Settings overlay ============================================= */
#cardSettings.scrim{ display:none; }
.cardSettingsPanel{
  position:absolute; left:50%; top:50%;
  transform:translate(-50%,-50%); width:min(820px,94vw); max-height:80vh; overflow:auto;
  background:rgba(12,18,28,.98); border:1px solid #24324a; border-radius:14px; padding:12px;
}
.cs-header{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px; }
.cs-row{ display:grid; grid-template-columns:140px 1fr; gap:10px; align-items:start; margin-bottom:10px; }
.cs-row .lbl{ color:#9fb4d9; font-weight:800; padding-top:6px; }
.cs-input, .cs-textarea, .cs-chipinput{ width:100%; background:#0a0f16; color:#e7efff; border:1px solid #24324a; border-radius:10px; padding:8px 10px; }
.cs-textarea{ min-height:90px; resize:vertical; }
.cs-chips{ display:flex; gap:6px; flex-wrap:wrap; }
.cs-chip{ background:#1b2a47; border:1px solid #2b3f63; color:#d8e7ff; border-radius:999px; padding:6px 10px; font-weight:800; }
.cs-minirow{ display:flex; gap:8px; align-items:center; margin-bottom:6px; }
.cs-minirow input{ background:#0a0f16; color:#e7efff; border:1px solid #24324a; border-radius:8px; padding:6px 8px; }
.cs-actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
.cs-btn{ background:#1a2a45; color:#cfe1ff; border:1px solid #2b3f63; border-radius:10px; padding:8px 12px; font-weight:900; }
.cs-btn.warn{ background:#2a1730; border-color:#5e2a6a; }

/* Counters list */
.countersWrap{ display:flex; flex-direction:column; gap:6px; }
.counterRow{ display:grid; grid-template-columns:1fr 90px 34px; gap:8px; }
.counterRow input{ background:#0a0f16; color:#e7efff; border:1px solid #24324a; border-radius:8px; padding:6px 8px; }
.counterRow .addBtn, .counterRow .delBtn{
  background:#142136; color:#e9f2ff; border:1px solid #35527d; border-radius:10px; width:34px; height:34px; font-weight:900;
}

/* === Under-card anchor badge =========================================== */
.cardBadge{
  position:absolute; z-index:var(--z-tooltip);
  background:rgba(20,33,54,.92); border:1px solid #35527d; color:#e7f2ff;
  border-radius:10px; padding:6px 8px; display:flex; gap:8px; align-items:center;
  /* baseline boost (multiplies the existing inverse-zoom behavior) */
transform: translate(-50%, 0) scale(calc((1 / var(--world-zoom)) * var(--badgeBoost, 1.35)));

  pointer-events:none;
}
.cardBadge .bchip{
  background:#1b2a47; border:1px solid #2b3f63; border-radius:8px; padding:2px 6px; font-weight:800;
}
.cardBadge .notes{ max-width:260px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; opacity:.9; }

.deck-actions{ pointer-events: none; }         /* wrapper ignores hits */
.deck-actions .sbtn{ pointer-events: auto; }   /* buttons still clickable */

/* Deck Top/Bottom/Shuffle/Cancel popup */
#deckChoice{
  position: fixed;
  z-index: var(--z-overlays);
  transform: translate(-50%, -8px);
}

/* === Player view helpers ============================================== */
.viewing-opponent .hand { display:none; }
.card.hidden-by-view { display:none !important; }

/* Viewing chip (topbar, right side) */
.viewingChip{
  justify-self:end;
  background:#142136;
  color:#e9f2ff;
  border:1px solid #35527d;
  border-radius:10px;
  padding:6px 10px;
  font-weight:800;
  white-space:nowrap;
}

/* === Badge size override: free from card scale === */
.cardBadge {
  transform: none !important;            /* stop inheriting card transform chain */
  transform-origin: top center;
  scale: var(--badgeBoost, 1.8);         /* pure scale multiplier, editable */
  position: fixed !important;            /* no longer nested inside the card box */
  pointer-events: none;
  z-index: var(--z-tooltip);
}

:root{
  --effects-scale: 1;
  --effects-offset-x: 0px;
  --effects-offset-y: 0px;
  --effects-right-safe: 0px;     /* subtracts space from effects row max-width */
  --tooltipBadgeScale: 1.6;
  --tooltip-font-size: 13px;     /* ensure present & global */
  --tooltip-icon-size: 18px;
}

/* Tooltip body text size */
.tt-body, .tooltip .body, .tooltip .content{
  font-size: var(--tooltip-font-size, 13px) !important;
  line-height: 1.25;
}


/* === Flying card (deck → hand) ====================== */
.fly-card{
  position:fixed;
  width:var(--card-w);
  height:var(--card-h);
  border-radius:14px;
  box-shadow:0 10px 26px rgba(0,0,0,.55);
  pointer-events:none;
  will-change:transform, opacity;
  /* start values get set inline; end handled by WAAPI */
}
.fly-card img{
  width:100%; height:100%; object-fit:cover; border-radius:14px;
  display:block;
}

/* Hand wants horizontal gestures; don’t fight it */
#hand { touch-action: pan-x; }

/* Prevent native image dragging/selecting from interfering */
.handCard img {
  -webkit-user-drag: none;
  user-select: none;
}

.card img, .handCard img {
  -webkit-user-drag: none;
  user-select: none;
}


</style>
</head>
<body>

<!-- Top bar -->
<div class="topbar">
  <button class="cog" id="cogBtn">⚙️</button>
  <div class="life-strip">
  <div class="life-tile"><span>P1</span>
    <span>
      <span class="life-main" data-seat="1" data-field="life">40</span>
      <span class="life-cmd"  data-seat="1" data-field="cmd">21</span>
      <span class="life-poison" style="color:#54ff86;font-weight:800" data-seat="1" data-field="poison">0</span>
    </span>
  </div>
  <div class="life-tile"><span>P2</span>
    <span>
      <span class="life-main" data-seat="2" data-field="life">40</span>
      <span class="life-cmd"  data-seat="2" data-field="cmd">21</span>
      <span class="life-poison" style="color:#54ff86;font-weight:800" data-seat="2" data-field="poison">0</span>
    </span>
  </div>
  <div class="life-tile"><span>P3</span>
    <span>
      <span class="life-main" data-seat="3" data-field="life">40</span>
      <span class="life-cmd"  data-seat="3" data-field="cmd">21</span>
      <span class="life-poison" style="color:#54ff86;font-weight:800" data-seat="3" data-field="poison">0</span>
    </span>
  </div>

  <div class="turn-tile"><span>Turn:</span><span><span class="turn-count">1</span></div>
</div>


  <!-- NEW: who you're viewing -->
  <div class="viewingChip" id="viewingChip" role="status" aria-live="polite">Viewing: P1</div>
</div>


<!-- Drawer -->
<div id="drawerWrap" class="drawer-wrap expanded">
  <div class="drawer">
    <div class="row">
      <label class="pill">Players
        <select class="pill" id="playerCount">
          <option>1</option><option selected>2</option><option>3</option>
        </select>
      </label>
      <label class="pill">I am
        <select class="pill" id="mySeat">
          <option>1</option><option selected>2</option><option>3</option>
        </select>
      </label>
      <button class="pill" id="lifeEditBtn">Edit Life</button>
    </div>
    <textarea class="deck-in" id="deckIn" placeholder="Paste your deck list..."></textarea>
    <div class="row">
      <button class="pill" id="loadBtn">Load Deck</button>
      <button class="pill" id="resetBtn" title="Resets THIS player only">Reset (me)</button>
    </div>
    <div class="row">
      <div class="gamePicker" id="gamePicker">
  <button class="gameBtn" id="btnHost">Host</button>
  <button class="gameBtn" id="btnJoin">Join</button>
  <button class="gameBtn" id="btnSave">Save</button>
  <button class="gameBtn" id="btnRestore">Restore</button>
</div>
<div class="row">
  <button class="pill js-ui-settings">⚙ Settings</button>
</div>

    </div>
  </div>
</div>

<!-- Table -->
<div class="table" id="table">
  <div class="worldWrap" id="worldWrap">
    <div class="worldScale" id="worldScale" style="transform:translate(0px,0px) scale(1);">
      <div class="world" id="world">
        <div class="zone" id="deckZone"><div class="label">Deck</div></div>
		<!-- Left-of-deck actions (🔍 ＋ …) -->
<div class="deck-actions" id="deckActions">
  <button class="sbtn" id="deckSearchBtn" title="Search Deck">🔍</button>
  <button class="sbtn" id="deckAddBtn"    title="Add card / token">＋</button>
  <button class="sbtn" id="deckMoreBtn"   title="Deck Tools">…</button>
</div>

        <div class="zone" id="cmdZone"><div class="label">Commander</div></div>
        <div class="zone" id="graveyard"><div class="label">Graveyard</div></div>
        <div class="zone" id="exileZone"><div class="label">Exile</div></div>
      </div>
    </div>
  </div>
</div>

<!-- Hand -->
<div class="hand" id="hand"><div class="handTrack" id="handTrack"></div></div>

<!-- Toolbar -->
<div class="toolbar">
  <button class="fab" id="battleBtn" title="Battle">⚔️</button>
  <button class="fab" id="endTurnBtn" title="End Turn">⏭</button>
  <button class="fab" id="viewEyeBtn" title="View Player">👁</button>
  <button class="fab" id="turnInfoBtn" title="Turn Info" aria-label="Turn Info">
  <svg viewBox="0 0 24 24" fill="none"
       stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
       aria-hidden="true">
    <circle cx="12" cy="12" r="10"></circle>
    <path d="M12 16v-4"></path>
    <path d="M12 8h.01"></path>
  </svg>
</button>

</div>

<!-- Zoom -->
<div class="zoomWrap"><input type="range" id="zoom" min="20" max="200" value="100"/></div>


<!-- Overlays -->
<div class="scrim" id="zoneOverlay">
  <div class="panel">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <strong id="overlayTitle">Zone</strong>
      <button class="pill" id="overlayClose">Close</button>
    </div>
    <div class="zoneGrid" id="overlayGrid"></div>
  </div>
</div>

<div class="deckChoice" id="deckChoice" style="display:none; left:0; top:0;">
  <button class="pill" data-choice="top">Top</button>
  <button class="pill" data-choice="bottom">Bottom</button>
  <button class="pill" data-choice="shuffle">Shuffle</button>
  <button class="pill" data-choice="cancel">Cancel</button>
</div>


<!-- Card Settings (⚙️) -->
<div class="scrim" id="cardSettings">
  <div class="cardSettingsPanel">
    <div class="cs-header">
      <strong id="csTitle">Card Settings</strong>
      <button class="cs-btn" id="csClose">Close</button>
    </div>

    <div class="cs-row">
      <div class="lbl">Additional Types</div>
      <div>
        <div class="cs-chips" id="csTypesChips"></div>
        <input class="cs-input" id="csTypesInput" placeholder="Type a type and press Enter (e.g., Wizard)" />
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Additional Effects</div>
      <div>
        <div class="cs-chips" id="csEffectsChips"></div>
        <input class="cs-input" id="csEffectsInput" placeholder="Type an effect and press Enter (e.g., Vigilance)" />
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Chosen Type</div>
      <input class="cs-input" id="csChosenType" placeholder="e.g., Angel, Wizard, Beast..." />
    </div>

    <div class="cs-row">
      <div class="lbl">P/T Mod</div>
      <div class="cs-minirow">
        <label>Power ± <input type="number" id="csPowMod" style="width:80px" value="0"></label>
        <label>Toughness ± <input type="number" id="csTghMod" style="width:80px" value="0"></label>
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Counters</div>
      <div>
        <div class="countersWrap" id="csCounters"></div>
        <div class="counterRow">
          <input id="csNewCounterName" placeholder="counter name (e.g., +1/+1)" />
          <input id="csNewCounterQty" type="number" placeholder="qty" value="1" />
          <button class="addBtn" id="csAddCounter">＋</button>
        </div>
      </div>
    </div>

    <div class="cs-row">
      <div class="lbl">Notes</div>
      <textarea class="cs-textarea" id="csNotes" placeholder="Anything else..."></textarea>
    </div>

    <div class="cs-actions">
      <button class="cs-btn warn" id="csClear">Clear</button>
      <button class="cs-btn" id="csSave">Save</button>
    </div>
  </div>
</div>


<!-- Connecting overlay -->
<div class="scrim" id="connectingScrim" style="display:none;">
  <div class="panel" style="text-align:center">
    <div id="connectingText" style="font-weight:800;">Establishing connection<span id="connectingDots">.</span></div>
  </div>
</div>


<!-- Mulligan overlay (friendly: always draw 7 again) -->
<div class="mulliganOverlay" id="mulliganOverlay">
  <div class="mullPanel">
    <span>Mulligan?</span>
    <button class="btn" id="mullYesBtn">Yes</button>
    <button class="btn" id="mullNoBtn">No</button>
  </div>
</div>

<!-- put this early in the page -->
<!-- put this BEFORE any scripts that use StorageAPI -->
<script type="module" src="./modules/card.attributes.js"></script>
<script type="module" src="./modules/env.supabase.js"></script>

<script type="module" src="./modules/save.snap.js"></script>
<script type="module" src="./modules/save.snap.attributes.patch.js"></script>

<script type="module" src="./modules/tooltip.js"></script>
<script type="module" src="./modules/tooltip.cog.patch.js"></script>
<script type="module" src="./modules/tooltip.activate.patch.js"></script>

<script type="module" src="./modules/battle.ui.js"></script>


<script type="module"> 
// NEW: networking + saves
import { createPeerRoom } from './modules/net.rtc.js';
import { initTooltipSystem, attachTooltip, followTooltip, reflowAll, showCardTooltip, hideCardTooltip, clearSelection, attachHandAutoTooltip } from './modules/tooltip.js';
import {
  saveAutoSnapshot, listAutoSaves, pruneAutoSaves, loadAutoSnapshot,
  getSlots, saveToSlot, loadSlot
} from './modules/save.snap.js';

import Overlays from './modules/overlays.js';
import { initTurnUpkeep } from './modules/turn.upkeep.js';

  import UIConstants from './modules/ui.constants.js';
  UIConstants.apply();

  import Zones from './modules/zones.js';
window.Zones = Zones;


import {
  saveSnapshot,
  listSnapshots,
  loadSnapshot,
  getLatestSnapshotForSeat
} from './modules/save.snap.js';

import { saveSession, loadSession, clearSession, markAskRestoreNext, shouldAskRestoreNext } from './modules/session.memory.js';

// More forgiving thresholds on touch
// Touch capability
const IS_TOUCH = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

const MOVE_TOL       = IS_TOUCH ? 12 : 6;    // was 6
const TAP_MS         = IS_TOUCH ? 550 : 300; // was 300
const DBL_TAP_SLOP_PX= IS_TOUCH ? 44 : 16;   // spatial leeway between taps

// ====== helpers ======
const $  = (s, r=document) => r.querySelector(s);
const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

// core nodes (IDs exactly from your HTML)
const worldWrap   = $('#worldWrap');
const worldScale  = $('#worldScale');
const world       = $('#world');
const handEl      = $('#hand');
const handTrack   = $('#handTrack');
const deckZone    = $('#deckZone');
const deckIn      = $('#deckIn');
const loadBtn     = $('#loadBtn');
const resetBtn    = $('#resetBtn'); // decorative; no-op as requested
const zoomWrapEl = document.querySelector('.zoomWrap');

const viewEyeBtn = document.getElementById('viewEyeBtn');
const mySeat = () => parseInt(seatSelect.value, 10) || 1;

const viewingChip = document.getElementById('viewingChip');


document.querySelector('.js-ui-settings')?.addEventListener('click', () => {
  document.querySelector('.drawer-wrap')?.classList.remove('expanded');
  UIConstants.openSettingsOverlay();
});

// Kill native image drag for our cards/hand (prevents ghost-copy cursor)
document.addEventListener('dragstart', (e) => {
  if (e.target.closest('.card, .handCard')) e.preventDefault();
}, true);


// --- Connecting overlay helpers (non-blocking) ---
const connectingScrim = document.getElementById('connectingScrim');
const connectingText  = document.getElementById('connectingText');
const connectingDots  = document.getElementById('connectingDots');
let _dotsTimer = null;

let AUTOSAVE_TIMER = null;

function startAutoSaver(){
  stopAutoSaver();
  if (!ROOM_ID) return;
  const seat = mySeat();
  AUTOSAVE_TIMER = setInterval(async ()=>{
    try{
      await saveAutoSnapshot({ roomId: ROOM_ID, bySeat: seat });
      // keep only the last 3 minutes worth
      await pruneAutoSaves({ roomId: ROOM_ID, bySeat: seat, maxAgeMs: 3*60*1000 });
      console.log('[autosave] ok');
    }catch(e){
      console.warn('[autosave] failed', e?.message || e);
    }
  }, 60 * 1000);
}

function stopAutoSaver(){
  if (AUTOSAVE_TIMER){ clearInterval(AUTOSAVE_TIMER); AUTOSAVE_TIMER = null; }
}


function showConnecting(msg = 'Establishing connection'){
  if (connectingText) connectingText.firstChild.nodeValue = msg;
  if (connectingScrim) connectingScrim.style.display = 'block';
  // animated ellipsis: ".", "..", "..."
  if (connectingDots){
    let n = 1;
    connectingDots.textContent = '.';
    _dotsTimer = setInterval(()=>{
      n = (n % 3) + 1;
      connectingDots.textContent = '.'.repeat(n);
    }, 450);
  }
}

function hideConnecting(){
  if (_dotsTimer){ clearInterval(_dotsTimer); _dotsTimer = null; }
  if (connectingScrim) connectingScrim.style.display = 'none';
}


// === Host/Join/Save/Restore ===
const btnHost    = document.getElementById('btnHost');
const btnJoin    = document.getElementById('btnJoin');
const btnSave    = document.getElementById('btnSave');
const btnRestore = document.getElementById('btnRestore');

let RTC = null;  // { send(), close(), role, seatOk, ... }
let ROOM_ID = ''; // we’ll prompt once and reuse
const seatSelect = document.getElementById('mySeat');
seatSelect.addEventListener('change', () => {
  window.CardAttributes?.init({ roomId: ROOM_ID, seat: mySeat() });
});

let currentViewSeat = mySeat();

function updateViewingChip(){
  if (viewingChip) viewingChip.textContent = `Viewing: P${currentViewSeat}`;
}

// Rejoin prompt modal (theme-matched, mobile-friendly)
const RejoinPrompt = {
  show({ roomId, role, seat }){
    return new Promise(resolve => {
      const close = (val) => {
        cleanup();
        resolve(val);
      };

      const el = document.createElement('div');
      el.className = 'rejoin-backdrop';
      el.innerHTML = `
        <div class="rejoin-card" role="dialog" aria-modal="true" aria-labelledby="rejoin-title">
          <div class="rejoin-head">
            <div class="rejoin-dot" aria-hidden="true"></div>
            <div id="rejoin-title" class="rejoin-title">Rejoin last session?</div>
          </div>
          <div class="rejoin-body">
            <div class="rejoin-row"><div class="rejoin-key">Room</div><div class="rejoin-val">${roomId}</div></div>
            <div class="rejoin-row"><div class="rejoin-key">Role</div><div class="rejoin-val">${String(role).toUpperCase()}</div></div>
            <div class="rejoin-row"><div class="rejoin-key">Seat</div><div class="rejoin-val">P${seat}</div></div>
          </div>
          <div class="rejoin-cta">
            <button class="btn" data-act="cancel" type="button">Cancel</button>
            <button class="btn btn-primary" data-act="ok" type="button">Rejoin</button>
          </div>
        </div>
      `.trim();

      // events
      const onClick = (e) => {
        const act = e.target?.getAttribute?.('data-act');
        if (act === 'ok') close(true);
        if (act === 'cancel') close(false);
        if (e.target === el) close(false); // click outside to dismiss
      };
      const onKey = (e) => {
        if (e.key === 'Escape') close(false);
        if (e.key === 'Enter') close(true);
      };

      function cleanup(){
        el.removeEventListener('click', onClick);
        document.removeEventListener('keydown', onKey, true);
        el.remove();
      }

      el.addEventListener('click', onClick);
      document.addEventListener('keydown', onKey, true);
      document.body.appendChild(el);

      // initial focus to primary button for quick “Enter”
      el.querySelector('[data-act="ok"]')?.focus();
    });
  }
};

// --- Auto reapply last session on load ---
(async function tryReapplyLastSession(){
  const last = loadSession();
  if (!last) return;

  // Ensure modal styles are present (once)
  (function ensureRejoinStyles(){
    if (document.getElementById('rejoin-style')) return;
    const s = document.createElement('style');
    s.id = 'rejoin-style';
    s.textContent = `
      .rejoin-backdrop{
        position:fixed; inset:0; z-index:9999;
        background:rgba(8,12,18,0.6); backdrop-filter: blur(6px);
        display:grid; place-items:center;
      }
      .rejoin-card{
        width: min(520px, 92vw);
        border-radius:16px;
        background: linear-gradient(180deg, #10141b, #0c1117);
        border:1px solid #24324a;
        box-shadow: 0 10px 40px rgba(0,0,0,0.45);
        color: var(--fg);
        font: 500 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
        overflow: hidden;
      }
      .rejoin-head{
        padding:16px 18px;
        border-bottom:1px solid #212a3a;
        display:flex; align-items:center; gap:10px;
      }
      .rejoin-dot{
        width:10px; height:10px; border-radius:50%;
        background: var(--ok, #42d392); box-shadow: 0 0 12px rgba(66,211,146,0.6);
      }
      .rejoin-title{ font-size:16px; font-weight:700; letter-spacing:.2px; }
      .rejoin-body{
        padding:18px;
        color: var(--muted);
      }
      .rejoin-row{ display:flex; align-items:center; gap:10px; margin:6px 0; }
      .rejoin-key{
        min-width:72px; color:#8fa1c1; font-weight:600; text-transform:uppercase; font-size:11px; letter-spacing:.6px;
      }
      .rejoin-val{ color: var(--fg); font-weight:600; }
      .rejoin-cta{
        display:flex; gap:10px; justify-content:flex-end;
        padding:16px 18px; border-top:1px solid #212a3a; background:#0c1117;
      }
      .btn{
        appearance:none; border:1px solid #24324a; background:#111826; color:var(--fg);
        border-radius:12px; padding:10px 14px; font-weight:700; letter-spacing:.3px; cursor:pointer;
        transition: transform .04s ease, border-color .15s ease, background .15s ease;
      }
      .btn:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }
      .btn:hover{ border-color:#32425c; background:#0f1520; }
      .btn:active{ transform: translateY(1px); }
      .btn-primary{
        border-color: color-mix(in srgb, var(--accent), #000 35%);
        background: linear-gradient(180deg, color-mix(in srgb, var(--accent), #000 75%), color-mix(in srgb, var(--accent), #000 82%));
      }
      .btn-primary:hover{
        border-color: var(--accent);
        background: linear-gradient(180deg, color-mix(in srgb, var(--accent), #000 65%), color-mix(in srgb, var(--accent), #000 75%));
      }
    `;
    document.head.appendChild(s);
  })();

  const { roomId, role, seat } = last;
  const ok = await RejoinPrompt.show({ roomId, role, seat });
  if (!ok) return;

  // set UI + internal state to match
  try { seatSelect.value = String(seat); } catch {}
  // NEW → immediately view the restored seat
  currentViewSeat = Number(seat);
  applyViewFilter();

  ROOM_ID = roomId;
  window.CardAttributes?.init({ roomId: ROOM_ID, seat: mySeat() });
  window.BattleUI?.init({ roomId: ROOM_ID, seat: mySeat() });

  markAskRestoreNext(true); // silent auto-restore happens later, no extra popup
  startRTC(role);

})();





// === Selection & tooltip helpers =========================================


function selectCard(el, sx = null, sy = null){
  clearSelection();              // from tooltip.js (also hides any open tip)
  el.classList.add('selected');  // cyan outline (your CSS)

  // If we were called with screen coords (e.g., pointerdown), open the tip now
  if (sx != null && sy != null) {
    showCardTooltip(el, sx, sy);
  }
  // Anchor/keep-following to left of the card
  followTooltip(el);
}





// ====== camera (V2 behavior) ======
// ====== camera (pan/zoom) ======
const Z_MIN = 0.2;   // was 0.5
const Z_MAX = 3.0;   // was 2.5

// camera state
const cam = { x:0, y:0, z:1 };

function applyCam(){
  worldScale.style.transform = `translate(${cam.x}px,${cam.y}px) scale(${cam.z})`;
  document.documentElement.style.setProperty('--world-zoom', String(cam.z));

  const sel = world.querySelector('.card.selected');
  if (sel) {
    followTooltip(sel);
  } else {
    reflowAll();
  }
  // NEW: keep the slider in sync with camera zoom
  syncZoomUI();
}
// ===== Zoom slider wiring =====
const zoomEl = document.getElementById('zoom');

function syncZoomUI(){
  if (!zoomEl) return;
  // Match slider range to our Z_MIN..Z_MAX (e.g. 0.2 ↔ 20, 3.0 ↔ 300)
  const min = Math.round(Z_MIN * 100);
  const max = Math.round(Z_MAX * 100);
  if (zoomEl.min !== String(min)) zoomEl.min = String(min);
  if (zoomEl.max !== String(max)) zoomEl.max = String(max);

  const val = Math.round(cam.z * 100);
  if (zoomEl.value !== String(val)) zoomEl.value = String(val);
}

// Dragging the slider zooms toward the viewport center
zoomEl?.addEventListener('input', (e) => {
  const v = Number(e.target.value) || 100;
  const z = v / 100;
  const vr = worldWrap.getBoundingClientRect();
  const cx = vr.left + vr.width / 2;
  const cy = vr.top  + vr.height / 2;
  setZoom(z, cx, cy);
});



applyCam();

// ——— Pan (empty felt only; ignore cards & hand strip) ———
let panning=false, baseX=0, baseY=0, startX=0, startY=0;


worldWrap.addEventListener('pointerdown', (e)=>{
  // 1) battlefield card? let card drag handle it
  if (e.target.closest('#world .card')) return;

  // 2) zones? don't pan; let their click handlers fire
  if (e.target.closest('#deckZone, #graveyard, #exileZone, #cmdZone, [data-zone]')) return;

  // 3) hand? let HandScrub own it
  const topEl = document.elementFromPoint(e.clientX, e.clientY);
  if (topEl && topEl.closest('.handCard')) return;

  // 🔹 If a pinch is in progress, do NOT start panning
  if (isPinching) return;

  // NEW: background tap starts → clear any selected card + hide tooltip
  clearSelection();
  hideCardTooltip();

  // Allow panning, even if pointer Y is inside the hand strip region
  panning = true;
  baseX=cam.x; baseY=cam.y; startX=e.clientX; startY=e.clientY;
  worldWrap.classList.add('panning');
  worldWrap.setPointerCapture?.(e.pointerId);
}, {passive:true});

// === Enable desktop dragging for cards (mouse + touch unified) ===
// Only drag CARDS ON THE TABLE (inside #world), never the hand.
document.addEventListener('pointerdown', e => {
  // If the pointer started in the hand strip, let HandScrub own it.
  if (e.target.closest('#hand') || e.target.closest('.handCard')) return;

  // Only allow dragging for battlefield cards
  const card = e.target.closest('#world .card');
  if (!card) return;

  e.preventDefault();
  const start = { x: e.clientX, y: e.clientY };
  const orig = {
    left: parseFloat(card.style.left || 0),
    top:  parseFloat(card.style.top  || 0)
  };
  card.setPointerCapture?.(e.pointerId);

  const move = ev => {
    const dx = ev.clientX - start.x;
    const dy = ev.clientY - start.y;
    card.style.left = `${orig.left + dx / cam.z}px`;
    card.style.top  = `${orig.top  + dy / cam.z}px`;
  };

  const up = () => {
    card.releasePointerCapture?.(e.pointerId);
    document.removeEventListener('pointermove', move);
    document.removeEventListener('pointerup', up);
    document.removeEventListener('pointercancel', up);
    if (window.Zones?.handleDrop) Zones.handleDrop(card);
  };

  document.addEventListener('pointermove', move, { passive: false });
  document.addEventListener('pointerup', up, { passive: true });
  document.addEventListener('pointercancel', up, { passive: true });
}, { passive: false });




worldWrap.addEventListener('pointermove', e=>{
  if (!panning || isPinching) return;  // 🔹 block pan during pinch
  cam.x = baseX + (e.clientX - startX);
  cam.y = baseY + (e.clientY - startY);
  applyCam();
},{passive:false});


const endPan = () => { panning=false; worldWrap.classList.remove('panning'); };
worldWrap.addEventListener('pointerup', endPan);
worldWrap.addEventListener('pointercancel', endPan);


// ——— Pinch-to-zoom (two fingers) ———
const activePtrs = new Map();
let pinchPrevD = 0;
let isPinching = false;   // 🔹 NEW: gate panning while true



worldWrap.addEventListener('pointerdown', (e)=>{
  activePtrs.set(e.pointerId, { x:e.clientX, y:e.clientY });
}, {passive:true});

worldWrap.addEventListener('pointermove', (e)=>{
  if (!activePtrs.has(e.pointerId)) return;
  activePtrs.set(e.pointerId, { x:e.clientX, y:e.clientY });

  if (activePtrs.size !== 2) return;

  isPinching = true;          // 🔹 now actively pinching → disable pan
  e.preventDefault();

  const pts = [...activePtrs.values()];
  const midX = (pts[0].x + pts[1].x) / 2;
  const midY = (pts[0].y + pts[1].y) / 2;

  // distance between fingers in screen space
  const d = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);

  // On the first frame of a pinch, initialize previous distance
  if (!pinchPrevD) {
    pinchPrevD = d;
    return;
  }

  // Compute world point under the CURRENT midpoint BEFORE changing zoom
  const rect = worldScale.getBoundingClientRect();
  const mx = midX - rect.left;
  const my = midY - rect.top;
  const wx = (mx - cam.x) / cam.z;
  const wy = (my - cam.y) / cam.z;

  // Scale factor since last event (frame-to-frame, avoids jumpiness)
  const step = d / pinchPrevD;
  const newZ = Math.max(Z_MIN, Math.min(Z_MAX, cam.z * step));

  // Keep that same world point anchored under the moving midpoint
  cam.z = newZ;
  cam.x = mx - wx * cam.z;
  cam.y = my - wy * cam.z;

  pinchPrevD = d;
  applyCam();
}, {passive:false});


function endPtr(e){
  activePtrs.delete(e.pointerId);
  if (activePtrs.size < 2) {
    pinchPrevD = 0;
    isPinching = false;   // 🔹 pinch ended → allow panning again
  }
}
worldWrap.addEventListener('pointerup', endPtr, {passive:true});
worldWrap.addEventListener('pointercancel', endPtr, {passive:true});



// ——— Wheel zoom anchored at cursor (desktop) ———
worldWrap.addEventListener('wheel', (e)=>{
  if (e.ctrlKey) return;            // allow browser zoom when Ctrl/⌘ held
  e.preventDefault();

  // cursor position in screen space
  const rect = worldScale.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // convert to world coords (pre-zoom)
  const wx = (mx - cam.x) / cam.z;
  const wy = (my - cam.y) / cam.z;

  // scale step (handles line vs pixel deltas)
  const step = Math.pow(1.0015, -e.deltaY * (e.deltaMode===1 ? 12 : 1));
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const newZ = clamp(cam.z * step, Z_MIN, Z_MAX);

  // keep cursor anchored
  cam.z = newZ;
  cam.x = mx - wx * cam.z;
  cam.y = my - wy * cam.z;

  applyCam();
},{passive:false});

initTooltipSystem({
  world,
  getCam: () => cam,
  screenToWorld,
});
attachHandAutoTooltip(document.querySelector('#hand'));

Overlays.init();

  Zones.init({
    zones: {
      graveyard: document.getElementById('graveyard'),
      exile:     document.getElementById('exileZone'),
      deck:      document.getElementById('deckZone'),
      hand:      document.getElementById('hand'),
      cmd:       document.getElementById('cmdZone')
    },
    worldEl: document.getElementById('world'),
    screenToWorld, // used for snapping to commander zone center


  // Wire these to your v3 helpers:
  spawnToTable: (card, seat) => {
  const vr = worldWrap.getBoundingClientRect();
  const cx = vr.left + vr.width / 2;
  const cy = vr.top  + vr.height * 0.45;
  const { x, y } = screenToWorld(cx, cy);

  const cid = card.id || card.cid || (crypto?.randomUUID?.() || String(Math.random())).slice(0,12);
  if (typeof rememberCid === 'function') rememberCid(cid, card);

  // Create the card element
  spawnTableCard({ name: card.name || '', img: card.img || '' }, x, y, { owner: seat, cid });

  // Immediately stamp base stats + innate on the new DOM node so PT() works
  try {
    const el = document.querySelector(`.card[data-cid="${CSS.escape(String(cid))}"]`);
    if (el) {
      if (card.baseP != null) el.dataset.baseP = String(card.baseP);
      if (card.baseT != null) el.dataset.baseT = String(card.baseT);
      if (Array.isArray(card.ogEffects)) el.dataset.ogEffects = JSON.stringify(card.ogEffects);
      if (Array.isArray(card.ogTypes))   el.dataset.ogTypes   = JSON.stringify(card.ogTypes);
      // also keep the owner stamp consistent if provided
      if (!el.dataset.owner && seat != null) el.dataset.owner = String(seat);
    }
  } catch {}
},

  addToHand: (card, seat) => window.addToHand?.(card, seat),
  addToDeck: (card, seat, options) => window.addToDeck?.(card, seat, options),
  shuffleDeck: (seat) => window.shuffleDeck?.(seat),
  removeTableCardDomById: (cid) => {
  const el = document.querySelector(`.card[data-cid="${CSS.escape(String(cid))}"]`);
  if (!el) return;

  // If this card is currently selected / showing a tooltip, clear it now
  try {
    if (el.classList.contains('selected')) {
      // these are imported at top of v3.html from ./modules/tooltip.js
      clearSelection?.();
      hideCardTooltip?.();
    }
  } catch {}

  // Remove the element from the battlefield
  try { el.remove(); } catch {}
},

  getCardDataById: (cid) => window.getCardDataById?.(cid),

  onMoved: ({ seat, cid, from, to, position }) => {
  // Broadcast meta so peers update their zone state
  sendRTC({ type: 'zones:move', seat, cid, from, to, position });
}

});




function afterYouCreateCardEl(cardEl, meta){
  // Ensure CID exists ASAP
  if (meta?.cid && !cardEl.dataset.cid) cardEl.dataset.cid = String(meta.cid);

  // 🔹 Stamp base P/T so the attributes overlay can combine immediately
  // meta.card should be your scryfall-ish object with power/toughness (strings like "2", "3", "*", etc.)
  if (meta?.card) {
    const p = meta.card.power, t = meta.card.toughness;
    if (p != null) cardEl.dataset.baseP = String(p);
    if (t != null) cardEl.dataset.baseT = String(t);
  }

  Zones.registerDraggableCard(cardEl);
}





// ——— Utilities & public API (optional, handy later) ———
function screenToWorld(sx, sy){
  const r = worldScale.getBoundingClientRect();
  return { x: (sx - r.left - cam.x)/cam.z, y: (sy - r.top - cam.y)/cam.z };
}
function worldToScreen(wx, wy){
  const r = worldScale.getBoundingClientRect();
  return { x: r.left + cam.x + wx*cam.z, y: r.top + cam.y + wy*cam.z };
}
function centerOn(wx, wy){
  const vr = worldWrap.getBoundingClientRect();
  cam.x = vr.width/2  - wx*cam.z;
  cam.y = vr.height*0.45 - wy*cam.z; // slight lift so hand doesn’t cover
  applyCam();
}
function setZoom(z, anchorScreenX = null, anchorScreenY = null){
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  z = clamp(z, Z_MIN, Z_MAX);
  if (anchorScreenX!=null && anchorScreenY!=null){
    const { x:wx, y:wy } = screenToWorld(anchorScreenX, anchorScreenY);
    cam.z = z;
    // re-anchor at the same screen spot
    cam.x = anchorScreenX - wx*cam.z - worldScale.getBoundingClientRect().left;
    cam.y = anchorScreenY - wy*cam.z - worldScale.getBoundingClientRect().top;
  } else {
    cam.z = z;
  }
  applyCam();
}

// expose for other modules (optional)
window.Camera = { cam, applyCam, screenToWorld, worldToScreen, centerOn, setZoom };


// ====== deck / hand (V2 fan, minimal features) ======
// === GameIO adapter (Save/Restore uses this) ===
window.GameIO = {
  collectState(){
    // 1) battlefield cards (DOM-based)
    const toNum = (v) => {
  const n = Number(v);
  return Number.isFinite(n) ? n : undefined;
};

const table = Array.from(world.querySelectorAll('.card')).map(el => ({
  name:  el.dataset?.name || '',
  img:   el.querySelector('img')?.src || '',
  x:     parseFloat(el.style.left) || 0,
  y:     parseFloat(el.style.top)  || 0,
  tapped: el.classList.contains('tapped') || false,
  owner: parseInt(el.dataset.owner || '0', 10) || 1,
  cid:   el.dataset.cid || '',

  ogpower:     toNum(el.dataset.baseP),
  ogtoughness: toNum(el.dataset.baseT),
  ogloyalty:   toNum(el.dataset.baseL),

  // NEW: OG types/effects (read from dataset if present)
  ogTypes:   (()=>{ try{ return JSON.parse(el.dataset.ogTypes||'[]') }catch{ return [] } })(),
  ogEffects: (()=>{ try{ return JSON.parse(el.dataset.ogEffects||'[]') }catch{ return [] } })()
}));



    // 2) zones (graveyard/exile/hand/deck/table) per seat
    const zones = {};
    const norm = (st)=>({
      table:     Array.isArray(st?.table)     ? st.table     : [],
      graveyard: Array.isArray(st?.graveyard) ? st.graveyard : [],
      exile:     Array.isArray(st?.exile)     ? st.exile     : [],
      hand:      Array.isArray(st?.hand)      ? st.hand      : [],
      deck:      Array.isArray(st?.deck)      ? st.deck      : [],
    });

    try {
  const Z = (typeof Zones !== 'undefined' && Zones) || (window && window.Zones);
  if (Z) {
    if (typeof Z.exportState === 'function') {
      const all = Z.exportState();                         // { [seat]: {table,graveyard,exile,hand,deck} }
      for (const [seat, st] of Object.entries(all || {})) zones[seat] = norm(st);
    } else if (Z.zoneState instanceof Map) {
      for (const [seat, st] of Z.zoneState.entries())      zones[seat] = norm(st);
    } else if (Z.zoneState && typeof Z.zoneState === 'object') {
      for (const seat of Object.keys(Z.zoneState))         zones[seat] = norm(Z.zoneState[seat]);
    }
  }
} catch (e) {
  console.warn('[save] zones snapshot failed:', e);
}


    // 3) hand/deck come from local arrays
    //    (top-of-deck is END of the array per your draw())
    return { deck, hand, table, zones, life: window.Life?.state || {} };

  },

  // ⬇ only apply keys that are present; leave others alone
  applyState(state = {}){
    try{
      if ('deck' in state) deck = Array.isArray(state.deck) ? state.deck : [];
      if ('hand' in state) hand = Array.isArray(state.hand) ? state.hand : [];

      if ('table' in state) {
        world.querySelectorAll('.card').forEach(n => n.remove());
        for (const c of (state.table || [])) {
          const x = Number(c.x)||0, y = Number(c.y)||0;
          spawnTableCard({
  name: c.name || '',
  img:  c.img  || '',
  power:       c.power,
  toughness:   c.toughness,
  loyalty:     c.loyalty,
  type_line:   c.type_line,

  ogpower:     c.ogpower,
  ogtoughness: c.ogtoughness,
  ogloyalty:   c.ogloyalty,

  // NEW:
  ogTypes:     Array.isArray(c.ogTypes) ? c.ogTypes : [],
  ogEffects:   Array.isArray(c.ogEffects) ? c.ogEffects : []
}, x, y, {
  owner: c.owner ?? 1,
  cid:   c.cid   || (crypto?.randomUUID?.() || String(Math.random())).slice(0,12)
});

          if (c.tapped) world.lastChild?.classList.add('tapped');
        }
      }

      // ✅ restore zones for each seat, if provided
      if (state.zones && window.Zones && typeof Zones.restoreFromState === 'function') {
        for (const [seatStr, st] of Object.entries(state.zones)) {
          const seat = Number(seatStr) || 1;
          Zones.restoreFromState(seat, st);
        }
      }
if (state.life) { window.Life?.load(state.life); }

      renderHand();
      applyViewFilter();


    }catch(e){ console.warn('applyState error', e); }
  }
};




function sendRTC(msg){
  if (!RTC) { console.log('[NET] no RTC yet, drop', msg); return false; }
  const ok = RTC.send(msg);
  if (!ok) console.log('[NET] send dropped (channel not open yet)', msg);
  else     console.log('[NET] sent', msg.type, msg);
  return ok;
}

// ===== Life model (life, commander life, poison) =========================
const DEFAULT_LIFE = { life: 40, cmd: 21, poison: 0 }; // EDH defaults + poison shown; adjust cmd if you prefer 20
window.Life = {
  state: { 1:{...DEFAULT_LIFE}, 2:{...DEFAULT_LIFE}, 3:{...DEFAULT_LIFE} },

  get(seat){ seat = Number(seat)||1; return this.state[seat] || (this.state[seat] = {...DEFAULT_LIFE}); },
  set(seat, patch){
    seat = Number(seat)||1;
    this.state[seat] = { ...this.get(seat), ...patch };
    renderLifeStrip();
    // broadcast to peers
    sendRTC({ type:'life:update', seat, life: this.state[seat] });
  },
  load(all){ if (!all || typeof all !== 'object') return;
    for (const s of [1,2,3]) if (all[s]) this.state[s] = { ...DEFAULT_LIFE, ...all[s] };
    renderLifeStrip();
  }
};

// right under window.Life = { ... }
window.Life.setSilent = function(seat, patch){
  seat = Number(seat)||1;
  this.state[seat] = { ...this.get(seat), ...patch };
  renderLifeStrip();                 // update UI, but DON'T send to peers
};


function renderLifeStrip(){
  document.querySelectorAll('[data-seat][data-field]').forEach(span=>{
    const seat  = Number(span.dataset.seat);
    const field = span.dataset.field;
    const v = window.Life.get(seat)[field];
    span.textContent = String(v ?? '');
  });
}

renderLifeStrip();

// quick editor (reuses your overlay look)
document.getElementById('lifeEditBtn')?.addEventListener('click', ()=>{
  const seat = mySeat();
  const cur  = Life.get(seat);
  const scrim = document.createElement('div');
  scrim.className = 'scrim';
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.innerHTML = `
    <div class="row" style="justify-content:space-between;align-items:center">
      <strong>Edit Life — P${seat}</strong>
      <button class="pill js-close">Close</button>
    </div>
    <div class="row" style="gap:10px;margin-top:8px">
      <label class="pill">Life <input id="lifeLife" type="number" style="width:80px" value="${cur.life}"></label>
      <label class="pill">Cmd  <input id="lifeCmd"  type="number" style="width:80px" value="${cur.cmd}"></label>
      <label class="pill">Poison <input id="lifePoison" type="number" style="width:80px" value="${cur.poison}"></label>
      <button class="pill" id="lifeSave">Save</button>
    </div>`;
  scrim.appendChild(panel);
  document.body.appendChild(scrim);
  scrim.style.display = 'block';
  const close = ()=>{ try{document.body.removeChild(scrim);}catch{} };
  panel.querySelector('.js-close').onclick = close;
  scrim.onclick = (e)=>{ if (e.target===scrim) close(); };
  panel.querySelector('#lifeSave').onclick = ()=>{
    Life.set(seat, {
      life:   Number(panel.querySelector('#lifeLife').value),
      cmd:    Number(panel.querySelector('#lifeCmd').value),
      poison: Number(panel.querySelector('#lifePoison').value)
    });
    close();
  };
});

// receive life updates from peers
function applyLifeFromPeer(seat, lifeObj){ window.Life.setSilent(seat, lifeObj || {}); }


function promptRoomId() {
  let id = ROOM_ID || (prompt('Enter room code (e.g. ABC123):', ROOM_ID || '') || '').trim().toUpperCase();
  ROOM_ID = id;
window.CardAttributes?.init({ roomId: ROOM_ID, seat: mySeat() });   // ← add this

  if (!id) return null;
  ROOM_ID = id;
  startAutoSaver();               // ← start autosave whenever a room is chosen
  return id;
}


function seatNum() {
  return parseInt(seatSelect.value, 10) || 1;
}

// Seat conflict handler → offer auto-swap to next free seat
function onSeatConflict({ seatTaken, options }) {
  const next = options[0];
  if (!next) { alert(`Seat ${seatTaken} is already taken. No free seats.`); return; }
  const ok = confirm(`Seat ${seatTaken} is taken. Switch to seat ${next}?`);
  if (ok) { seatSelect.value = String(next); alert(`Switched to seat ${next}. Click Host/Join again.`); }
}



async function startRTC(role) {
  const id = promptRoomId(); if (!id) return;

  // NEW: non-blocking connecting overlay
  showConnecting(role === 'host' ? 'Establishing host link' : 'Establishing connection');

  // persist session intent
  saveSession({ roomId: id, role, seat: seatNum() });

  if (RTC) { try{ await RTC.close(); }catch{} RTC = null; }
  RTC = await createPeerRoom({
    roomId: id,
    role,
    seat: seatNum(),
    onMessage: handlePeerMessage,
    onSeatConflict
  });

  // expose + when datachannel/ICE is live
  window.RTC = RTC;
  RTC.opened.then(async () => {
    console.log('[APP] P2P LINK LIVE (datachannel open, ICE connected)');

    // Fade out overlay shortly after link is live
    setTimeout(hideConnecting, 600);
currentViewSeat = seatNum();
applyViewFilter();

// close drawer the same way the cog does (only if it's open)
if (drawerWrap.classList.contains('expanded')) cogBtn.click();

	

// Only on “auto reapply” flows, silently try to restore the last save for *this* seat
if (shouldAskRestoreNext()) {
  markAskRestoreNext(false);
  try {
    const latest = await getLatestSnapshotForSeat({ roomId: id, seat: seatNum() });
    if (latest) {
      await loadSnapshot({ id: latest.id }); // local full restore
      if (RTC) {
        const { table } = window.GameIO.collectState();
        RTC.send({ type:'state:table', table }); // broadcast only table
      }
    }
    // If no latest, do nothing (no warning popup)
  } catch (e) {
    console.warn('Auto-restore failed', e); // no alert
  }
}

  });

  console.log('[RTC] ready as', role, 'seat', seatNum(), 'room', id);
  // REMOVED: blocking alert for “Hosting/Joined room …”
}



// Example messages we’ll handle now: sync spawn/move, and full restore
function handlePeerMessage(msg){
  if (!msg || typeof msg !== 'object') return;
  switch (msg.type) {
    case 'spawn':
  spawnTableCard({
    name: msg.name || '',
    img:  msg.img,
    ogpower:     Number.isFinite(msg?.ogpower)     ? msg.ogpower     : undefined,
    ogtoughness: Number.isFinite(msg?.ogtoughness) ? msg.ogtoughness : undefined,
    ogloyalty:   Number.isFinite(msg?.ogloyalty)   ? msg.ogloyalty   : undefined,

    // NEW:
    ogTypes:   Array.isArray(msg?.ogTypes)   ? msg.ogTypes   : [],
    ogEffects: Array.isArray(msg?.ogEffects) ? msg.ogEffects : []
  }, msg.x, msg.y, { cid: msg.cid, owner: msg.owner });
  applyViewFilter();
  break;

case 'life:update':
  applyLifeFromPeer(Number(msg.seat)||1, msg.life || {});
  break;



    case 'cast:announce': {
  const fromSeat = Number(msg.owner)||1;
  if (fromSeat === mySeat()) break; // ignore our own

  Overlays.openCastPrompt({
    card: {
      name: msg.name, img: msg.img,
      mana_cost: msg.mana_cost,
      type_line: msg.type_line,
      oracle_text: msg.oracle_text,
      power: msg.power, toughness: msg.toughness, loyalty: msg.loyalty
    },
    timeoutMs: 5000,
    onResolve: () => {
      sendRTC({ type:'cast:resolve', castId: msg.castId, name: msg.name, owner: msg.owner });
    },
    onCounter: () => {
      sendRTC({ type:'cast:counter', castId: msg.castId, name: msg.name, owner: msg.owner, by: mySeat() });
    }
  });
  break;
}

case 'cast:resolve': {
  Overlays?.notify?.('ok', `${msg.name || 'Spell'} resolves.`);
  break;
}

case 'cast:counter': {
  if ((Number(msg.owner)||0) === mySeat()) {
    Overlays?.notify?.('danger', `Stop — ${msg.name || 'Your spell'} has been countered.`);
  }
  break;
}



    case 'move': {
      const el = findCardByCid(msg.cid);
      if (el) { el.style.left = msg.x+'px'; el.style.top = msg.y+'px'; }
      break;
    }

    case 'tap': {
      const el = findCardByCid(msg.cid);
      if (el) {
        el.classList.toggle('tapped', !!msg.tapped);
        el.style.setProperty('--tap-rot', msg.tapped ? '90deg' : '0deg');
      }
      break;
    }

    case 'state:apply':
      window.GameIO.applyState(msg.state);
      break;
	  
	     // ⬇ peer is pushing just the shared battlefield
    case 'state:table':
      window.GameIO.applyState({ table: Array.isArray(msg.table) ? msg.table : [] });
      break;
	  
	  case 'zones:move': {
  // Ask Zones to mirror this move locally.
  // It will remove from table if needed and update zone state.
  if (typeof Zones.applyRemoteMove === 'function') {
    Zones.applyRemoteMove(msg.seat, msg); // { seat, from, to, cid, position? }
  }
  break;
}

    case 'battle:apply': {
      // A peer is telling us to run local, idempotent apply.
      // BattleUI._maybeLocalApply(state, hash) safely no-ops if we already did it.
      try {
        window.BattleUI?._maybeLocalApply(msg.state, msg.hash);
      } catch(e) {
        console.warn('[RTC] battle:apply handler error', e);
      }
      break;
    }

    case 'battle:done': {
      // Optional: nudge UI/overlay if a peer finalized already.
      try {
        // If your overlay is open, BattleUI's poller will close on 'done'.
        // This message is just a helpful nudge in case a poll tick is delayed.
        // No state mutation here; Supabase remains the source of truth.
        Overlays?.notify?.('ok', 'Combat resolved (peer).');
      } catch {}
      break;
    }



    // legacy (keep if you ever send full state intentionally)
    case 'state:apply':
      // If you keep this around, protect hands:
      // window.GameIO.applyState({ table: msg.state?.table || [] });
      break;
  }
}


function findCardByCid(cid){
  return world.querySelector(`.card[data-cid="${CSS.escape(String(cid))}"]`);
}


btnHost?.addEventListener('click', ()=> startRTC('host'));
btnJoin?.addEventListener('click', ()=> startRTC('join'));

// Save → Supabase row
btnSave?.addEventListener('click', async ()=>{
  if (!ROOM_ID) { alert('No room set'); return; }
  const seat = mySeat();

  // Preload current slots so the overlay shows timestamps instead of "Empty"
  const rows = await getSlots({ roomId: ROOM_ID });  // [{room_id,slot,snapshot_id,by_seat,updated_at}]
  const slots = (rows || []).map(r => ({
    slot: Number(r.slot),
    label: `Slot ${r.slot}`,
    savedAt: r.updated_at
  }));

  Overlays.openSaveSlots({
    roomId: ROOM_ID,
    seat,
    slots,                                  // <-- overlay expects an array
    onSave: (slot) =>                       // <-- overlay calls onSave(n)
      saveToSlot({ roomId: ROOM_ID, bySeat: seat, slot })
    // onDelete is optional; omit for now
  });
});




// Restore → pick from list
btnRestore?.addEventListener('click', async ()=>{
  if (!ROOM_ID) { alert('No room set'); return; }
  const seat = mySeat();

  // Fetch lists now; overlay expects data arrays, not provider functions
  const [manual, autos] = await Promise.all([
    listSnapshots({ roomId: ROOM_ID, limit: 25 }),
    listAutoSaves({ roomId: ROOM_ID, bySeat: seat, limit: 25 })
  ]);

  Overlays.openRestorePicker({
    roomId: ROOM_ID,
    seat,
    manual,                                     // array of manual saves
    autos,                                      // array of autosaves
    onRestoreSave: (id) => loadSnapshot({ id }),       // correct callback names
    onRestoreAuto: (id) => loadAutoSnapshot({ id })
    // NOTE: this overlay does not show slots; if you want slots here, we can extend it.
  });
});


window.debugListAutos = () =>
  listAutoSaves({ roomId: ROOM_ID, bySeat: mySeat(), limit: 25 }).then(x => (console.log('debug autos:', x), x));

window.debugListManual = () =>
  listSnapshots({ roomId: ROOM_ID, limit: 25 }).then(x => (console.log('debug manual:', x), x));

window.debugListSlots = () =>
  getSlots({ roomId: ROOM_ID }).then(x => (console.log('debug slots:', x), x));







const SCRY = 'https://api.scryfall.com';
let deck = [];           // [{name,img}]
let hand = [];
let focus = 0;

// ==== Mulligan state ====
let hasDrawn = true;        // false until we accept our opening hand
let mullOpen  = false;       // true while the "Mulligan?" overlay is up
// DOM hooks for the overlay
const mullOverlay = document.getElementById('mulliganOverlay');
const mullYesBtn  = document.getElementById('mullYesBtn');
const mullNoBtn   = document.getElementById('mullNoBtn');
// helpers
const showMull = ()=>{ if (mullOverlay){ mullOverlay.style.display='block'; mullOpen = true; } };
const hideMull = ()=>{ if (mullOverlay){ mullOverlay.style.display='none';  mullOpen = false; } };

// Mini-Stack tracking (one-at-a-time is fine for now)
const PENDING_CASTS = new Map(); // castId -> { bySeat, cid, card, x, y }
function makeCastId(){ return (crypto?.randomUUID?.() || (Date.now()+'-'+Math.random())).slice(0,18); }


async function fetchCardByName(name){
  const res = await fetch(`${SCRY}/cards/named?fuzzy=${encodeURIComponent(name)}`);
  if (!res.ok) throw new Error('Scryfall error for '+name);
  const data = await res.json();

  const face = Array.isArray(data.card_faces) && data.card_faces.length
    ? data.card_faces[0]
    : data;

  const img =
    (data.image_uris && (data.image_uris.normal || data.image_uris.large || data.image_uris.png)) ||
    (face.image_uris && (face.image_uris.normal || face.image_uris.large || face.image_uris.png));
  if (!img) throw new Error('No image for '+name);

  const toNum = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : undefined;
  };

  const basePower   = face.power     ?? data.power     ?? null; // may be "*"
  const baseTough   = face.toughness ?? data.toughness ?? null;
  const baseLoyalty = face.loyalty   ?? data.loyalty   ?? null;

  // ---- OG TYPES (split type_line) ----
  const tlRaw = (data.type_line || face.type_line || '').trim();
  // type_line looks like "Legendary Creature — Elf Druid"
  const [left, right] = tlRaw.split('—').map(s => (s||'').trim());
  const leftParts  = left ? left.split(/\s+/).filter(Boolean) : [];
  // Split into buckets if you ever need them; for now we only care about a single combined list
  const supertypes = leftParts.filter(x => /^(Basic|Legendary|Ongoing|Snow|World)$/i.test(x));
  const cardTypes  = leftParts.filter(x => /^(Artifact|Battle|Creature|Conspiracy|Dungeon|Enchantment|Instant|Land|Monster|Phenomenon|Plane|Planeswalker|Scheme|Sorcery|Tribal|Vanguard)$/i.test(x));
  const subtypes   = (right ? right.split(/\s+/).filter(Boolean) : []);
  const ogTypes    = [...supertypes, ...cardTypes, ...subtypes];

  // ---- OG EFFECTS (innate keywords only) ----
  // Scryfall's `keywords` is exactly what we want (Flying, Lifelink, Deathtouch, etc)
  const ogEffects = Array.isArray(data.keywords) ? data.keywords.slice() : [];

  return {
    name: data.name,
    img,
    type_line: tlRaw,
    power: basePower,
    toughness: baseTough,
    loyalty: baseLoyalty,

    // ← numeric OGs (as you already had)
    ogpower:     toNum(basePower),
    ogtoughness: toNum(baseTough),
    ogloyalty:   toNum(baseLoyalty),

    // ← NEW: always-on printed stuff
    ogTypes,
    ogEffects,

    // (optional helpers you may want later)
    mana_cost: data.mana_cost || face.mana_cost || '',
    oracle_text: data.oracle_text || face.oracle_text || ''
  };
}



async function loadDeckFromTextarea(){
  const lines = (deckIn.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

  // reset all local play zones for this seat's deck/hand
  deck = []; hand = []; focus = 0;
  hasDrawn = false;     // opening hand not drawn yet
  hideMull();           // just in case it was open

  for (const raw of lines){
    const m = raw.match(/^(\d+)\s+(.+)$/);
    const qty = m ? parseInt(m[1],10) : 1;
    const name= m ? m[2] : raw;
    for (let i=0;i<qty;i++){
      try{ deck.push(await fetchCardByName(name)); }
      catch{ deck.push({name, img:'https://via.placeholder.com/488x680/191f2b/9fb4d9?text='+encodeURIComponent(name)}); }
    }
  }

  // Shuffle freshly loaded deck
  window.shuffleDeck?.(mySeat());

  renderHand();
  // (No auto-draw here; first click on deck will draw 7 + ask Mulligan)
}


// Single draw with animation
async function drawOneAnimated(seat, {stagger=0, duration=420} = {}){
  if (!deck.length) { notify('Deck is empty.'); return false; }

  const insertAt = clamp(focus + 1, 0, hand.length);
  // 1) insert an invisible ghost so neighbors shift immediately
  insertGhostAt(insertAt);

  const card = deck.pop();

  // 2) fly to the ghost slot
  await flyCardToHand({ img: card.img, duration, delay: stagger });

  // 3) swap ghost → real card, focus on it, re-render
  hand[insertAt] = { ...card };
  focus = insertAt;
  clearGhost();
  renderHand();

  // 4) ensure tooltip shows on the new center card
  const host = handTrack.querySelector('.handCard.focus .card');
  if (host){
    const r = host.getBoundingClientRect();
    showCardTooltip(host, r.left, r.top);
    followTooltip(host);
  }

  return true;
}


// Replace previous click-draw handler call-sites to use this:
function drawOne(){ drawOneAnimated(mySeat()); }

// Animated batch draw (sequential)
async function drawXAnimated(seat, n, { gap=60, firstDelay=0, duration=300 } = {}){
  let count = 0;
  for (let i=0; i<n; i++){
    const ok = await drawOneAnimated(seat, { stagger: (i===0? firstDelay : i*gap), duration });
    if (!ok) break;
    count++;
  }
  if (count > 0) notify(`Drew ${count} card${count!==1?'s':''}.`);
  return count;
}


// Override global drawXCards to use fast timings
window.drawXCards = async (seat, n) => {
  n = Math.max(1, n|0);
  return drawXAnimated(seat, n, { gap: 60, duration: 300, firstDelay: 0 });
};


// ---- Hand gap/slot helpers ----
let GHOST_AT = -1; // -1 = off

function clearGhost(){ GHOST_AT = -1; }

function insertGhostAt(idx){
  // insert a lightweight placeholder into the hand array
  GHOST_AT = idx;
  hand.splice(idx, 0, { __ghost: true });
  renderHand();
}

// screen point for a slot *relative to current focus*
function handSlotScreenPoint(relFromFocus = 0){
  const tr = handTrack.getBoundingClientRect();
  const hr = handEl.getBoundingClientRect();
  const gap = 64; // keep in sync with renderHand gap
  const x = tr.left + tr.width/2 + relFromFocus * gap;
  const y = hr.top + hr.height/2;
  return { x, y };
}


// V2 rolodex layout (fixed)
function renderHand(){
  handTrack.innerHTML = '';
  if (!hand.length) return;

  focus = clamp(focus, 0, hand.length - 1);

  const gap = 64;          // px shift per step
  const baseSpread = 10;   // deg at center; we’ll taper at edges

  for (let i = 0; i < hand.length; i++){
    const rel = i - focus;                       // position relative to focus

    // Skip drawing the ghost; it still participates in indexing/fan spacing
    if (hand[i]?.__ghost) continue;

    // host wrapper for transforms/stacking
    const host = document.createElement('div');
    host.className = 'handCard';
    if (Math.abs(rel) >= 3) host.classList.add('far');
    else if (Math.abs(rel) === 2) host.classList.add('mid');
    if (rel === 0) host.classList.add('focus');

    // position + tapered rotation
    host.style.setProperty('--dx', `${rel * gap}px`);
    const taper = 1 - Math.min(0.5, Math.abs(rel) / 10);           // less tilt further out
    const rot   = rel * (baseSpread * taper);
    host.style.setProperty('--rot', `${rot}deg`);

    // natural stacking: focused on top, neighbors beneath
    host.style.zIndex = String(1000 - Math.abs(rel));

    // card shell
    const shell = document.createElement('div');
    shell.className = 'card';
    shell.innerHTML =
      `<div class="cardInner">
         <div class="face front">
           <img draggable="false" src="${hand[i].img}" alt="${hand[i].name}"
     style="width:100%;height:100%;object-fit:cover;border-radius:14px"/>

         </div>
       </div>`;
    host.appendChild(shell);
    handTrack.appendChild(host);

    attachHandGestures(host, i);
  }
}

// ==== Deck → Hand animation ======================================
const PREFERS_REDUCED_MOTION = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;

function deckCenterScreenPoint(){
  const r = deckZone.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}

function handCatchPoint({ toGhost = false } = {}){
  if (toGhost && GHOST_AT >= 0){
    // aim for the slot just inserted (by definition: focus+1)
    const rel = (GHOST_AT - focus);
    return handSlotScreenPoint(rel);
  }
  // default: center of track
  const hr = handEl.getBoundingClientRect();
  const tr = handTrack.getBoundingClientRect();
  return { x: tr.left + tr.width/2, y: hr.top + hr.height/2 };
}


// Read CSS variables safely (numbers only)
function readCSSNumber(el, varName, fallback){
  const v = getComputedStyle(el).getPropertyValue(varName).trim();
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : fallback;
}

async function flyCardToHand({ img, duration=420, delay=0 }){
  // Respect user's reduced-motion
  if (PREFERS_REDUCED_MOTION) { await new Promise(r=>setTimeout(r, Math.max(0, delay))); return; }

  const start = deckCenterScreenPoint();
  const end   = handCatchPoint({ toGhost: true });


  const ghost = document.createElement('div');
  ghost.className = 'fly-card';
  ghost.style.left = `${start.x - (readCSSNumber(document.documentElement,'--card-w',223)/2)}px`;
  ghost.style.top  = `${start.y - (readCSSNumber(document.documentElement,'--card-h',310)/2)}px`;
  ghost.innerHTML  = `<img alt="" src="${img}">`;
  document.body.appendChild(ghost);

  // Target scale roughly matches hand scale
  const handScale = readCSSNumber(document.documentElement, '--hand-scale', 0.88) || 0.88;

  // Use WAAPI so we don't fight existing CSS transitions
  const keyframes = [
    { transform: 'translate(0px, 0px) scale(1)',   opacity: 0.98, offset: 0 },
    { transform: `translate(${end.x - start.x}px, ${end.y - start.y}px) scale(${handScale})`, opacity: 1, offset: 1 }
  ];

  // optional stagger
  if (delay > 0) await new Promise(r=>setTimeout(r, delay));

  await ghost.animate(keyframes, {
    duration,
    easing: 'cubic-bezier(.22,.9,.1,1)',
    fill: 'forwards'
  }).finished.catch(()=>{});

  // quick fade-out so the "catch" feels snappy
await ghost.animate([{opacity:1},{opacity:0}], {duration:80, fill:'forwards'}).finished.catch(()=>{});
ghost.remove();
}


// swipe L/R is handled by the hand scrubber now.
// This handler is only for: long-press to play, or vertical swipe-up to play.
function attachHandGestures(el, index){
  let down = false, sx = 0, sy = 0, moved = false, hold = null, played = false;
  const UP_THRESH = 110;   // must swipe this far up to play
  const HOLD_MS   = 600;   // hold to show tooltip
  const START_MOVE_TOL = 8;

  el.addEventListener('pointerdown', (e)=>{
    // IMPORTANT: don't let the hand scrubber start on this event
    e.stopPropagation();

    down = true; sx = e.clientX; sy = e.clientY; moved = false; played = false;
    handTrack.classList.add('swiping');
    el.setPointerCapture?.(e.pointerId);

    // Long-press → show tooltip (do NOT play)
    hold = setTimeout(()=>{
      if (!moved && !window.HandScrub?.active){
        const cardEl = el.querySelector('.card');
        if (cardEl) {
          selectCard(cardEl, e.clientX, e.clientY);
          showCardTooltip(cardEl, e.clientX, e.clientY);
        }
      }
    }, HOLD_MS);
  });

  el.addEventListener('pointermove', (e)=>{
    if (!down) return;
    // keep the event local to this card
    e.stopPropagation();

    const dx = e.clientX - sx;
    const dy = sy - e.clientY; // positive = moving up
    if (!moved && (Math.abs(dx) > START_MOVE_TOL || Math.abs(dy) > START_MOVE_TOL)) moved = true;

    // If scrubbing had turned on somehow, turn it off for clear vertical intent
    const verticalDominant = Math.abs(dy) > Math.abs(dx) * 1.3;
    if (verticalDominant && window.HandScrub?.active){
      window.HandScrub.active = false;
    }

    // Cancel the long-press if we’re clearly moving or scrubbing
    if (window.HandScrub?.active || Math.abs(dx) > Math.abs(dy)){
      if (hold){ clearTimeout(hold); hold = null; }
      return;
    }

    // Strong vertical swipe-up → play
    if (!played && verticalDominant && dy > UP_THRESH){
      if (hold){ clearTimeout(hold); hold = null; }
      playFromHand(index);
      played = true;
      down = false;
    }
  }, {passive:false});

  const end = ()=>{
    down = false;
    if (hold){ clearTimeout(hold); hold = null; }
    handTrack.classList.remove('swiping');
  };
  el.addEventListener('pointerup', end);
  el.addEventListener('pointercancel', end);
}




// ===== Hand scrub (continuous left/right while held) =====
window.HandScrub = { active: false };

let scrubbing = false;
let scrubStartX = 0;
let scrubStartY = 0;          // <-- add this line
let scrubStartFocus = 0;
const STEP = 46;

let pendingScrub = false;



// Capture phase so we still see events even if a child stops propagation.
handTrack.addEventListener('pointerdown', (e)=>{
  if (!e.target.closest('.handCard')) return;

  pendingScrub = true;
  scrubbing = false;
  window.HandScrub.active = false;
  scrubStartX = e.clientX;
  scrubStartY = e.clientY;
  scrubStartFocus = focus;
  handTrack.setPointerCapture?.(e.pointerId);
}, { passive: true, capture: true });

handTrack.addEventListener('pointermove', (e)=>{
  if (!pendingScrub && !scrubbing) return;

  const dx = e.clientX - scrubStartX;
  const dy = e.clientY - scrubStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);

  // Only activate scrubbing for clearly horizontal intent
  if (pendingScrub){
    if (absDx > (STEP/2) && absDx > absDy * 1.3){
      pendingScrub = false;
      scrubbing = true;
      window.HandScrub.active = true;
    } else {
      return; // keep waiting for a decisive horizontal move
    }
  }

  // Active scrubbing → adjust focus by step
  const delta = Math.round((-dx) / STEP);
  const next = clamp(scrubStartFocus + delta, 0, hand.length - 1);
  if (next !== focus){
    focus = next;
    renderHand();
  }
}, { passive: false, capture: true });

function endScrub(e){
  if (!pendingScrub && !scrubbing) return;
  pendingScrub = false;
  if (scrubbing){
    scrubbing = false;
    window.HandScrub.active = false;
  }
  try{ handTrack.releasePointerCapture?.(e.pointerId); }catch{}
}
handTrack.addEventListener('pointerup', endScrub, {capture:true});
handTrack.addEventListener('pointercancel', endScrub, {capture:true});


//------------------------------------


// play from hand → center of view
function playFromHand(i){
  if (i<0 || i>=hand.length) return;
  const card = hand.splice(i,1)[0];
  focus = clamp(focus, 0, Math.max(0, hand.length-1));
  renderHand();

  // place at center of current viewport (slightly above true center so hand doesn’t cover)
  const vr = worldWrap.getBoundingClientRect();
  const cx = vr.left + vr.width/2;
  const cy = vr.top  + vr.height*0.45;
  const p = screenToWorld(cx, cy);


  // card size from CSS variables (defaults)
   const cw = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-w')) || 223;
  const ch = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-h')) || 310;

  const cid = (crypto?.randomUUID?.() || String(Math.random())).slice(0, 12);
  rememberCid(cid, card);
  const x = p.x - cw/2, y = p.y - ch/2;

  // 1) SPAWN NOW (authoritative local + broadcast to peers)
  spawnTableCard(card, x, y, { cid, owner: mySeat() });
  sendRTC({
  type: 'spawn',
  cid,
  owner: mySeat(),
  name: card.name || '',
  img:  card.img || '',
  x, y,
  ogpower:     Number.isFinite(card?.ogpower)     ? card.ogpower     : (Number.isFinite(+card?.power) ? +card.power : undefined),
  ogtoughness: Number.isFinite(card?.ogtoughness) ? card.ogtoughness : (Number.isFinite(+card?.toughness) ? +card.toughness : undefined),
  ogloyalty:   Number.isFinite(card?.ogloyalty)   ? card.ogloyalty   : (Number.isFinite(+card?.loyalty) ? +card.loyalty : undefined),

  // 🔹 NEW: send OG lists so the remote sees badges immediately
  ogTypes:     Array.isArray(card?.ogTypes)   ? card.ogTypes   : [],
  ogEffects:   Array.isArray(card?.ogEffects) ? card.ogEffects : [],

  type_line:   card.type_line || '',
  mana_cost:   card.mana_cost || '',
  oracle_text: card.oracle_text || '',
  power:       card.power ?? '',
  toughness:   card.toughness ?? '',
  loyalty:     card.loyalty ?? ''
});


  // 2) ANNOUNCE (opponent gets the 5s decision overlay; no blocking)
  const castId = makeCastId();
  sendRTC({
    type: 'cast:announce',
    castId,
    owner: mySeat(),
    cid,
    name: card.name || '',
    img:  card.img || '',
    mana_cost:   card.mana_cost || '',
    type_line:   card.type_line || '',
    oracle_text: card.oracle_text || '',
    power:       card.power ?? '',
    toughness:   card.toughness ?? '',
    loyalty:     card.loyalty ?? ''
  });




}

function finalizeCast(castId){
  const meta = PENDING_CASTS.get(castId);
  if (!meta) return;
  const { cid, card, x, y, bySeat } = meta;
  PENDING_CASTS.delete(castId);

  // actual spawn (authoritative cid+owner)
  spawnTableCard(card, x, y, { cid, owner: bySeat });
  applyViewFilter?.();
}



const _lastMoveSend = new Map(); // img -> ts

function shouldSendMove(img, everyMs=24){
  const now = performance.now();
  const last = _lastMoveSend.get(img) || 0;
  if (now - last < everyMs) return false;
  _lastMoveSend.set(img, now);
  return true;
}


// --- Store simple card data by cid so overlays/zones can hydrate quickly
const CID_DATA = new Map();
function rememberCid(cid, card) {
  if (!cid || !card) return;
  CID_DATA.set(String(cid), {
    id: String(cid),
    name: card.name || '',
    img:  card.img  || '',
    type_line: card.type_line || '',
    mana_cost: card.mana_cost || '',
    oracle_text: card.oracle_text || '',           // ← add this
    power: card.power ?? null,
    toughness: card.toughness ?? null,
    loyalty: card.loyalty ?? null,
    ogpower: card.ogpower,
    ogtoughness: card.ogtoughness,
    ogloyalty: card.ogloyalty,
    ogTypes: Array.isArray(card.ogTypes) ? card.ogTypes.slice() : [],
    ogEffects: Array.isArray(card.ogEffects) ? card.ogEffects.slice() : []
  });
}



window.getCardDataById = (cid) => {
  const key = String(cid || '');
  if (CID_DATA.has(key)) return CID_DATA.get(key);
  // fallback: look at the DOM if the card is still on table
  const el = document.querySelector(`.card[data-cid="${CSS.escape(key)}"]`);
  if (!el) return null;
  return {
    id: key,
    name: el.dataset?.name || '',
    img:  el.querySelector('img')?.src || ''
  };
};

// ——— UI mutators used by Zones
window.addToHand = (card, seat) => {
  if (seat !== mySeat()) return;
  // push the full card object (keep ogpower/ogtoughness/ogloyalty)
  hand.push({ ...card });
  focus = hand.length - 1;
  renderHand();
};


window.addToDeck = (card, seat, { position } = {}) => {
  if (seat !== mySeat()) return;
  const item = { ...card };
  if (position === 'bottom') {
    deck.unshift(item);
  } else if (position === 'shuffle') {
    const idx = Math.floor(Math.random() * (deck.length + 1));
    deck.splice(idx, 0, item);
  } else {
    deck.push(item); // top
  }
};

async function initialDraw7(){
  const seat = mySeat();
  const n = Math.min(7, Array.isArray(deck) ? deck.length : 0);
  if (n <= 0) { notify('Deck is empty.'); return; }

  // Fast: starts immediately, overlaps heavily
  await drawXAnimated(seat, n, { gap: 10, firstDelay: 0, duration: 100 });
  showMull();
}


function doMulligan(){
  // Return current hand to deck, shuffle, and re-draw 7.
  if (Array.isArray(hand) && hand.length){
    deck.push(...hand.splice(0)); // put entire hand back on top (we’ll shuffle)
  }
  window.shuffleDeck?.(mySeat());
  renderHand();
  initialDraw7();        // draw 7 again and re-ask
}


window.shuffleDeck = (seat) => {
  if (seat !== mySeat()) return;
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  // (no UI refresh necessary until next draw)
};


// spawn + drag (world coords, zoom/pan aware)
function spawnTableCard(card, x, y, opts = {}){
  const owner = opts.owner ?? mySeat();
  const cid   = opts.cid   ?? (crypto?.randomUUID?.() || String(Math.random())).slice(0,12);
rememberCid(cid, card);
  const el = document.createElement('div');
  // Seed printed base from OGs (prefer) or raw power/toughness if numeric
const n = v => {
  const k = Number(v);
  return Number.isFinite(k) ? k : NaN;
};
const ogP = n(card?.ogpower), ogT = n(card?.ogtoughness);
const p   = n(card?.power),   t   = n(card?.toughness);

if (Number.isFinite(ogP)) el.dataset.baseP = String(ogP);
else if (Number.isFinite(p)) el.dataset.baseP = String(p);

if (Number.isFinite(ogT)) el.dataset.baseT = String(ogT);
else if (Number.isFinite(t)) el.dataset.baseT = String(t);

// Stamp OG types/effects to the DOM dataset so attributes/badges can read instantly
if (Array.isArray(card?.ogTypes) && card.ogTypes.length) {
  // store as JSON string; safer for multi-word types like "Phyrexian — Elf"
  el.dataset.ogTypes = JSON.stringify(card.ogTypes);
}
if (Array.isArray(card?.ogEffects) && card.ogEffects.length) {
  el.dataset.ogEffects = JSON.stringify(card.ogEffects);
}


// (optional) let attributes know it’s a creature, etc.
if (card?.type_line) {
  el.dataset.type_line = String(card.type_line); // <-- needed for CSS
  el.dataset.typeLine  = String(card.type_line); // legacy/other code paths
}


  el.className = 'card';
  el.style.left = x+'px';
  el.style.top  = y+'px';
  el.dataset.owner = String(owner);
  el.dataset.cid   = String(cid);
  el.dataset.name  = card.name || '';
  // Stamp base P/T/L if we have numeric OGs (for overlays and snapshot)
if (Number.isFinite(card?.ogpower))   el.dataset.baseP = String(card.ogpower);
if (Number.isFinite(card?.ogtoughness)) el.dataset.baseT = String(card.ogtoughness);
// loyalty (if you want to surface later)
if (Number.isFinite(card?.ogloyalty)) el.dataset.baseL = String(card.ogloyalty);

  el.innerHTML = `
    <div class="cardInner">
      <div class="face front" style="background:none">
        <img draggable="false" src="${card.img}" alt="${card.name}" style="width:100%;height:100%;object-fit:cover;border-radius:14px"/>

      </div>
    </div>`;
	
  world.appendChild(el);

 // NEW: attach tooltip for this card (fill real type/cost/oracle if you have it)
  attachTooltip(el, {
  name: card.name || '',
  typeLine: '',
  costHTML: '',
  oracle: card.oracle_text || ''
});

// Also stamp directly on the node so other modules can read it fast
if (card.oracle_text) {
  el.dataset.oracle = String(card.oracle_text);
}



  // respect current view immediately
  if (parseInt(el.dataset.owner,10) !== currentViewSeat) el.classList.add('hidden-by-view');

  // helper: toggle tap locally + broadcast
  function setTapped(v, broadcast=true){
    el.classList.toggle('tapped', v);
    el.style.setProperty('--tap-rot', v ? '90deg' : '0deg');
    if (broadcast && window.RTC) {
      window.RTC.send({ type:'tap', cid, tapped: v });
    }
  }
  function toggleTap(broadcast=true){ setTapped(!el.classList.contains('tapped'), broadcast); }

  // ----- drag + tap/double-tap (owner)  |  tap-to-select+tooltip (non-owner)




let dragging=false, ox=0, oy=0;
let startX=0, startY=0, moved=false;
const MOVE_TOL = 6;     // px
const TAP_MS   = 300;   // double-tap window
el._lastTapTs  = el._lastTapTs || 0;

el.addEventListener('pointerdown', (e)=>{
  const isOwner = parseInt(el.dataset.owner,10) === mySeat();
  
   // NEW: select + show tooltip immediately on press down
 selectCard(el);
showCardTooltip(el, e.clientX, e.clientY);  // <- correct function name
     
  // Always track movement to differentiate tap vs drag
  moved = false; startX = e.clientX; startY = e.clientY;

  if (!isOwner){
    // Read-only: don't start dragging. We’ll handle tap on pointerup.
    // Prevent battlefield pan from stealing this *tap* sequence.
    el.setPointerCapture?.(e.pointerId);
    e.stopPropagation();
    return;
  }

  // Owner: begin drag
  dragging=true;
  const r = worldScale.getBoundingClientRect();
  const lx = (e.clientX - r.left - cam.x)/cam.z;
  const ly = (e.clientY - r.top  - cam.y)/cam.z;
  ox = lx - parseFloat(el.style.left);
  oy = ly - parseFloat(el.style.top);
  el.setPointerCapture?.(e.pointerId);
  e.stopPropagation();
});

el.addEventListener('pointermove', (e)=>{
  if (!dragging) {
    if (!moved && (Math.abs(e.clientX-startX) > MOVE_TOL || Math.abs(e.clientY-startY) > MOVE_TOL)) moved = true;
    // Even when not dragging, keep the tooltip anchored to the element (pan/zoom or small nudges)
    followTooltip(el);
    return;
  }

  if (!moved && (Math.abs(e.clientX-startX) > MOVE_TOL || Math.abs(e.clientY-startY) > MOVE_TOL)) moved = true;

  const r = worldScale.getBoundingClientRect();
  const lx = (e.clientX - r.left - cam.x)/cam.z;
  const ly = (e.clientY - r.top  - cam.y)/cam.z;
  el.style.left = (lx - ox) + 'px';
  el.style.top  = (ly - oy) + 'px';

  // Keep tooltip glued to the left edge of the card while dragging
  followTooltip(el);

  if (window.RTC) window.RTC.send({
    type: 'move',
    cid,
    x: parseFloat(el.style.left)||0,
    y: parseFloat(el.style.top)||0
  });
});


const end = async (e)=>{
  const isOwner = parseInt(el.dataset.owner,10) === mySeat();

  if (!moved){
    const now = performance.now();

    // Track last tap time + position for spatial slop
    const lastTs = el._lastTapTs || 0;
    const lastX  = el._lastTapX  || e.clientX;
    const lastY  = el._lastTapY  || e.clientY;

    const dt = now - lastTs;
    const dx = Math.abs((e.clientX || 0) - lastX);
    const dy = Math.abs((e.clientY || 0) - lastY);
    const withinTime  = dt > 0 && dt <= TAP_MS;
    const withinSlop  = dx <= DBL_TAP_SLOP_PX && dy <= DBL_TAP_SLOP_PX;
    const isDouble    = withinTime && withinSlop;

    // update last-tap markers for next time
    el._lastTapTs = now;
    el._lastTapX  = e.clientX;
    el._lastTapY  = e.clientY;

    if (isDouble){
      // owner double-tap = tap/untap broadcast
      if (isOwner) toggleTap(true);
    } else {
      // Single tap: select + tooltip
      selectCard(el);
      await showCardTooltip(el, e.clientX, e.clientY);
    }
  }

  dragging = false;
  try{ el.releasePointerCapture?.(e.pointerId); }catch{}
};


el.addEventListener('pointerup', end);
el.addEventListener('pointercancel', end);

// Desktop nicety: dblclick also toggles (owner only)
el.addEventListener('dblclick', (e)=>{
  if (parseInt(el.dataset.owner,10) === mySeat()) {
    toggleTap(true);
  }
});

}



// ====== hook up minimal controls ======
loadBtn?.addEventListener('click', loadDeckFromTextarea);
resetBtn?.addEventListener('click', ()=>{/* no-op per your request */});
deckZone?.addEventListener('click', ()=>{
  // If Mulligan prompt is visible, block drawing more cards
  if (mullOpen) return;

  if (!hasDrawn){
    initialDraw7();
  } else {
    drawOne(); // normal single-card draw after mulligan is accepted
  }
});

mullYesBtn?.addEventListener('click', ()=>{
  // Friendly mulligan: always redraw 7; keep asking until "No"
  doMulligan();
});

mullNoBtn?.addEventListener('click', ()=>{
  // Lock in this hand; future deck clicks draw one card at a time
  hasDrawn = true;
  hideMull();
});

// Optional: auto-load if textarea already has lines
if ((deckIn?.value||'').trim()) { loadDeckFromTextarea().catch(()=>{}); }

// Start with my seat’s view
applyViewFilter();



/* === Ownership + Player View ========================================= */
// Make seats visible to modules (Zones uses this)
window.AppState = window.AppState || {};
Object.defineProperty(window.AppState, 'mySeat',  { get: () => mySeat() });
Object.defineProperty(window.AppState, 'viewSeat', {
  get: () => currentViewSeat,
  set: (v) => { 
    const next = Number(v) || currentViewSeat; 
    if (next !== currentViewSeat){ currentViewSeat = next; applyViewFilter(); }
  }
});


const otherSeat = () => (mySeat() === 1 ? 2 : 1);

function applyViewFilter(){
  // table cards
  for (const el of world.querySelectorAll('.card')) {
    const owner = parseInt(el.dataset.owner || '0', 10);
    const show = owner === currentViewSeat;
    el.classList.toggle('hidden-by-view', !show);
  }
  // hand: only show mine
  const seeMine = currentViewSeat === mySeat();
  handEl.style.display = seeMine ? '' : 'none';
  document.body.classList.toggle('viewing-opponent', !seeMine);

  updateViewingChip();   
}

viewEyeBtn?.addEventListener('click', ()=>{
  currentViewSeat = (currentViewSeat === mySeat()) ? otherSeat() : mySeat();
  applyViewFilter();     // update + chip
});

seatSelect?.addEventListener('change', ()=>{
  if (currentViewSeat !== otherSeat()) currentViewSeat = mySeat();
  applyViewFilter();     // update + chip
});


// ======= Drawer Controls ===========
const cogBtn = document.getElementById('cogBtn');

document.addEventListener('pointerdown', (e) => {
  if (e.target.closest('[data-card-cog], .cardCogBtn')) e.stopPropagation();
});

document.addEventListener('click', (e) => {
  if (e.target.closest('[data-card-cog], .cardCogBtn')) e.stopPropagation();
});

document.addEventListener('mousedown', (e) => {
  if (e.target.closest('[data-card-cog], .cardCogBtn')) e.stopPropagation();
});

initTurnUpkeep({ endTurnBtnSelector: '#endTurnBtn' });


/* Drawer toggle */
cogBtn.addEventListener('click', ()=>{
  const open = !drawerWrap.classList.contains('expanded');
  drawerWrap.classList.toggle('collapsed', !open);
  drawerWrap.classList.toggle('expanded', open);
  zoomWrapEl.style.display = open ? 'none' : 'flex';
});

// --- Wire deck action buttons (🔍, ＋, …) ---
const deckSearchBtn = document.getElementById('deckSearchBtn');
const deckAddBtn    = document.getElementById('deckAddBtn');
const deckMoreBtn   = document.getElementById('deckMoreBtn');

// 🔍 Search deck — unchanged
deckSearchBtn.addEventListener('click', async ()=>{
  const seat = mySeat();
  const deckCards = await window.getDeckCardsForSeat?.(seat) || [];
  Overlays.openDeckSearch({
    seat,
    deckCards,
    onMove:(card,dest)=>{
  if (dest==='table')   window.spawnCardAtViewCenter?.(card, seat);
  if (dest==='hand')    window.addToHand?.(card, seat);
  if (dest==='graveyard'||dest==='exile')
    window.moveCardToZone?.(card, dest, seat);
},
    onCloseAskShuffle:(doShuffle)=>{ if (doShuffle) window.shuffleDeck?.(seat); }
  });
});

// ＋ Add any card — UPDATED to use onMove
deckAddBtn.addEventListener('click', ()=>{
  const seat = mySeat();
  Overlays.openAddCard({
    seat,
    onMove:(card,dest)=>{
  if (dest==='table')   window.spawnCardAtViewCenter?.(card, seat);
  if (dest==='hand')    window.addToHand?.(card, seat);
  if (dest==='graveyard'||dest==='exile')
    window.moveCardToZone?.(card, dest, seat);
}
  });
});

// … Deck tools — unchanged
deckMoreBtn.addEventListener('click', ()=>{
  const seat = mySeat();
  Overlays.openDeckOptions({
    seat,
    onDrawX:(n)=> window.drawXCards?.(seat,n),
    onMillX:(n)=> window.millXCards?.(seat,n),
    onCascade:(opts)=> window.startCascade?.(seat, opts),
    onShuffle:()=> window.shuffleDeck?.(seat)
  });
});


window.getDeckCardsForSeat = async (seat)=>{
  // We only track a single local deck in v3; top of deck is the array end.
  // Return in draw order (top-first) and include the fields the overlays expect.
  return (Array.isArray(deck) ? deck.slice().reverse() : []).map((c, i)=>({
    id: `deck-${i}`,           // stable-ish id for overlay removal
    name: c.name || '',
    img:  c.img  || '',
    // optional fields used by filters (safe defaults):
    type_line: c.type_line || '',
    mana_cost: c.mana_cost || '',
    oracle_text: c.oracle_text || ''
  }));
};

window.spawnCardAtViewCenter = (card, seat)=>{
  const vr = worldWrap.getBoundingClientRect();
  const cx = vr.left + vr.width/2;
  const cy = vr.top  + vr.height*0.45;
  const { x, y } = screenToWorld(cx, cy);
  const cid = (crypto?.randomUUID?.() || String(Math.random())).slice(0,12);
  spawnTableCard({ ...card }, x, y, { owner: seat, cid });
};


// Utils
function notify(msg){ try{ Overlays.notify('info', msg); }catch{} }

// DRAW X → move from top-of-deck to hand
window.drawXCards = (seat, n)=>{
  n = Math.max(1, n|0);
  const drawn = [];
  while (n-- > 0 && Array.isArray(deck) && deck.length){
    const c = deck.pop();       // top of deck
    drawn.push(c);
    window.addToHand?.(c, seat);
  }
  if (!drawn.length){ notify('Deck is empty.'); return; }
  notify(`Drew ${drawn.length} card${drawn.length!==1?'s':''}.`);
};

// MILL X → move from top-of-deck to graveyard
// MILL X → move from top-of-deck to graveyard (with ids so Zones can track them)
window.millXCards = (seat, n)=>{
  n = Math.max(1, n|0);
  let moved = 0;

  while (n-- > 0 && Array.isArray(deck) && deck.length){
    const c = deck.pop();                 // top of deck
    Zones?.addToZone?.({ seat, zoneName:'graveyard', card: c });  // ← authoritative
    moved++;
  }

  Overlays.notify('info', `Milled ${moved}.`);
  Zones?.emitChange?.({ seat, zoneName:'graveyard' });
};




// CASCADE (reveal until hit, cast for free, bottom the rest randomly)
window.startCascade = (seat, opts={ value:0, strictLess:true, ignoreLands:true })=>{
  const N = Math.max(0, Number(opts.value||0)|0);
  const strict = !!opts.strictLess;       // true => < N, false => ≤ N
  const ignoreLands = !!opts.ignoreLands; // true => skip lands as candidates

  if (!Array.isArray(deck) || !deck.length){
    notify('Deck is empty.');
    return;
  }

  const revealed = [];
  let hit = null;

  // Helper to read mana value (fall back across common fields)
  const mvOf = (c)=>{
  if (Number.isFinite(c?.mana_value)) return c.mana_value|0;
  if (Number.isFinite(c?.cmc))        return c.cmc|0;
  if (Number.isFinite(c?.converted_mana_cost)) return c.converted_mana_cost|0;
  return 0; // treat missing as 0 (lands typically)
};

  const isLand = (c)=>{
  const tl = (c?.type_line || c?.type || '').toLowerCase();
  if (tl.includes('land')) return true;
  if (Array.isArray(c?.types)      && c.types.some(t => String(t).toLowerCase()==='land')) return true;
  if (Array.isArray(c?.supertypes) && c.supertypes.some(t => String(t).toLowerCase()==='land')) return true;
  return false;
};


  // Reveal from the top until we find a candidate
  while (deck.length){
    const c = deck.pop();            // reveal
    revealed.push(c);

    const mv = mvOf(c);
    const mvOk = strict ? (mv < N) : (mv <= N);
    const landOk = ignoreLands ? !isLand(c) : true;

    if (landOk && mvOk){
      hit = c;
      break;
    }
  }

  // Bottom the rest in random order (top is array end ⇒ bottom is array start)
  const toBottom = revealed.filter(c => c !== hit);
  for (let i = toBottom.length - 1; i > 0; i--){
    const j = (Math.random()* (i+1))|0;
    [toBottom[i], toBottom[j]] = [toBottom[j], toBottom[i]];
  }
  // Put on bottom (front)
  deck.unshift(...toBottom);

  // If we found a hit, “cast” it (spawn to table center for now)
  if (hit){
    window.spawnCardAtViewCenter?.(hit, seat);
    notify(`Cascade hit: ${hit.name || 'card'}`);
  } else {
    notify('Cascade revealed the entire deck — no valid hit.');
  }
};

</script>
