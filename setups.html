<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Setups – Marks</title>
<style>
  :root { --gap: 12px; --chip-bg:#f7f7f7; --border:#ddd; }
  body { font-family: system-ui, sans-serif; margin: 16px; background:#f5f5f5; }
  h1 { margin: 0 0 8px; }
  .muted { color:#666; font-size:12px; margin-top:2px; }

  .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 12px; border-radius:8px; cursor:pointer; }
  .btn.primary { background:#0b74ff; border-color:#0b74ff; color:#fff; }
  .btn.ghost { background:#fff; border-color:#ccc; }

  .section { border:1px solid var(--border); border-radius:12px; padding:12px; margin-top:14px; background:#fff; }

  /* Header row */
  .marks-head {
    display:grid;
    grid-template-columns: 100px 1fr repeat(6, 80px) 72px;
    gap:6px; align-items:center;
    font-size:12px; color:#444; font-weight:600; margin-bottom:8px;
  }
  .head-center { text-align:center; }

  /* Mark rows as cards */
  .mark-item {
    display:grid;
    grid-template-columns: 100px 1fr repeat(6, 80px) 72px; /* label | slider | 6 opts | remove */
    gap:6px; align-items:center;

    background:#fafafa;
    padding:10px;
    border:1px solid #ddd;
    border-radius:10px;
    margin-bottom:12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
  }
  .mark-label { font-weight:700; }
  .opt-cell { text-align:center; }
  .slider-wrap { grid-column: 2 / 3; }
  input[type="range"] { width:100%; }

  /* Per-checkbox labels: hidden on desktop, shown on mobile */
  .opt { display:flex; align-items:center; gap:8px; justify-content:center; }
  .opt span { display:none; font-size:13px; color:#333; }

  /* Mobile tweaks */
  @media (max-width: 768px) {
    .marks-head { display:none; }
    .mark-item { grid-template-columns: repeat(3, 1fr); grid-auto-rows: auto; }
    .mark-label { grid-column: 1 / -1; }
    .opt-cell { text-align:left; }
    .opt { justify-content:flex-start; }
    .opt span { display:inline; }      /* show label text on phones */
    .slider-wrap { grid-column: 1 / -1; order: 99; }
  }

  /* Board / chips */
  .board-head { display:flex; gap:8px; justify-content:space-between; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
  .board-controls { display:flex; gap:8px; align-items:center; }
  .dock { display:flex; flex-wrap:wrap; gap:8px; padding:8px; border:1px dashed #cfcfcf; border-radius:10px; min-height:46px; }
  .board { display:grid; gap:var(--gap); margin-top:12px; } /* columns set via JS */
  .column { border:1px solid var(--border); border-radius:10px; min-height:140px; padding:8px; display:flex; flex-direction:column; gap:8px; background:#fff; }
  .column-title { font-weight:600; font-size:13px; color:#444; display:flex; align-items:center; justify-content:space-between; margin-bottom:6px; }
  .column-title .title { pointer-events:none; }

  .chip { user-select:none; padding:8px 10px; border:1px solid #bbb; border-radius:999px; background:var(--chip-bg); font-size:14px; touch-action:none; cursor:grab; }
  .drag-ghost { position:fixed; left:0; top:0; pointer-events:none; transform:translate(-9999px,-9999px); z-index:9999; opacity:.95; box-shadow: 0 4px 14px rgba(0,0,0,0.15); background:#fff; }
  .drop-hint { outline:2px dashed #0b74ff; outline-offset:-4px; }
</style>
</head>
<body>
  <h1>Setups – Marks</h1>
  <div class="muted" id="ctx">Loading…</div>

  <div class="section" id="marksContainer">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <strong>Marks</strong>
      <button class="btn primary" id="addMarkBtn">+ Add</button>
    </div>

    <div class="marks-head">
      <div></div>
      <div class="head-center">Distance</div>
      <div class="head-center">hand tossed</div>
      <div class="head-center">short check down</div>
      <div class="head-center">punch bird</div>
      <div class="head-center">no off</div>
      <div class="head-center">walk up</div>
      <div class="head-center">water mark</div>
      <div class="head-center">Remove</div>
    </div>

    <div class="marks-list" id="marksList"></div>
  </div>

  <div class="section">
    <div class="board-head">
      <strong>Board</strong>
      <div class="board-controls">
        <label>Day: <input type="date" id="dayPicker"></label>
        <button class="btn ghost" id="todayBtn">Today</button>
        <button class="btn ghost" id="addColumnBtn">+ Add Column</button>
      </div>
    </div>
    <strong>Dock</strong>
    <div class="dock" id="dock"></div>

    <div class="board" id="board"><!-- dynamic columns --></div>
  </div>

  <div class="chip drag-ghost" id="ghost"></div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
// ---------- Firebase ----------
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.firebasestorage.app",
  messagingSenderId: "795274673000",
  appId: "1:795274673000:web:0ea07130e45c72384134dd",
  measurementId: "G-VLW5KLY4FF"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ---------- Params ----------
const params = new URL(location.href).searchParams;
const trainer = params.get('trainer') || 'default';
document.getElementById('ctx').textContent = `Trainer: ${trainer}`;

// ---------- Daily docs ----------
function ymd(d) {
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
const dayPicker = document.getElementById('dayPicker');
const todayBtn  = document.getElementById('todayBtn');
const localToday = new Date();
dayPicker.value = ymd(localToday);
todayBtn.addEventListener('click', () => { dayPicker.value = ymd(new Date()); switchDay(dayPicker.value); });

// dynamic docRef based on date
let currentDateKey = dayPicker.value;
let docRef = () => db.collection('setups').doc(trainer).collection('days').doc(currentDateKey).collection('configs').doc('marks');

// ---------- State (dynamic columns) ----------
// VALID SHAPE: { items:[{id,dist,options}], columns:{ dock:[ids], cols:[ {items:[ids]}, ... ] } }
let state = { items: [], columns: { dock: [], cols: [] } };

// ---------- Snapshot control ----------
let unsub = null;                // active listener
let suppressSnapshots = false;   // ignore Firestore snapshots during local writes

async function switchDay(key) {
  currentDateKey = key;
  if (unsub) { try { unsub(); } catch(e){} unsub = null; }
  state = { items: [], columns: { dock: [], cols: [] } };
  renderAll();
  unsub = docRef().onSnapshot(handleSnapshot);
}

// ---------- DOM refs ----------
const dock  = document.getElementById('dock');
const board = document.getElementById('board');
const ghost = document.getElementById('ghost');

// ---------- Helpers ----------
const OPTION_KEYS = [
  { key:'handTossed',     label:'hand tossed' },
  { key:'shortCheckDown', label:'short check down' },
  { key:'punchBird',      label:'punch bird' },
  { key:'noOff',          label:'no off' },
  { key:'walkUp',         label:'walk up' },
  { key:'waterMark',      label:'water mark' },
];

function byId(id){ return state.items.find(i => i.id === id); }
function indexOfId(id){ return state.items.findIndex(i => i.id === id); }
function makeId(){ return 'm_' + Math.random().toString(36).slice(2,9); }
function clampToStep(v){ return Math.max(0, Math.min(400, Math.round(v/25)*25)); }

// Label text format: "#1 - 400 yards"
function markTextFrom(id){
  const item = byId(id);
  const idx = indexOfId(id);
  const number = idx >= 0 ? (idx + 1) : '?';
  const dist = item?.dist ?? 0;
  return `#${number} - ${dist} yards`;
}

// Chip label = base + short flags (HT/GO/WT/RT) if selected
function chipTextFrom(id){
  const base = markTextFrom(id);
  const item = byId(id);
  if (!item) return base;
  const o = item.options || {};
  const codes = [];
  if (o.handTossed) codes.push('HT');
  if (o.goBird)     codes.push('GO');
  if (o.whiteCoat)  codes.push('WT');
  if (o.retire)     codes.push('RT');
  return codes.length ? `${base} ${codes.join(' ')}` : base;
}


function optionsSummary(id){
  const item = byId(id);
  if (!item || !item.options) return '';
  return OPTION_KEYS.filter(o => !!item.options[o.key]).map(o => o.label).join(', ');
}

function collectColItems() {
  const out = [];
  (state.columns.cols || []).forEach(c => (c?.items || []).forEach(id => out.push(id)));
  return out;
}
function removeIdFromAll(id){
  state.columns.dock = state.columns.dock.filter(x => x !== id);
  state.columns.cols = state.columns.cols.map(c => ({ items: (c.items || []).filter(x => x !== id) }));
}
function ensureAllIdsPlaced() {
  const placed = new Set([ ...state.columns.dock, ...collectColItems() ]);
  for (const it of state.items) if (!placed.has(it.id)) state.columns.dock.push(it.id);
  state.columns.dock = state.columns.dock.filter(id => byId(id));
  state.columns.cols = state.columns.cols.map(c => ({ items: (c.items || []).filter(id => byId(id)) }));
}

// NEW: only add columns up to a minimum; never remove
function ensureMinColumns(n=2) {
  while (state.columns.cols.length < n) state.columns.cols.push({ items: [] });
}

// NEW: used only when migrating legacy shapes (optional tidy)
function pruneTrailingEmptyColumns() {
  while (state.columns.cols.length > 0 && (state.columns.cols[state.columns.cols.length-1].items || []).length === 0) {
    state.columns.cols.pop();
  }
}

function migrateLegacyColumns(columns) {
  if (!columns) return { dock: [], cols: [{items:[]},{items:[]}], migrated: true, legacyKeys: [] };

  // Already in good shape?
  if (Array.isArray(columns.cols) && columns.cols.every(el => el && typeof el === 'object' && Array.isArray(el.items))) {
    return {
      dock: Array.isArray(columns.dock) ? columns.dock.slice() : [],
      cols: columns.cols.map(c => ({ items: Array.isArray(c.items) ? c.items.slice() : [] })),
      migrated: false,
      legacyKeys: []
    };
  }

  // Array-of-arrays -> convert to array of maps
  if (Array.isArray(columns.cols) && columns.cols.every(el => Array.isArray(el))) {
    return {
      dock: Array.isArray(columns.dock) ? columns.dock.slice() : [],
      cols: columns.cols.map(arr => ({ items: arr.slice() })),
      migrated: true,
      legacyKeys: []
    };
  }

  // Legacy col1..colN -> convert
  const legacyKeys = Object.keys(columns).filter(k => k.startsWith('col')).sort((a,b) => {
    const ai = parseInt(a.replace('col',''))||0, bi = parseInt(b.replace('col',''))||0;
    return ai - bi;
  });
  if (legacyKeys.length) {
    const cols = legacyKeys.map(k => ({ items: Array.isArray(columns[k]) ? columns[k].slice() : [] }));
    const dock = Array.isArray(columns.dock) ? columns.dock.slice() : [];
    return { dock, cols, migrated: true, legacyKeys };
  }

  // Fallback
  return { dock: Array.isArray(columns.dock) ? columns.dock.slice() : [], cols: [{items:[]},{items:[]}], migrated: true, legacyKeys: [] };
}

async function save() {
  ensureAllIdsPlaced();
  await docRef().set({
    items: state.items,
    columns: { dock: state.columns.dock, cols: state.columns.cols },
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    dateKey: currentDateKey,
    trainer
  }, { merge: true });
}

// ---------- UI: Marks ----------
function renderMarksList() {
  const marksList = document.getElementById('marksList');
  marksList.innerHTML = '';

  state.items.forEach((item) => {
    // include defaults (with new flags) for older docs
    item.options = Object.assign({
      handTossed:false, shortCheckDown:false, punchBird:false,
      noOff:false, walkUp:false, waterMark:false,
      goBird:false, whiteCoat:false, retire:false
    }, item.options || {});

    const row = document.createElement('div');
    row.className = 'mark-item';
    row.dataset.id = item.id;

    // Label (desktop row label stays WITHOUT short flags)
    const label = document.createElement('div');
    label.className = 'mark-label';
    label.textContent = markTextFrom(item.id);

    // Slider
    const sliderWrap = document.createElement('div');
    sliderWrap.className = 'slider-wrap';
    const slider = document.createElement('input');
    slider.type = 'range'; slider.min = 0; slider.max = 400; slider.step = 25;
    slider.value = item.dist;
    slider.addEventListener('input', () => {
      item.dist = clampToStep(Number(slider.value));
      // update row label
      label.textContent = markTextFrom(item.id);
      // update any chips for this id (text uses chipTextFrom)
      document.querySelectorAll(`.chip[data-id="${item.id}"]`).forEach(c => {
        c.textContent = chipTextFrom(item.id);
        const sum = optionsSummary(item.id); c.title = sum || '';
      });
    });
    slider.addEventListener('change', save);
    sliderWrap.appendChild(slider);

    // Option checkboxes (mobile shows text next to each)
    const optCells = OPTION_KEYS.map(({key, label:optLabel}) => {
      const cell = document.createElement('div');
      cell.className = 'opt-cell';

      const lab = document.createElement('label');
      lab.className = 'opt';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!item.options[key];
      cb.title = optLabel;
      cb.addEventListener('change', async () => {
        item.options[key] = cb.checked;
        // update chips: both tooltip and the short codes in the text
        document.querySelectorAll(`.chip[data-id="${item.id}"]`).forEach(c => {
          c.textContent = chipTextFrom(item.id);
          const sum = optionsSummary(item.id); c.title = sum || '';
        });
        await save();
      });

      const txt = document.createElement('span');
      txt.textContent = optLabel;

      lab.append(cb, txt);
      cell.appendChild(lab);
      return cell;
    });

    // Delete mark
    const del = document.createElement('button');
    del.className = 'btn';
    del.textContent = 'Remove';
    del.title = 'Remove mark';
    del.addEventListener('click', async () => {
      state.items = state.items.filter(x => x.id !== item.id);
      removeIdFromAll(item.id);
      renderAll();
      suppressSnapshots = true;
      await save().finally(()=>{ suppressSnapshots=false; });
    });

    // Append in fixed order
    row.appendChild(label);
    row.appendChild(sliderWrap);
    optCells.forEach(c => row.appendChild(c));
    row.appendChild(del);

    marksList.appendChild(row);
  });

  // Refresh numbering after deletions
  marksList.querySelectorAll('.mark-label').forEach((el, idx) => {
    const id = state.items[idx]?.id;
    if (id) el.textContent = markTextFrom(id);
  });
}


// ---------- UI: Chips / Columns ----------
function makeChip(id) {
  const chip = document.createElement('div');
  chip.className = 'chip';
  chip.dataset.id = id;
  chip.textContent = chipTextFrom(id);   // <-- use chipTextFrom
  const sum = optionsSummary(id);
  if (sum) chip.title = sum;
  return chip;
}


function renderColumnsAndDock() {
  // Dock
  dock.innerHTML = '';
  state.columns.dock.forEach(id => dock.appendChild(makeChip(id)));

  // Columns
  board.innerHTML = '';
  const count = Math.max(1, state.columns.cols.length);
  board.style.gridTemplateColumns = `repeat(${count}, minmax(0, 1fr))`;

  state.columns.cols.forEach((colData, i) => {
    const col = document.createElement('div');
    col.className = 'column';
    col.dataset.colindex = String(i);

    const title = document.createElement('div');
    title.className = 'column-title';
    const tText = document.createElement('span');
    tText.className = 'title';
    tText.textContent = `Column ${i + 1}`;

    const remBtn = document.createElement('button');
    remBtn.className = 'btn';
    remBtn.textContent = 'Remove';
    remBtn.title = 'Remove this column';
    remBtn.addEventListener('click', async () => {
      // optimistic
      state.columns.dock.push(...(state.columns.cols[i].items || []));
      state.columns.cols.splice(i, 1);
      ensureMinColumns(2);
      renderColumnsAndDock();

      suppressSnapshots = true;
      await save().finally(()=>{ suppressSnapshots=false; });
    });

    title.append(tText, remBtn);
    col.appendChild(title);

    (colData.items || []).forEach(id => col.appendChild(makeChip(id)));
    board.appendChild(col);
  });
}

function renderAll(){
  renderMarksList();
  renderColumnsAndDock();
}

// ---------- Drag & drop (chips) ----------
let dragging = null, offsetX = 0, offsetY = 0, activePointerId = null;

function setGhost(text, x, y) {
  ghost.textContent = text;
  ghost.style.transform = `translate(${x - offsetX}px, ${y - offsetY}px)`;
}
function containers() { return [ ...document.querySelectorAll('.column'), dock ]; }
function nearestDropContainer(x, y) {
  let best = null, bestDist = Infinity;
  for (const t of containers()) {
    const r = t.getBoundingClientRect();
    if (x < r.left || x > r.right || y < r.top || y > r.bottom) continue;
    const cx = (r.left + r.right) / 2, cy = (r.top + r.bottom) / 2;
    const d = Math.hypot(x - cx, y - cy);
    if (d < bestDist) { best = t; bestDist = d; }
  }
  return best;
}
function highlight(el, on) { el.classList.toggle('drop-hint', !!on); }
function clearHighlights() { containers().forEach(c => highlight(c, false)); }
function hideGhost() { ghost.style.transform = 'translate(-9999px,-9999px)'; ghost.textContent = ''; }
function endDragCleanup() {
  clearHighlights();
  hideGhost();
  dragging = null;
  activePointerId = null;
  document.body.style.cursor = '';
}

document.addEventListener('pointerdown', e => {
  const chip = e.target.closest('.chip');
  if (!chip) return;

  e.preventDefault();
  activePointerId = e.pointerId;
  chip.setPointerCapture?.(activePointerId);

  dragging = chip;
  const r = chip.getBoundingClientRect();
  offsetX = e.clientX - r.left;
  offsetY = e.clientY - r.top;

  setGhost(chip.textContent, e.clientX, e.clientY);
  document.body.style.cursor = 'grabbing';
});

document.addEventListener('pointermove', e => {
  if (!dragging || e.pointerId !== activePointerId) return;

  setGhost(dragging.textContent, e.clientX, e.clientY);
  clearHighlights();
  const t = nearestDropContainer(e.clientX, e.clientY);
  if (t) highlight(t, true);
});

document.addEventListener('pointerup', async e => {
  if (!dragging || e.pointerId !== activePointerId) return;

  dragging.releasePointerCapture?.(activePointerId);

  clearHighlights();
  const id = dragging.dataset.id;
  const t = nearestDropContainer(e.clientX, e.clientY);
  const oldParent = dragging.parentElement;

  if (!t) {
    oldParent.appendChild(dragging);
    endDragCleanup();
    return;
  }

  // Optimistic local update
  removeIdFromAll(id);
  if (t === dock) {
    state.columns.dock.push(id);
    dock.appendChild(dragging);
  } else {
    const idx = Number(t.dataset.colindex);
    if (!Number.isNaN(idx) && state.columns.cols[idx]) {
      (state.columns.cols[idx].items ||= []).push(id);
      t.appendChild(dragging);
    } else {
      state.columns.dock.push(id);
      dock.appendChild(dragging);
    }
  }

  hideGhost();
  dragging = null;
  activePointerId = null;
  document.body.style.cursor = '';

  suppressSnapshots = true;
  try { await save(); }
  catch (err) {
    console.error('Save failed after drop:', err);
    // Revert UI if save fails
    removeIdFromAll(id);
    if (oldParent === dock) state.columns.dock.push(id);
    else {
      const idxOld = Number(oldParent.dataset.colindex);
      if (!Number.isNaN(idxOld) && state.columns.cols[idxOld]) (state.columns.cols[idxOld].items ||= []).push(id);
      else state.columns.dock.push(id);
    }
    renderColumnsAndDock();
  }
  finally { suppressSnapshots = false; }
});

document.addEventListener('pointercancel', () => {
  if (!dragging) return;
  dragging.releasePointerCapture?.(activePointerId);
  endDragCleanup();
});

// ---------- Add mark ----------
document.getElementById('addMarkBtn').addEventListener('click', async () => {
  const id = makeId();
  state.items.push({
    id,
    dist: 0,
    options: { handTossed:false, shortCheckDown:false, punchBird:false, noOff:false, walkUp:false, waterMark:false }
  });
  state.columns.dock.push(id);
  renderAll();
  suppressSnapshots = true;
  await save().finally(()=>{ suppressSnapshots=false; });
});

// ---------- Add column ----------
document.getElementById('addColumnBtn').addEventListener('click', async () => {
  state.columns.cols.push({ items: [] });   // add and persist first
  suppressSnapshots = true;
  try { await save(); }
  finally {
    suppressSnapshots = false;
    renderColumnsAndDock();                 // then render
  }
});

// ---------- Day switching ----------
dayPicker.addEventListener('change', () => switchDay(dayPicker.value));

// ---------- Snapshot handler ----------
async function handleSnapshot(snap) {
  if (suppressSnapshots) return;

  if (!snap.exists) {
    state = { items: [], columns: { dock: [], cols: [{items:[]},{items:[]}] } };
    renderAll();
    suppressSnapshots = true;
    await save().finally(()=>{ suppressSnapshots=false; });
    return;
  }

  const data = snap.data() || {};

  // Items
  state.items = Array.isArray(data.items) ? data.items.map(it => ({
    id: it.id,
    dist: typeof it.dist === 'number' ? clampToStep(it.dist) : 0,
    options: Object.assign({
      handTossed:false, shortCheckDown:false, punchBird:false,
      noOff:false, walkUp:false, waterMark:false
    }, it.options || {})
  })) : [];

  // Columns (migrate legacy / invalid shapes)
  const mig = migrateLegacyColumns(data.columns);
  state.columns = { dock: mig.dock, cols: mig.cols };

  // Only tidy on migration; otherwise never remove user's empty columns
  if (mig.migrated) {
    pruneTrailingEmptyColumns();
  }
  ensureMinColumns(2);
  ensureAllIdsPlaced();
  renderAll();

  // If we migrated, write back once and hard-delete legacy keys
  if (mig.migrated) {
    try {
      await docRef().set({ columns: { dock: state.columns.dock, cols: state.columns.cols } }, { merge: true });
      if (mig.legacyKeys && mig.legacyKeys.length) {
        const del = firebase.firestore.FieldValue.delete();
        const deletes = {};
        mig.legacyKeys.forEach(k => { deletes[`columns.${k}`] = del; });
        await docRef().set(deletes, { merge: true });
      }
    } catch (e) { console.error(e); }
  }
}

// ---------- Kick things off ----------
switchDay(currentDateKey);
</script>
</body>
</html>
