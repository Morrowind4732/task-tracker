<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Setups – Marks & Blinds</title>
<style>
  :root { --gap: 12px; --chip-bg:#f7f7f7; --border:#ddd; --accent:#0b74ff; }
  body { font-family: system-ui, sans-serif; margin: 16px; background:#f5f5f5; }
  h1 { margin: 0 0 8px; }
  .muted { color:#666; font-size:12px; margin-top:2px; }

  .title-row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .mini-link { font-size:12px; color:var(--accent); text-decoration:underline; }
  .mini-link:visited { color:var(--accent); }

  .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .btn.primary { background:#0b74ff; border-color:#0b74ff; color:#fff; }
  .btn.ghost { background:#fff; border-color:#ccc; }
  .btn.danger { border-color:#f87171; color:#b91c1c; }
  .btn.danger:hover { background:#fee2e2; }

  .section { border:1px solid var(--border); border-radius:12px; padding:12px; margin-top:14px; background:#fff; }

  /* Trainer picker overlay */
  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; align-items:center; justify-content:center; z-index:99999; }
  .overlay.open { display:flex; }
  .overlay-card { background:#fff; padding:18px; border-radius:12px; min-width:280px; border:1px solid #e5e5e5; box-shadow:0 10px 30px rgba(0,0,0,.2); }
  .overlay-card h3 { margin:0 0 10px; }
  .overlay-actions { display:flex; gap:10px; margin-top:12px; justify-content:space-between; }

  /* Tabs (browser style) */
  .tabs-bar { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .tabs { display:flex; align-items:flex-end; gap:6px; flex-wrap:wrap; }
  .tab {
    position:relative; padding:8px 12px; border:1px solid var(--border);
    border-bottom:none; border-top-left-radius:10px; border-top-right-radius:10px;
    background:#f6f6f6; cursor:pointer; font-weight:600; color:#444;
  }
  .tab.active { background:#fff; color:#111; box-shadow:0 -1px 0 #fff inset; }
  .tab:hover { background:#fdfdfd; }

  /* Header row (Marks) */
  .marks-head {
    /* remove column | label | slider | 9 opts */
    grid-template-columns: 72px 100px 1fr repeat(9, 80px);
    display:grid; gap:6px; align-items:center;
    font-size:12px; color:#444; font-weight:600; margin-bottom:8px;
  }
  .head-center { text-align:center; }

  /* Mark rows as cards */
  .mark-item {
    /* remove column | label | slider | 9 opts */
    grid-template-columns: 72px 100px 1fr repeat(9, 80px);
    display:grid; gap:6px; align-items:center;
    background:#fafafa; padding:10px; border:1px solid #ddd; border-radius:10px;
    margin-bottom:12px; box-shadow: 0 1px 3px rgba(0,0,0,0.06);
  }
  .mark-label { font-weight:700; }
  .opt-cell { text-align:center; }
  .slider-wrap { grid-column: 3 / 4; } /* moved one column to the right */
  input[type="range"] { width:100%; }

  /* Per-checkbox labels: hidden on desktop, shown on mobile */
  .opt { display:flex; align-items:center; gap:8px; justify-content:center; }
  .opt span { display:none; font-size:13px; color:#333; }

  /* Mobile tweaks for Marks */
  @media (max-width: 768px) {
    .marks-head { display:none; }
    .mark-item { grid-template-columns: repeat(3, 1fr); grid-auto-rows: auto; }
    .mark-label { grid-column: 1 / -1; }
    .opt-cell { text-align:left; }
    .opt { justify-content:flex-start; }
    .opt span { display:inline; }
    .slider-wrap { grid-column: 1 / -1; order: 99; }
  }

  /* Board / chips (Marks) */
  .board-head { display:flex; gap:8px; justify-content:space-between; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
  .board-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .dock { display:flex; flex-wrap:wrap; gap:8px; padding:8px; border:1px dashed #cfcfcf; border-radius:10px; min-height:46px; }
  .board { display:grid; gap:var(--gap); margin-top:12px; } /* columns set via JS */
  .column { border:1px solid var(--border); border-radius:10px; min-height:140px; padding:8px; display:flex; flex-direction:column; gap:8px; background:#fff; }
  .column-title { font-weight:600; font-size:13px; color:#444; display:flex; align-items:center; justify-content:space-between; margin-bottom:6px; }
  .column-title .title { pointer-events:none; }

  .chip { user-select:none; padding:8px 10px; border:1px solid #bbb; border-radius:999px; background:#fff; font-size:14px; touch-action:none; cursor:grab; }
  .drag-ghost { position:fixed; left:0; top:0; pointer-events:none; transform:translate(-9999px,-9999px); z-index:9999; opacity:.95; box-shadow: 0 4px 14px rgba(0,0,0,0.15); background:#fff; }
  .drop-hint { outline:2px dashed #0b74ff; outline-offset:-4px; }

  /* === BLINDS === */
  .blinds-head {
    /* remove | label | slider | 5 opts */
    grid-template-columns: 72px 120px 1fr repeat(5, 110px);
    display:grid; gap:6px; align-items:center;
    font-size:12px; color:#444; font-weight:600; margin-bottom:8px;
  }
  .blind-item {
    /* remove | label | slider | 5 opts */
    grid-template-columns: 72px 120px 1fr repeat(5, 110px);
    display:grid; gap:6px; align-items:center;
    background:#fafafa; padding:10px; border:1px solid #ddd; border-radius:10px;
    margin-bottom:12px; box-shadow: 0 1px 3px rgba(0,0,0,0.06);
  }
  .blind-label { font-weight:700; }
  .blind-slider { grid-column: 3 / 4; } /* moved one column to the right */

  @media (max-width:768px){
    .blinds-head { display:none; }
    .blind-item { grid-template-columns: repeat(3, 1fr); grid-auto-rows:auto; }
    .blind-label { grid-column: 1 / -1; }
    .blind-item .opt-cell { text-align:left; }
    .blind-item .opt { justify-content:flex-start; }
    .blind-item .opt span { display:inline; }
    .blind-slider { grid-column: 1 / -1; order: 99; }
  }
  
  /* 1) Narrow the "Remove" column */
.marks-head, .mark-item { grid-template-columns: 44px 100px 1fr repeat(9, 80px); }
.blinds-head, .blind-item { grid-template-columns: 44px 120px 1fr repeat(5, 110px); }

/* 2) Compact icon-style buttons */
.btn.icon {
  padding: 0;
  width: 28px;
  height: 28px;
  min-width: 0;         /* prevent any default min-width */
  line-height: 1;
  display: inline-grid; /* center the X nicely */
  place-items: center;
  border-radius: 8px;
  box-sizing: border-box;
}

/* optional: small X buttons on column headers too */
.column-title .btn { width: 28px; height: 28px; padding: 0; min-width: 0; }

</style>
</head>
<body>
  <div class="title-row">
    <h1>Setups – Marks & Blinds</h1>
    <a id="changeUserLink" class="mini-link" href="https://morrowind4732.github.io/task-tracker/setups.html">change user</a>
  </div>
  <div class="muted" id="ctx">Loading…</div>

  <!-- Trainer chooser overlay -->
  <div class="overlay" id="trainerOverlay">
    <div class="overlay-card">
      <h3>Who are you?</h3>
      <div class="overlay-actions">
        <button class="btn primary" data-trainer="Scott">Scott</button>
        <button class="btn primary" data-trainer="Cody">Cody</button>
        <button class="btn primary" data-trainer="Brian">Brian</button>
      </div>
    </div>
  </div>

  <!-- Tabs / day -->
  <div class="section">
    <div class="tabs-bar">
      <div class="board-controls" style="margin-right:auto;">
        <label>Day: <input type="date" id="dayPicker"></label>
        <button class="btn ghost" id="todayBtn">Today</button>
      </div>
      <div class="tabs" id="tabs"></div>
      <button class="btn ghost" id="addSetupBtn">+ Add Setup</button>
      <button class="btn ghost danger" id="deleteSetupBtn">– Delete Setup</button>
    </div>
  </div>

  <!-- MARKS -->
  <div class="section" id="marksContainer">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <strong>Marks</strong>
      <button class="btn primary" id="addMarkBtn">+ Add Mark</button>
    </div>

    <div class="marks-head">
      <div class="head-center">Remove</div>
      <div></div>
      <div class="head-center">Distance</div>
      <div class="head-center">hand tossed</div>
      <div class="head-center">short check down</div>
      <div class="head-center">punch bird</div>
      <div class="head-center">no off</div>
      <div class="head-center">walk up</div>
      <div class="head-center">water mark</div>
      <div class="head-center">go bird</div>
      <div class="head-center">white coat</div>
      <div class="head-center">retire</div>
    </div>

    <div class="marks-list" id="marksList"></div>

    <div class="board-head">
      <strong></strong>
      <div class="board-controls">
        <button class="btn ghost" id="addColumnBtn">+ Add Group</button>
      </div>
    </div>
    <strong>Unassigned</strong>
    <div class="dock" id="dock"></div>
    <div class="board" id="board"><!-- dynamic columns --></div>
  </div>

  <!-- BLINDS -->
  <div class="section" id="blindsContainer">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <strong>Blinds</strong>
      <button class="btn primary" id="addBlindBtn">+ Add Blind</button>
    </div>

    <div class="blinds-head">
      <div class="head-center">Remove</div>
      <div></div>
      <div class="head-center">Distance</div>
      <div class="head-center">Water</div>
      <div class="head-center">Poison 1</div>
      <div class="head-center">Poison 2</div>
      <div class="head-center">Duck</div>
      <div class="head-center">W Drill</div>
    </div>

    <div class="blinds-list" id="blindsList"></div>
  </div>

  <div class="chip drag-ghost" id="ghost"></div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
// ---------- Firebase ----------
const firebaseConfig = {
  apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
  authDomain: "task-tracker-73b77.firebaseapp.com",
  projectId: "task-tracker-73b77",
  storageBucket: "task-tracker-73b77.firebasestorage.app",
  messagingSenderId: "795274673000",
  appId: "1:795274673000:web:0ea07130e45c72384134dd",
  measurementId: "G-VLW5KLY4FF"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ---------- UI refs ----------
const ctxEl  = document.getElementById('ctx');
const overlay = document.getElementById('trainerOverlay');
document.getElementById('changeUserLink').addEventListener('click', (e) => {
  e.preventDefault();
  const url = new URL(location.href);
  url.searchParams.delete('trainer');
  history.replaceState(null, '', url.toString());
  showTrainerPrompt();
});

// ---------- Date handling ----------
function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
const dayPicker = document.getElementById('dayPicker');
const todayBtn  = document.getElementById('todayBtn');
dayPicker.value = ymd(new Date());
todayBtn.addEventListener('click', ()=>{ dayPicker.value = ymd(new Date()); switchDay(dayPicker.value); });
let currentDateKey = dayPicker.value;

// ---------- Trainer selection ----------
const params = new URL(location.href).searchParams;
let trainerId = params.get('trainer') || '';
function setTrainer(name){
  trainerId = name;
  const url = new URL(location.href);
  url.searchParams.set('trainer', trainerId);
  history.replaceState(null, '', url.toString());
  ctxEl.textContent = `Trainer: ${trainerId}`;
  boot();
}
function showTrainerPrompt(){
  overlay.classList.add('open');
  overlay.querySelectorAll('button[data-trainer]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      overlay.classList.remove('open');
      setTrainer(btn.dataset.trainer);
    }, { once:true });
  });
}
if (trainerId) ctxEl.textContent = `Trainer: ${trainerId}`;

// ---------- Tabs state ----------
const tabsEl = document.getElementById('tabs');
let setupsMeta = [];       // [{id, name, order}]
let activeSetupId = null;

// ---------- Setup-level state (Marks + Blinds) ----------
/*
  state = {
    items:   [ {id, dist, options:{ ...marks flags... }} ],
    columns: { dock:[], cols:[ {items:[]}, ... ] },
    blinds:  [ {id, dist, options:{ water, poison1, poison2, duck, wDrill }} ]
  }
*/
let state = { items: [], columns: { dock: [], cols: [] }, blinds: [] };

// ---------- Snapshot control ----------
let unsubSetups = null;          // listener for setups list
let unsubSetupDoc = null;        // listener for active setup
let suppressSetupDocSnapshots = false;

// ---------- DOM refs ----------
const dock  = document.getElementById('dock');
const board = document.getElementById('board');
const ghost = document.getElementById('ghost');

// ---------- Helpers (Marks) ----------
const OPTION_KEYS = [
  { key:'handTossed',     label:'hand tossed' },
  { key:'shortCheckDown', label:'short check down' },
  { key:'punchBird',      label:'punch bird' },
  { key:'noOff',          label:'no off' },
  { key:'walkUp',         label:'walk up' },
  { key:'waterMark',      label:'water mark' },
  { key:'goBird',         label:'go bird' },
  { key:'whiteCoat',      label:'white coat' },
  { key:'retire',         label:'retire' },
];
// ---------- Helpers (Blinds) ----------
const BLIND_OPTION_KEYS = [
  { key:'water',   label:'Water' },
  { key:'poison1', label:'Poison 1' },
  { key:'poison2', label:'Poison 2' },
  { key:'duck',    label:'Duck' },
  { key:'wDrill',  label:'W Drill' },
];

function byId(id){ return state.items.find(i => i.id === id); }
function indexOfId(id){ return state.items.findIndex(i => i.id === id); }
function makeId(){ return 'm_' + Math.random().toString(36).slice(2,9); }
function clampToStep(v){ return Math.max(0, Math.min(400, Math.round(v/25)*25)); }

// Labels
function markTextFrom(id){ const item = byId(id); const idx = indexOfId(id); const number = idx >= 0 ? (idx + 1) : '?'; const dist = item?.dist ?? 0; return `#${number} - ${dist} yards`; }
function optionsSummary(id){
  const item = byId(id); if (!item || !item.options) return '';
  return OPTION_KEYS.filter(o => !!item.options[o.key]).map(o => o.label).join(', ');
}
function chipTextFrom(id){
  const base = markTextFrom(id);
  const item = byId(id); if (!item) return base;
  const o = item.options || {};
  const codes = [];
  if (o.handTossed) codes.push('HT');
  if (o.goBird)     codes.push('GO');
  if (o.whiteCoat)  codes.push('WC');
  if (o.retire)     codes.push('RT');
  return codes.length ? `${base} ${codes.join(' ')}` : base;
}

// Columns helpers (Marks board)
function collectColItems(){ const out=[]; (state.columns.cols||[]).forEach(c => (c?.items||[]).forEach(id => out.push(id))); return out; }
function removeIdFromAll(id){
  state.columns.dock = state.columns.dock.filter(x => x !== id);
  state.columns.cols = state.columns.cols.map(c => ({ items: (c.items || []).filter(x => x !== id) }));
}
function ensureAllIdsPlaced(){
  const placed = new Set([ ...state.columns.dock, ...collectColItems() ]);
  for (const it of state.items) if (!placed.has(it.id)) state.columns.dock.push(it.id);
  state.columns.dock = state.columns.dock.filter(id => byId(id));
  state.columns.cols = state.columns.cols.map(c => ({ items: (c.items || []).filter(id => byId(id)) }));
}
function ensureMinColumns(n=2){ while (state.columns.cols.length < n) state.columns.cols.push({ items: [] }); }

// ---------- Firestore refs ----------
const dayDocPath = () => db.collection('setups').doc(trainerId).collection('days').doc(currentDateKey);
const setupsColl = () => dayDocPath().collection('setups');
const setupDocRef = () => (activeSetupId ? setupsColl().doc(activeSetupId) : null);

// ---------- Save current setup ----------
async function save(){
  const ref = setupDocRef(); if (!ref) return;
  ensureAllIdsPlaced();
  await ref.set({
    name: currentSetupName(),
    order: currentSetupOrder(),
    items: state.items,
    columns: { dock: state.columns.dock, cols: state.columns.cols },
    blinds: state.blinds,
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    dateKey: currentDateKey,
    trainer: trainerId
  }, { merge: true });
}

// ---------- Tabs UI ----------
function currentSetupMeta(){ return setupsMeta.find(s => s.id === activeSetupId) || null; }
function currentSetupName(){ return currentSetupMeta()?.name || 'Setup'; }
function currentSetupOrder(){ return currentSetupMeta()?.order ?? 1; }

function renderTabs(){
  tabsEl.innerHTML = '';
  setupsMeta.sort((a,b)=>(a.order ?? 0)-(b.order ?? 0)).forEach((meta, i)=>{
    const b = document.createElement('button');
    b.className = 'tab' + (meta.id===activeSetupId ? ' active' : '');
    b.textContent = meta.name || `Setup ${i+1}`;
    b.addEventListener('click', ()=>{ if (meta.id !== activeSetupId) setActiveSetup(meta.id); });
    tabsEl.appendChild(b);
  });
}

// ---------- Setup collection listener ----------
async function attachSetupsListener(){
  if (unsubSetups){ try{unsubSetups();}catch(e){} unsubSetups=null; }
  unsubSetups = setupsColl().orderBy('order').onSnapshot(async snap=>{
    const list=[];
    snap.forEach(doc=>{
      const d=doc.data()||{};
      list.push({ id:doc.id, name:d.name||'Setup', order: typeof d.order==='number'?d.order:9999 });
    });
    setupsMeta = list;
    if (setupsMeta.length===0){
      // create first setup
      const newDoc = setupsColl().doc();
      await newDoc.set({
        name:'Setup 1', order:1,
        items:[], columns:{ dock:[], cols:[{items:[]},{items:[]}] },
        blinds:[],
        trainer:trainerId, dateKey: currentDateKey,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      setupsMeta = [{ id:newDoc.id, name:'Setup 1', order:1 }];
    }
    renderTabs();

    // pick active
    const lsKey = `activeSetup:${trainerId}:${currentDateKey}`;
    const wanted = localStorage.getItem(lsKey);
    const exists = setupsMeta.some(s=>s.id===wanted);
    const firstId = setupsMeta[0]?.id;
    const nextActive = exists ? wanted : firstId;
    if (nextActive && nextActive !== activeSetupId) setActiveSetup(nextActive, { fromList:true });
  });
}

// ---------- Active setup doc listener ----------
function setActiveSetup(id){
  activeSetupId = id;
  localStorage.setItem(`activeSetup:${trainerId}:${currentDateKey}`, id);
  renderTabs();

  if (unsubSetupDoc){ try{unsubSetupDoc();}catch(e){} unsubSetupDoc=null; }
  state = { items: [], columns:{ dock:[], cols:[] }, blinds: [] };
  renderAll();

  const ref = setupDocRef(); if (!ref) return;
  unsubSetupDoc = ref.onSnapshot(async snap=>{
    if (!snap.exists) {
      // If the requested setup doesn't exist, switch to the first available.
      const firstId = setupsMeta[0]?.id;
      if (firstId && firstId !== activeSetupId) {
        setActiveSetup(firstId);
      }
      // If there are no setups at all, attachSetupsListener will create one.
      return;
    }

    const data = snap.data() || {};

    // ----- Items (Marks)
    state.items = Array.isArray(data.items) ? data.items.map(it => ({
      id: it.id,
      dist: typeof it.dist === 'number' ? clampToStep(it.dist) : 0,
      options: Object.assign({
        handTossed:false, shortCheckDown:false, punchBird:false,
        noOff:false, walkUp:false, waterMark:false,
        goBird:false, whiteCoat:false, retire:false
      }, it.options || {})
    })) : [];

    // ----- Columns (Marks)
    let colsShape = data.columns;
    if (!colsShape) colsShape = { dock: [], cols: [{items:[]},{items:[]}] };
    if (Array.isArray(colsShape.cols) && colsShape.cols.every(el=>Array.isArray(el))){
      colsShape = { dock:Array.isArray(colsShape.dock)?colsShape.dock:[], cols: colsShape.cols.map(a=>({items:a.slice()})) };
    } else if (Array.isArray(colsShape.col1)) {
      const legacyKeys = Object.keys(colsShape).filter(k=>k.startsWith('col'))
        .sort((a,b)=>parseInt(a.replace('col',''))-parseInt(b.replace('col','')));
      colsShape = { dock:Array.isArray(colsShape.dock)?colsShape.dock:[], cols: legacyKeys.map(k=>({items:Array.isArray(colsShape[k])?colsShape[k]:[]})) };
    }
    state.columns = {
      dock: Array.isArray(colsShape.dock)?colsShape.dock:[],
      cols: Array.isArray(colsShape.cols)?colsShape.cols:[{items:[]},{items:[]}]
    };
    ensureMinColumns(2);
    ensureAllIdsPlaced();

    // ----- Blinds
    state.blinds = Array.isArray(data.blinds) ? data.blinds.map(bl => ({
      id: bl.id,
      dist: typeof bl.dist==='number' ? clampToStep(bl.dist) : 0,
      options: Object.assign({
        water:false, poison1:false, poison2:false, duck:false, wDrill:false
      }, bl.options || {})
    })) : [];

    renderAll();
  });
}


// ---------- Switch day ----------
async function switchDay(key){
  currentDateKey = key;
  if (unsubSetups){ try{unsubSetups();}catch{} unsubSetups=null; }
  if (unsubSetupDoc){ try{unsubSetupDoc();}catch{} unsubSetupDoc=null; }
  setupsMeta = [];
  activeSetupId = null;
  state = { items: [], columns:{ dock:[], cols:[] }, blinds: [] };
  renderAll(); renderTabs();
  if (trainerId) attachSetupsListener();
}
dayPicker.addEventListener('change', ()=>switchDay(dayPicker.value));

// ---------- UI: MARKS ----------
function renderMarksList() {
  const marksList = document.getElementById('marksList');
  marksList.innerHTML = '';

  state.items.forEach((item) => {
    item.options = Object.assign({
      handTossed:false, shortCheckDown:false, punchBird:false,
      noOff:false, walkUp:false, waterMark:false,
      goBird:false, whiteCoat:false, retire:false
    }, item.options || {});

    const row = document.createElement('div');
    row.className = 'mark-item';
    row.dataset.id = item.id;

// Marks delete
const del = document.createElement('button');
del.className = 'btn icon';
del.textContent = '×';    // looks cleaner than 'X'
    del.addEventListener('click', async () => {
      state.items = state.items.filter(x => x.id !== item.id);
      removeIdFromAll(item.id);
      renderAll();
      suppressSetupDocSnapshots = true;
      await save().finally(()=>{ suppressSetupDocSnapshots=false; });
    });

    const label = document.createElement('div');
    label.className = 'mark-label';
    label.textContent = markTextFrom(item.id);

    const sliderWrap = document.createElement('div');
    sliderWrap.className = 'slider-wrap';
    const slider = document.createElement('input');
    slider.type = 'range'; slider.min = 0; slider.max = 400; slider.step = 25;
    slider.value = item.dist;
    slider.addEventListener('input', () => {
      item.dist = clampToStep(Number(slider.value));
      label.textContent = markTextFrom(item.id);
      document.querySelectorAll(`.chip[data-id="${item.id}"]`).forEach(c => {
        c.textContent = chipTextFrom(item.id);
        const sum = optionsSummary(item.id); c.title = sum || '';
      });
    });
    slider.addEventListener('change', save);
    sliderWrap.appendChild(slider);

    const optCells = OPTION_KEYS.map(({key, label:optLabel}) => {
      const cell = document.createElement('div');
      cell.className = 'opt-cell';
      const lab = document.createElement('label'); lab.className = 'opt';
      const cb = document.createElement('input'); cb.type = 'checkbox';
      cb.checked = !!item.options[key]; cb.title = optLabel;
      cb.addEventListener('change', async () => {
        item.options[key] = cb.checked;
        document.querySelectorAll(`.chip[data-id="${item.id}"]`).forEach(c => {
          c.textContent = chipTextFrom(item.id);
          const sum = optionsSummary(item.id); c.title = sum || '';
        });
        suppressSetupDocSnapshots = true;
        await save().finally(()=>{ suppressSetupDocSnapshots=false; });
      });
      const txt = document.createElement('span'); txt.textContent = optLabel;
      lab.append(cb, txt); cell.appendChild(lab); return cell;
    });

    // Append in new order: delete first, then label, slider, then options
    row.appendChild(del);
    row.appendChild(label);
    row.appendChild(sliderWrap);
    optCells.forEach(c => row.appendChild(c));

    marksList.appendChild(row);
  });

  marksList.querySelectorAll('.mark-label').forEach((el, idx) => {
    const id = state.items[idx]?.id;
    if (id) el.textContent = markTextFrom(id);
  });
}

function makeChip(id) {
  const chip = document.createElement('div');
  chip.className = 'chip';
  chip.dataset.id = id;
  chip.textContent = chipTextFrom(id);
  const sum = optionsSummary(id);
  if (sum) chip.title = sum;
  return chip;
}
function renderColumnsAndDock() {
  dock.innerHTML = '';
  state.columns.dock.forEach(id => dock.appendChild(makeChip(id)));

  board.innerHTML = '';
  const count = Math.max(1, state.columns.cols.length);
  board.style.gridTemplateColumns = `repeat(${count}, minmax(0, 1fr))`;

  state.columns.cols.forEach((colData, i) => {
    const col = document.createElement('div');
    col.className = 'column';
    col.dataset.colindex = String(i);

    const title = document.createElement('div');
    title.className = 'column-title';
    const tText = document.createElement('span');
    tText.className = 'title';
    tText.textContent = `Group ${i + 1}`;

    const remBtn = document.createElement('button');
    remBtn.className = 'btn';
    remBtn.textContent = 'X';
    remBtn.title = 'Remove this column';
    remBtn.addEventListener('click', async () => {
      state.columns.dock.push(...(state.columns.cols[i].items || []));
      state.columns.cols.splice(i, 1);
      ensureMinColumns(2);
      renderColumnsAndDock();
      suppressSetupDocSnapshots = true;
      await save().finally(()=>{ suppressSetupDocSnapshots=false; });
    });

    title.append(tText, remBtn);
    col.appendChild(title);

    (colData.items || []).forEach(id => col.appendChild(makeChip(id)));
    board.appendChild(col);
  });
}

// ---------- UI: BLINDS ----------
function blindTextFromIndex(idx, dist){ return `#${idx+1} - ${dist} yards`; }

function renderBlindsList(){
  const blindsList = document.getElementById('blindsList');
  blindsList.innerHTML = '';

  state.blinds.forEach((blind, idx) => {
    blind.options = Object.assign({
      water:false, poison1:false, poison2:false, duck:false, wDrill:false
    }, blind.options || {});

    const row = document.createElement('div');
    row.className = 'blind-item';
    row.dataset.id = blind.id;

// Blinds delete
const del = document.createElement('button');
del.className = 'btn icon';
del.textContent = '×';
    del.addEventListener('click', async ()=>{
      state.blinds = state.blinds.filter(b => b.id !== blind.id);
      renderBlindsList();
      suppressSetupDocSnapshots = true;
      await save().finally(()=>{ suppressSetupDocSnapshots=false; });
    });

    const label = document.createElement('div');
    label.className = 'blind-label';
    label.textContent = blindTextFromIndex(idx, blind.dist ?? 0);

    const sliderWrap = document.createElement('div');
    sliderWrap.className = 'blind-slider';
    const slider = document.createElement('input');
    slider.type = 'range'; slider.min = 0; slider.max = 400; slider.step = 25;
    slider.value = blind.dist ?? 0;
    slider.addEventListener('input', () => {
      blind.dist = clampToStep(Number(slider.value));
      label.textContent = blindTextFromIndex(idx, blind.dist);
    });
    slider.addEventListener('change', save);
    sliderWrap.appendChild(slider);

    const optCells = BLIND_OPTION_KEYS.map(({key, label:optLabel}) => {
      const cell = document.createElement('div');
      cell.className = 'opt-cell';
      const lab = document.createElement('label'); lab.className = 'opt';
      const cb = document.createElement('input'); cb.type = 'checkbox';
      cb.checked = !!blind.options[key]; cb.title = optLabel;
      cb.addEventListener('change', async ()=>{
        blind.options[key] = cb.checked;
        suppressSetupDocSnapshots = true;
        await save().finally(()=>{ suppressSetupDocSnapshots=false; });
      });
      const txt = document.createElement('span'); txt.textContent = optLabel;
      lab.append(cb, txt); cell.appendChild(lab); return cell;
    });

    // New order: delete first, then label, slider, options
    row.appendChild(del);
    row.appendChild(label);
    row.appendChild(sliderWrap);
    optCells.forEach(c => row.appendChild(c));

    blindsList.appendChild(row);
  });

  // refresh numbering after deletions
  blindsList.querySelectorAll('.blind-label').forEach((el, i)=>{
    const dist = state.blinds[i]?.dist ?? 0;
    el.textContent = blindTextFromIndex(i, dist);
  });
}

// ---------- Render all ----------
function renderAll(){ renderMarksList(); renderColumnsAndDock(); renderBlindsList(); }

// ---------- Drag & drop (chips for Marks) ----------
let dragging = null, offsetX = 0, offsetY = 0, activePointerId = null;
function setGhost(text, x, y) { ghost.textContent = text; ghost.style.transform = `translate(${x - offsetX}px, ${y - offsetY}px)`; }
function containers() { return [ ...document.querySelectorAll('.column'), dock ]; }
function nearestDropContainer(x, y) { let best=null, bestDist=Infinity; for (const t of containers()){ const r=t.getBoundingClientRect(); if (x<r.left||x>r.right||y<r.top||y>r.bottom) continue; const cx=(r.left+r.right)/2, cy=(r.top+r.bottom)/2; const d=Math.hypot(x-cx, y-cy); if (d<bestDist){ best=t; bestDist=d; } } return best; }
function highlight(el, on) { el.classList.toggle('drop-hint', !!on); }
function clearHighlights() { containers().forEach(c => highlight(c, false)); }
function hideGhost() { ghost.style.transform = 'translate(-9999px,-9999px)'; ghost.textContent = ''; }
function endDragCleanup() { clearHighlights(); hideGhost(); dragging = null; activePointerId = null; document.body.style.cursor = ''; }

document.addEventListener('pointerdown', e => {
  const chip = e.target.closest('.chip'); if (!chip) return;
  e.preventDefault();
  activePointerId = e.pointerId;
  chip.setPointerCapture?.(activePointerId);
  dragging = chip;
  const r = chip.getBoundingClientRect();
  offsetX = e.clientX - r.left; offsetY = e.clientY - r.top;
  setGhost(chip.textContent, e.clientX, e.clientY);
  document.body.style.cursor = 'grabbing';
});
document.addEventListener('pointermove', e => {
  if (!dragging || e.pointerId !== activePointerId) return;
  setGhost(dragging.textContent, e.clientX, e.clientY);
  clearHighlights();
  const t = nearestDropContainer(e.clientX, e.clientY);
  if (t) highlight(t, true);
});
document.addEventListener('pointerup', async e => {
  if (!dragging || e.pointerId !== activePointerId) return;
  dragging.releasePointerCapture?.(activePointerId);
  clearHighlights();
  const id = dragging.dataset.id;
  const t = nearestDropContainer(e.clientX, e.clientY);
  const oldParent = dragging.parentElement;

  if (!t) { oldParent.appendChild(dragging); endDragCleanup(); return; }

  removeIdFromAll(id);
  if (t === dock) { state.columns.dock.push(id); dock.appendChild(dragging); }
  else {
    const idx = Number(t.dataset.colindex);
    if (!Number.isNaN(idx) && state.columns.cols[idx]) { (state.columns.cols[idx].items ||= []).push(id); t.appendChild(dragging); }
    else { state.columns.dock.push(id); dock.appendChild(dragging); }
  }
  hideGhost(); dragging = null; activePointerId = null; document.body.style.cursor = '';

  suppressSetupDocSnapshots = true;
  try { await save(); }
  catch(err){
    console.error('Save failed after drop:', err);
    removeIdFromAll(id);
    if (oldParent === dock) state.columns.dock.push(id);
    else {
      const idxOld = Number(oldParent.dataset.colindex);
      if (!Number.isNaN(idxOld) && state.columns.cols[idxOld]) (state.columns.cols[idxOld].items ||= []).push(id);
      else state.columns.dock.push(id);
    }
    renderColumnsAndDock();
  }
  finally { suppressSetupDocSnapshots = false; }
});
document.addEventListener('pointercancel', () => {
  if (!dragging) return;
  dragging.releasePointerCapture?.(activePointerId);
  endDragCleanup();
});

// ---------- Buttons ----------
document.getElementById('addMarkBtn').addEventListener('click', async () => {
  const id = makeId();
  state.items.push({
    id,
    dist: 0,
    options: {
      handTossed:false, shortCheckDown:false, punchBird:false,
      noOff:false, walkUp:false, waterMark:false,
      goBird:false, whiteCoat:false, retire:false
    }
  });
  state.columns.dock.push(id);
  renderAll();
  suppressSetupDocSnapshots = true;
  await save().finally(()=>{ suppressSetupDocSnapshots=false; });
});

document.getElementById('addColumnBtn').addEventListener('click', async () => {
  state.columns.cols.push({ items: [] });
  suppressSetupDocSnapshots = true;
  try { await save(); }
  finally { suppressSetupDocSnapshots = false; renderColumnsAndDock(); }
});

document.getElementById('addBlindBtn').addEventListener('click', async () => {
  const id = makeId();
  state.blinds.push({
    id,
    dist: 0,
    options: { water:false, poison1:false, poison2:false, duck:false, wDrill:false }
  });
  renderBlindsList();
  suppressSetupDocSnapshots = true;
  await save().finally(()=>{ suppressSetupDocSnapshots=false; });
});

document.getElementById('addSetupBtn').addEventListener('click', async () => {
  const nextOrder = (Math.max(0, ...setupsMeta.map(s => s.order || 0)) + 1) || 1;
  const nextIndex = (setupsMeta.length + 1);
  const name = `Setup ${nextIndex}`;
  const newDoc = setupsColl().doc();
  await newDoc.set({
    name, order: nextOrder,
    items: [],
    columns: { dock: [], cols: [{items:[]},{items:[]}] },
    blinds: [],
    trainer: trainerId, dateKey: currentDateKey,
    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
  });
  localStorage.setItem(`activeSetup:${trainerId}:${currentDateKey}`, newDoc.id);
});

// Deep-delete helper for setups/<id>/scores/*/runs/*
async function deleteSetupDeep(setupRef){
  // Delete nested scores/*/runs/*
  const scoresSnap = await setupRef.collection('scores').get();
  for (const dogDoc of scoresSnap.docs) {
    const runsSnap = await dogDoc.ref.collection('runs').get();
    // batch delete runs for this dog
    if (!runsSnap.empty) {
      const batch = db.batch();
      runsSnap.forEach(r => batch.delete(r.ref));
      await batch.commit();
    }
    await dogDoc.ref.delete();
  }
  // Delete the setup doc itself
  await setupRef.delete();
}

document.getElementById('deleteSetupBtn').addEventListener('click', async () => {
  if (!activeSetupId) return;

  // Don't allow deleting the last setup
  if (setupsMeta.length <= 1) {
    alert('You must have at least one setup. Add another before deleting this one.');
    return;
  }

  const meta = setupsMeta.find(s => s.id === activeSetupId) || { name: 'Setup' };
  const ok = confirm(`Delete "${meta.name}"?\nThis will also remove its marks/blinds and any saved scores for this setup.`);
  if (!ok) return;

  const ref = setupDocRef(); // setups/<trainer>/days/<date>/setups/<activeSetupId>
  try {
    await deleteSetupDeep(ref);

    // Choose a new active setup (first remaining by order)
    const remaining = setupsMeta.filter(s => s.id !== activeSetupId)
                                .sort((a,b)=>(a.order??0)-(b.order??0));
    if (remaining.length) {
      const next = remaining[0].id;
      localStorage.setItem(`activeSetup:${trainerId}:${currentDateKey}`, next);
      setActiveSetup(next);
    }
  } catch (e) {
    console.error('Delete setup failed:', e);
    alert('Sorry, deleting this setup failed. Check the console for details.');
  }
});



// ---------- Boot ----------
async function boot(){
  if (!trainerId) return showTrainerPrompt();
  ctxEl.textContent = `Trainer: ${trainerId}`;
  await switchDay(currentDateKey);
}

if (trainerId) boot(); else showTrainerPrompt();
</script>
</body>
</html>
