<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voice Flag Tester</title>
<style>
  :root{
    --accent:#0b74ff; --bg:#f6f7fb; --card:#fff; --muted:#667085; --border:#e4e7ec;
    --danger:#ef4444; --ok:#16a34a;
  }
  * { box-sizing: border-box; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:#101828;}
  header{padding:20px 24px 8px;}
  h1{margin:0 0 6px;font-size:28px;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:14px}
  .wrap{padding:0 24px 24px;max-width:1100px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 1px 2px rgba(16,24,40,.04)}
  .items{display:flex;flex-direction:column;gap:14px}
  .row{display:grid;grid-template-columns:minmax(160px,260px) 1fr auto;gap:14px;align-items:center;padding:12px;border:1px solid var(--border);border-radius:14px;background:#fafafa}
  .kind{font-size:12px;font-weight:800;color:#344054}
  .title{font-size:16px;font-weight:800}
  /* FLAGS AREA ‚Üí responsive columns */
  .chips{
    display:grid; gap:8px;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    align-items:start;
  }
  .chip{border:1px solid #d0d5dd;background:#fff;border-radius:999px;padding:6px 10px;font-size:13px;user-select:none;display:block}
  .chip.on{background:#eef4ff;border-color:#c7d7fe}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .mic{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:999px;background:#fff;border:1px solid #d0d5dd;cursor:pointer;font-weight:700}
  .mic .dot{width:10px;height:10px;border-radius:50%;background:#94a3b8}
  .row.listening .mic{border-color:#ffb4b4;box-shadow:0 0 0 4px rgba(255,59,48,.12)}
  .row.listening .mic .dot{background:#ff3b30;animation:pulse 1s infinite alternate}
  @keyframes pulse{from{transform:scale(.9)}to{transform:scale(1.2)}}
  input[type=range]{width:220px}
  .score{font-weight:800;min-width:44px;text-align:right;font-variant-numeric:tabular-nums}
  .bar{display:flex;gap:10px;align-items:center;padding:0 24px 12px;flex-wrap:wrap}
  .status{color:var(--muted);font-weight:700}
  .btn{appearance:none;border:1px solid var(--border);background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  .btn.ghost{background:#fff}
  .btn.small{padding:6px 8px;border-radius:8px;font-size:12px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:12px}
  .pill.ok{border-color:#c7f1d9;background:#ecfdf5;color:#065f46}
  .pill.bad{border-color:#ffd5d5;background:#fff1f1;color:#7f1d1d}
/* Hide the old grid; voice still toggles in the background */
.chips{ display:none; }

/* Red circle ‚Äúflag‚Äù button */
.flagBtn{
  width:48px; height:48px; border-radius:999px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#FFFFFF; color:#fff; border:none; cursor:pointer;
  box-shadow:0 10px 24px rgba(239,68,68,.35);
  touch-action:none; /* enables swipe tracking on mobile */
  font-size:20px; font-weight:900;
}
.flagBtn:active{ transform:translateY(1px); }

/* Peek overlay: big, easy-to-read list */
.peek{ width:min(420px,92vw); background:#fff; border-radius:16px;
  border:1px solid var(--border); padding:16px; text-align:center;
  box-shadow:0 20px 50px rgba(0,0,0,.25);
}
.peek-head{font-weight:800; font-size:14px; color:#475467; margin-bottom:8px}
.peek-list{display:flex; flex-direction:column; gap:12px; margin:10px 0 6px}
.peek-flag{font-size:22px; font-weight:800; padding:8px 12px; border-radius:12px;
  background:#f8fafc; border:1px solid #e5e7eb}

/* Pull-to-clear zone at bottom of the card */
.pull-zone{position:relative; height:64px; border-radius:12px; overflow:hidden;
  background:#fafafa; border:1px dashed #e5e7eb; margin-top:8px}
.pull-bar{position:absolute; left:0; top:0; width:100%; height:0;
  background:rgba(239,68,68,.25); transition:height .1s linear}
.pull-zone.ready .pull-bar{ background:rgba(239,68,68,.45); }
.pull-zone.cleared{ background:#fee2e2; border-color:#fecaca; }
.pull-label{position:relative; z-index:1; line-height:64px; font-weight:800; color:#7f1d1d}


  /* Overlay (missed phrases) */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:9999;padding:16px}
  .overlay.open{display:flex;}
  .sheet{width:min(720px,100%);max-height:86vh;overflow:auto;background:#fff;border-radius:16px;border:1px solid var(--border);box-shadow:0 20px 50px rgba(0,0,0,.25)}
  .sheet-head{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--border)}
  .sheet-body{padding:12px 16px;display:flex;flex-direction:column;gap:10px}
  .missed-item{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:12px}
  .missed-meta{display:flex;flex-direction:column;gap:4px}
  .missed-phrase{font-weight:800}
  .missed-row{color:#475467;font-size:12px}
  .missed-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sheet-foot{padding:12px 16px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end}
  .hint{color:#475467;font-size:12px}

  /* Overlay (master log) */
  .log-list{display:flex;flex-direction:column;gap:8px}
  .log-item{display:flex;justify-content:space-between;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:10px}
  .count{font-variant-numeric:tabular-nums;font-weight:800}
  
  /* Kill native long-press callout + text selection where we hold */
.flagBtn,
#peekOverlay,
#peekOverlay *,
.mic,
.row {
  -webkit-touch-callout: none; /* iOS copy/paste bubble */
  -webkit-user-select: none;
  user-select: none;
}

.flagBtn,
.peek { touch-action: none; } /* prevent native gestures during hold */

  
</style>
</head>
<body>
  <header>
    <h1>Voice Flag Tester</h1>
    <div class="sub">Click a row‚Äôs üé§; that utterance applies only to that row. Say multiple flags and a score in one go.</div>
  </header>

  <div class="bar">
    <button id="clearBtn" class="btn">Clear all</button>
    <button id="viewLogBtn" class="btn ghost">Unassigned Log</button>
    <div id="status" class="status">Status: idle</div>
  </div>

  <div class="wrap">
    <div class="card">
      <div id="items" class="items"></div>
    </div>

    <div class="card" style="margin-top:12px">
      <strong>Say things like‚Ä¶</strong>
      <ul class="sub" style="margin:6px 0 0 18px">
        <li>‚Äúflag big hunt and overran, rating seven point five‚Äù</li>
        <li>‚Äúremove didn‚Äôt mark and poor initial, increase by point five‚Äù</li>
        <li>‚Äúclear flags, score 6‚Äù</li>
        <li>‚Äú7.5‚Äù (just a number sets the score)</li>
      </ul>
    </div>
  </div>

  <!-- Missed phrases overlay -->
  <div id="missedOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases</strong></div>
        <div class="hint">These didn‚Äôt map to flags. Tap üé§ to retry or apply a suggestion.</div>
      </div>
      <div id="missedList" class="sheet-body"></div>
      <div class="sheet-foot">
        <button class="btn" id="missedClose">Close</button>
        <button class="btn ghost" id="missedClear">Dismiss all</button>
      </div>
    </div>
  </div>
  

  <!-- Master log overlay -->
  <div id="logOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases ‚Äì log</strong></div>
        <div class="hint">Kept in localStorage to spot trends. Clear anytime.</div>
      </div>
      <div id="logList" class="sheet-body log-list"></div>
      <div class="sheet-foot">
        <button class="btn" id="logClose">Close</button>
        <button class="btn danger" style="border-color:#fca5a5;color:#7f1d1d" id="logClear">Clear log</button>
      </div>
    </div>
  </div>
  
<!-- Active-flags peek (hold the red circle, swipe down to clear) -->
<div id="peekOverlay" class="overlay" aria-hidden="true">
  <div class="peek">
    <div class="peek-head">Active flags for this item</div>
    <div id="peekList" class="peek-list"></div>

    <div id="pullZone" class="pull-zone">
      <div id="pullBar" class="pull-bar"></div>
      <div id="pullLabel" class="pull-label">Swipe down to clear</div>
    </div>
  </div>
</div>

<script>
/* ---------------- Flag dictionary & variants (for positioning/fuzzy) ---------------- */
const FLAGS = [
  { key:'bigHunt',        label:'Big Hunt',         variants:['big hunt'] },
  { key:'marginalHunt',   label:'Marginal Hunt',    variants:['marginal hunt'] },

  // add split/inflected variants
  { key:'overran',        label:'Overran',          variants:['overran','over run','over-run','over ran','ran over'] },

  { key:'shortCheckDown', label:'Short Checkdown',  variants:[
      'short checkdown','short check down','short-check down','short check-down'
    ] },

  // allow articles + shorthand
  { key:'backSideOfGun',  label:'Backside of Gun',  variants:[
      'backside of gun','backside of the gun','back side of gun','back side of the gun',
      'back of gun','back of the gun'
    ] },

  { key:'handled',        label:'Handled',          variants:['handled'] },
  { key:'castRefusal',    label:'Cast Refusal',     variants:['cast refusal','cast refused','refused cast'] },

  // sit/sat + article
  { key:'sitOnWhistle',   label:'Sit on Whistle',   variants:[
      'sit on whistle','sit on the whistle','sat on whistle','sat on the whistle'
    ] },

  // didn‚Äôt vs did not
  { key:'didntMark',      label:"Didn't Mark",      variants:["didn't mark",'didnt mark','did not mark'] },

  { key:'poorInitial',    label:'Poor Initial',     variants:['poor initial'] },

  // head swing vs swung
  { key:'headswing',      label:'Headswing',        variants:['headswing','head swing','head swung'] },

  { key:'break',          label:'Broke',            variants:['broke','break'] },
  { key:'switched',       label:'Switched',         variants:['switched','switch','did a switch'] },
  { key:'noGo',           label:'No-Go',            variants:['no go','no-go'] },

  // pick-up hyphen + article
  { key:'pickedUpPoison', label:'Poison Pick Up',   variants:[
      'poison pick up','poison pick-up','picked up poison','picked up the poison'
    ] },
  { key:'noPickUp',       label:'No Pick Up',       variants:[
      'no pick up','no pick-up','no pickup'
    ] },

  { key:'stoodOut',       label:'Stood Out',        variants:['stood out','stood way out'] },
  { key:'popped',         label:'Popped',           variants:['popped','pop'] },
];
const FLAG_MAP = Object.fromEntries(FLAGS.map(f=>[f.key,f]));

/* Regex bundle for fast detection (multi-match) */
/* NOTE: these broaden matching but preserve existing behavior */
const FLAG_RX = {
  bigHunt:        [/big[\s-]*hunt/gi],
  marginalHunt:   [/marginal[\s-]*hunt/gi],

  // overran / over ran / over run / ran over
  overran:        [/\boverran\b/gi, /\bover[\s-]*(?:ran|run)\b/gi, /\bran\s+over\b/gi],

  // short checkdown / short check down / hyphenated
  shortCheckDown: [/short[\s-]*check[\s-]*down/gi, /short[\s-]*checkdown/gi],

  // backside of (the) gun | back of (the) gun
  backSideOfGun:  [
    /back\s*side\s*of\s*(?:the\s*)?gun/gi,
    /backside\s*of\s*(?:the\s*)?gun/gi,
    /back\s*of\s*(?:the\s*)?gun/gi
  ],

  handled:        [/\bhandled?\b/gi],

  // cast refusal + inflections
  castRefusal:    [/cast[\s-]*refusal/gi, /cast[\s-]*refused/gi, /refused[\s-]*cast/gi],

  // sit|sat on (the) whistle
  sitOnWhistle:   [/\b(?:sit|sat)\s*on\s*(?:the\s*)?whistle\b/gi],

  // didn't|did not mark
  didntMark:      [/(?:didn'?t|did\s+not)\s*mark/gi],

  poorInitial:    [/poor\s*initial/gi],

  // head swing / headswing / head swung
  headswing:      [/head\s*swing/gi, /\bheadswing\b/gi, /\bhead\s*swung\b/gi],

  break:          [/\bbroke?\b/gi, /\bbreak\b/gi],
  switched:       [/\bswitch(?:ed|)\b/gi, /did\s*(?:a\s*)?switch\b/gi],
  noGo:           [/\bno[-\s]?go\b/gi],

  // poison pick up (hyphen tolerant) | picked up (the) poison
  pickedUpPoison: [/poison\s*pick[-\s]*up/gi, /picked\s*up\s*(?:the\s*)?poison/gi],

  // no pick up | no pick-up | no pickup
  noPickUp:       [/\bno\s*pick[-\s]*up\b/gi, /\bno\s*pickup\b/gi],

  stoodOut:       [/stood\s*out/gi],
  popped:         [/\bpopped?\b/gi],
};

/* ---------------- Demo items ---------------- */
const items = [
  { id:'m1', kind:'Mark',  title:'#1 ‚Äî 78 yards',  score:0, flags:{} },
  { id:'m2', kind:'Mark',  title:'#2 ‚Äî 49 yards',  score:0, flags:{} },
  { id:'m3', kind:'Mark',  title:'#3 ‚Äî 143 yards', score:0, flags:{} },
  { id:'b1', kind:'Blind', title:'#1 ‚Äî 120 yards', score:0, flags:{} },
  { id:'b2', kind:'Blind', title:'#2 ‚Äî 95 yards',  score:0, flags:{} },
];

/* ---------------- UI ---------------- */
const itemsEl = document.getElementById('items');
const statusEl = document.getElementById('status');

function chip(key,on){
  const el=document.createElement('span');
  el.className='chip'+(on?' on':'');
  el.dataset.key=key;
  el.textContent=FLAG_MAP[key].label;
  return el;
}
function renderRow(it){
  const row=document.createElement('div'); row.className='row'; row.id='row-'+it.id;

  const left=document.createElement('div');
  left.innerHTML=`<div class="kind">${it.kind}</div><div class="title">${it.title}</div>`;

  const mid=document.createElement('div');
  const chips=document.createElement('div'); chips.className='chips';
  FLAGS.forEach(f=> chips.appendChild(chip(f.key, !!it.flags[f.key])));
  mid.appendChild(chips);
  
 const right=document.createElement('div'); right.className='controls';
const flagBtn = document.createElement('button');
flagBtn.type='button';
flagBtn.className='flagBtn';
flagBtn.title='Hold to view flags ‚Ä¢ Swipe down to clear';
flagBtn.textContent='üö©'; // keep emoji; easy and readable
setupFlagPeek(flagBtn, it.id);

 
  const mic=document.createElement('button'); mic.type='button'; mic.className='mic';
  mic.innerHTML='<span class="dot"></span> üé§ Listen';
  mic.addEventListener('click',()=>startListeningFor(it.id));
  
  const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='10'; slider.step='0.5'; slider.value=it.score;
  slider.addEventListener('input',()=>{ it.score=+slider.value; score.textContent=it.score.toFixed(1); });
  const score=document.createElement('div'); score.className='score'; score.textContent=it.score.toFixed(1);
 right.append(flagBtn, mic, slider, score);

  row.append(left,mid,right);
  itemsEl.appendChild(row);
}
function renderAll(){ itemsEl.innerHTML=''; items.forEach(renderRow); }
renderAll();


// --- Peek overlay state/refs ---
const peekOverlay = document.getElementById('peekOverlay');
const peekListEl  = document.getElementById('peekList');
const pullZone    = document.getElementById('pullZone');
const pullBar     = document.getElementById('pullBar');
const pullLabel   = document.getElementById('pullLabel');

// Suppress long-press context menu and text selection on the flag + overlay
['contextmenu', 'selectstart'].forEach(evt => {
  document.addEventListener(evt, (e) => {
    if (e.target.closest('.flagBtn') || e.target.closest('#peekOverlay')) {
      e.preventDefault();
    }
  }, { passive:false });
});


let peekHold = { itemId:null, startY:0, threshold:90 };

function openPeek(itemId){
  peekHold.itemId = itemId;
  fillPeek(itemId);
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
  pullLabel.textContent = 'Swipe down to clear';
  peekOverlay.classList.add('open');
  peekOverlay.setAttribute('aria-hidden','false');
}
function closePeek(){
  peekOverlay.classList.remove('open');
  peekOverlay.setAttribute('aria-hidden','true');
  peekHold.itemId = null;
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
}

function fillPeek(itemId){
  const it = items.find(x=>x.id===itemId);
  const labels = FLAGS.filter(f => !!(it?.flags?.[f.key])).map(f=>f.label);
  peekListEl.innerHTML = labels.length
    ? labels.map(l=>`<div class="peek-flag">${l}</div>`).join('')
    : `<div class="hint">No flags set</div>`;
}

function updatePull(dy){
  const h = Math.max(0, Math.min(140, dy));
  pullBar.style.height = h + 'px';
  const ready = dy >= peekHold.threshold;
  pullZone.classList.toggle('ready', ready);
  pullLabel.textContent = ready ? 'Release to clear' : 'Swipe down to clear';
}

function clearAllFlags(itemId){
  const it = items.find(x=>x.id===itemId);
  if(!it) return;
  it.flags = {};
  syncRow(it);
  fillPeek(itemId);
  pullZone.classList.add('cleared');
  pullLabel.textContent = 'Cleared';
}

// Attach pointer interactions to a given red circle button
function setupFlagPeek(btn, itemId){
  let pid = null, holding = false;

  // prevent native long-press callout / selection on this control
  btn.addEventListener('contextmenu', e => e.preventDefault(), { passive:false });
  btn.addEventListener('selectstart', e => e.preventDefault(), { passive:false });
  btn.addEventListener('touchstart',  e => e.preventDefault(), { passive:false });

  btn.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    holding = true;
    pid = e.pointerId;
    btn.setPointerCapture?.(pid);
    peekHold.startY = e.clientY ?? (e.touches?.[0]?.clientY || 0);
    openPeek(itemId);
  });

  btn.addEventListener('pointermove', (e)=>{
    if(!holding || e.pointerId !== pid) return;
    const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
    updatePull(y - peekHold.startY);
  });

  const end = (e)=>{
    if(!holding || e.pointerId !== pid) return;
    const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
    const dy = y - peekHold.startY;
    if (dy >= peekHold.threshold) clearAllFlags(itemId);
    holding = false; pid = null;
    closePeek();
  };
  btn.addEventListener('pointerup', end);
  btn.addEventListener('pointercancel', end);
}


/* ---------------- Speech engine ---------------- */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let rec=null, activeId=null, activeFix=null; // activeFix = { itemId, phrase, suggestKey }
if (SR){
  rec=new SR(); rec.lang='en-US'; rec.interimResults=false; rec.continuous=false;
  rec.onstart=()=>setStatus('listening‚Ä¶');
  rec.onerror=e=>{ setStatus('error: '+(e.error||'unknown')); endListen(); };
  rec.onend=()=>{ setStatus('idle'); endListen(); };
  rec.onresult = (e) => {
    // Build a ‚Äúbest guess‚Äù for apply, but also capture the last result‚Äôs alternatives.
    const tx = [...e.results].map(r => r[0].transcript).join(' ').trim();

    // Log alternatives (browser-dependent confidence support)
    const last = e.results[e.results.length - 1];
    const alts = last ? Array.from(last).map(a => ({
      transcript: (a.transcript || '').trim(),
      confidence: (typeof a.confidence === 'number') ? +a.confidence.toFixed(3) : null
    })) : [];

    const best = alts[0]?.transcript || tx;

    console.groupCollapsed(
      `%cSpeech(final) ‚Üí %c${best}`,
      'color:#888', 'color:#111;font-weight:700'
    );
    console.log('activeId:', activeId, 'activeFix:', activeFix);
    if (alts.length) console.table(alts);
    console.groupEnd();

    if (activeFix){
      // targeted retry: apply to its row, then remove if matched suggestion or any flag detected
      const before = snapshotFlags(items.find(x=>x.id===activeFix.itemId));
      applyTranscript(activeFix.itemId, best);
      const after = snapshotFlags(items.find(x=>x.id===activeFix.itemId));
      const changed = diffFlags(before, after);
      const matchedSuggestion = changed.added.includes(activeFix.suggestKey) || changed.toggled.includes(activeFix.suggestKey);
      if (matchedSuggestion || (changed.added.length + changed.toggled.length) > 0) {
        removeMissed(activeFix.itemId, activeFix.phrase);
        renderMissedOverlay();
      }
      activeFix = null;
    } else if (activeId) {
      applyTranscript(activeId, best);
    }
  };

}else{
  setStatus('Speech API not supported in this browser.');
}
function setStatus(s){ statusEl.textContent='Status: '+s; }
function startListeningFor(id){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeFix=null;
  activeId=id;
  document.querySelectorAll('.row').forEach(r=>r.classList.toggle('listening', r.id==='row-'+id));
  rec.start();
}
function startFixListening(itemId, phrase, suggestKey){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeId=null;
  activeFix={ itemId, phrase, suggestKey };
  document.querySelectorAll('.row').forEach(r=>r.classList.remove('listening'));
  document.getElementById('row-'+itemId)?.classList.add('listening');
  rec.start();
}
function endListen(){
  activeId=null;
  document.querySelectorAll('.row').forEach(r=>r.classList.remove('listening'));
}

/* ---------------- NLP core ---------------- */
function normalize(s){
  return String(s||'')
    .toLowerCase()
    .replace(/[‚Äô‚Äò']/g,"'")
    .replace(/[^a-z0-9.\s-]/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}
const NUM_WORDS = {
  zero:0, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9, ten:10,
  eleven:11, twelve:12, thirteen:13, fourteen:14, fifteen:15, sixteen:16, seventeen:17, eighteen:18, nineteen:19,
  twenty:20, half:0.5
};
function wordsToNumber(s){
  s=normalize(s);
  if(/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);
  const tok=s.split(/\s+/);
  const i=tok.indexOf('point');
  if(i>-1){
    const A=tok.slice(0,i).join(' ');
    const B=tok.slice(i+1).join(' ');
    const ia=NUM_WORDS[A]; const ib=NUM_WORDS[B];
    if(Number.isFinite(ia) && Number.isFinite(ib)) return +(ia + '.' + Math.round(ib*10));
  }
  if(s in NUM_WORDS) return NUM_WORDS[s];
  return NaN;
}

function quant05(n){ return Math.max(0, Math.min(10, Math.round(n*2)/2)); }

// treat digits or number-words as numeric (e.g., "nine", "seven point five")
function isNumberish(s){
  const t = normalize(s);
  if(!t) return false;
  if(/^\d+(\.\d+)?$/.test(t)) return true;
  return Number.isFinite(wordsToNumber(t));
}


function detectFlagsMulti(tx){
  const found=new Set();
  const hits=[]; // {key,start,end}
  for (const f of FLAGS){
    for (const rx of (FLAG_RX[f.key] || [])){
      rx.lastIndex = 0;
      let m;
      while ((m = rx.exec(tx)) !== null){
        found.add(f.key);
      }
    }
    // position by variants (first occurrence)
    let best=null;
    for (const v of f.variants){
      const ix = tx.indexOf(v);
      if (ix>=0 && (best==null || ix<best.start)){
        best = {start:ix, end:ix+v.length};
      }
    }
    if (best) hits.push({ key:f.key, start:best.start, end:best.end });
  }
  hits.sort((a,b)=>a.start-b.start);
  return { keys:[...found], hits };
}

/* Parse utterance ‚Üí intents + missed phrases (between hits) */
function parseUtterance(raw){
  const tx = normalize(raw);
  const intents={ add:new Set(), remove:new Set(), toggle:new Set(), clearAll:false, score:null, adjust:0 };
  if(/\bclear\s+flags?\b/.test(tx)) intents.clearAll=true;

  // score explicit
  let m=tx.match(/\b(?:rating|score|set|make)\b(?:\s*(?:it|to|at))?\s+([a-z0-9.\s-]+)(?!.*\b(?:by)\b)/);
  if(m){ const n=wordsToNumber(m[1].trim()); if(Number.isFinite(n)) intents.score=quant05(n); }
  else {
    // pure-number utterance ‚Üí score
    if(/^\d+(\.\d+)?$/.test(tx) || Number.isFinite(wordsToNumber(tx))){
      const n=wordsToNumber(tx); if(Number.isFinite(n)) intents.score=quant05(n);
    }
  }

  // adjustments
  const inc=tx.match(/\b(increase|raise|up|\+|plus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  const dec=tx.match(/\b(decrease|lower|down|-|minus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  if(inc && !dec){ const amt = inc[2] ? (Number.isFinite(wordsToNumber(inc[2])) ? wordsToNumber(inc[2]) : parseFloat(inc[2])) : 0.5; intents.adjust += Number.isFinite(amt) ? amt : 0.5; }
  if(dec && !inc){ const amt = dec[2] ? (Number.isFinite(wordsToNumber(dec[2])) ? wordsToNumber(dec[2]) : parseFloat(dec[2])) : 0.5; intents.adjust -= Number.isFinite(amt) ? amt : 0.5; }

  // flags + hit spans
  const { keys, hits } = detectFlagsMulti(tx);
  const isRemove=/\b(remove|clear|unset|delete)\b/.test(tx);
  const isAdd=/\b(add|flag|set)\b/.test(tx);
  for (const k of keys){
    if(isRemove) intents.remove.add(k);
    else if(isAdd) intents.add.add(k);
    else intents.toggle.add(k);
  }

  // infer missed phrases (now robust for head/tail too)
  let missed = [];
  if (hits.length >= 2) {
    missed = inferMissedSegments(tx, hits);
  } else {
    missed = inferMissedLoose(tx, hits);
  }

  // ---- DEBUG CONSOLE ----
  console.groupCollapsed('%cNLP', 'color:#0b74ff;font-weight:700');
  console.log('raw:', raw);
  console.log('normalized:', tx);
  console.log('flags(keys):', keys);
  console.log('hits:', hits);
  console.log('missed:', missed);
  console.log('score:', intents.score, 'adjust:', intents.adjust, 'clearAll:', intents.clearAll);
  console.log('add:', Array.from(intents.add));
  console.log('remove:', Array.from(intents.remove));
  console.log('toggle:', Array.from(intents.toggle));
  console.groupEnd();
  // -----------------------

  return { intents, missed, hits, keys };
}


/* Heuristic: segments between detected flags that still have meaningful tokens */
const STOPWORDS = /\b(?:and|then|uh|um|a|an|the|please|flag|set|add|remove|clear|by|to|at|on|in|into|onto|with|for|from|about|around|like|as|score|rating|make|plus|minus|up|down|of|this|that|there|here|it|him|her|them|they|their|his|hers|just)\b/gi;

function cleanSegment(seg){
  return seg.replace(/[^a-z0-9.\s-]/g,' ').replace(/\s+/g,' ').replace(STOPWORDS,' ').replace(/\s+/g,' ').trim();
}
function inferMissedSegments(tx, hits){
  const out = [];
  if (!hits.length) return out;

  const sorted = hits.slice().sort((a,b)=>a.start - b.start);

  // HEAD (before first hit)
  {
    const first = sorted[0];
    const head = cleanSegment(tx.slice(0, first.start));
    if (head && !isNumberish(head)) {
      const suggestion = bestSuggestion(head);
      out.push({
        raw: head,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: null,
        rightKey: first.key
      });
    }
  }

  // BETWEEN hits
  for (let i = 0; i < sorted.length - 1; i++){
    const a = sorted[i], b = sorted[i+1];
    if (b.start <= a.end) continue;
    const mid = cleanSegment(tx.slice(a.end, b.start));
    if (mid && !isNumberish(mid)) {
      const suggestion = bestSuggestion(mid);
      out.push({
        raw: mid,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: a.key,
        rightKey: b.key
      });
    }
  }

  // TAIL (after last hit)
  {
    const last = sorted[sorted.length - 1];
    const tail = cleanSegment(tx.slice(last.end));
    if (tail && !isNumberish(tail)) {
      const suggestion = bestSuggestion(tail);
      out.push({
        raw: tail,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: last.key,
        rightKey: null
      });
    }
  }

  return dedupeMissed(out);
}

function dedupeMissed(arr){
  const seen=new Set(); const out=[];
  for (const x of arr){
    const k=x.raw.toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k); out.push(x);
  }
  return out;
}

// treat the whole utterance (0 hits) or edge segments (1 hit) as candidates
function inferMissedLoose(tx, hits){
  const out = [];
  const addCand = (raw, leftKey=null, rightKey=null) => {
    const cleaned = cleanSegment(raw);
    if (!cleaned) return;
    // ignore numbers-only like "7" or "7.5"
    if (isNumberish(cleaned)) return;

    const suggestion = bestSuggestion(cleaned);
    out.push({
      raw: cleaned,
      suggestKey: suggestion?.key || null,
      suggestLabel: suggestion?.label || null,
      leftKey, rightKey
    });
  };

  if (hits.length === 0) {
    // no flags detected -> whole utterance is a candidate
    addCand(tx);
    return dedupeMissed(out);
  }

  if (hits.length === 1) {
    const h = hits[0];
    const pre  = tx.slice(0, h.start);
    const post = tx.slice(h.end);
    addCand(pre, null, h.key);
    addCand(post, h.key, null);
    return dedupeMissed(out);
  }

  return out; // fallback ‚Äì shouldn't happen here
}


/* Fuzzy suggestion (Levenshtein) to nearest canonical phrase */
function lev(a,b){
  const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}
function bestSuggestion(seg){
  let best=null; const s=seg.toLowerCase();
  for (const f of FLAGS){
    for (const v of f.variants){
      const d = lev(s, v);
      const sim = 1 - d / Math.max(s.length, v.length);
      if (!best || sim > best.sim) best = { key:f.key, label:f.label, sim };
    }
  }
  return (best && best.sim >= 0.55) ? best : null; // threshold
}

/* ---------------- Apply to row, then surface missed overlay + logging ---------------- */
function quantClamp(n){ return Math.max(0, Math.min(10, n)); }

function applyTranscript(itemId, raw){
  const it=items.find(x=>x.id===itemId); if(!it) return;
  const { intents, missed } = parseUtterance(raw);
  if (missed.length && (!intents.add.size && !intents.remove.size && !intents.toggle.size)) {
    setStatus('No flags matched; queued ' + missed.length + ' missed phrase(s).');
  }

  if(intents.clearAll) it.flags = {};

  intents.add.forEach(k => it.flags[k]=true);
  intents.remove.forEach(k => it.flags[k]=false);
  intents.toggle.forEach(k => it.flags[k]=!it.flags[k]);

  if(Number.isFinite(intents.score)) it.score=intents.score;
  if(intents.adjust!==0) it.score=quant05(it.score + intents.adjust);
  it.score = quantClamp(it.score);

  syncRow(it);

  if (missed.length){
    // build per-row missed items and log phrases
    for (const m of missed){
      addMissed(itemId, it.title, m.raw, m.suggestKey, m.suggestLabel);
      logUnassigned(m.raw);
    }
    renderMissedOverlay();
  }
}
function syncRow(it){
  const row=document.getElementById('row-'+it.id);
  if(!row) return;
  row.querySelector('input[type=range]').value=it.score;
  row.querySelector('.score').textContent=it.score.toFixed(1);
  row.querySelectorAll('.chip').forEach(ch=>{
    const k=ch.dataset.key;
    ch.classList.toggle('on', !!it.flags[k]);
  });
}
function snapshotFlags(it){
  const on = Object.entries(it.flags||{}).filter(([k,v])=>!!v).map(([k])=>k);
  return { on: new Set(on) };
}
function diffFlags(before, after){
  const b=[...before.on], a=[...after.on];
  const added = a.filter(k=>!before.on.has(k));
  const removed = b.filter(k=>!new Set(a).has(k));
  // treat simple toggles as added for our purposes:
  return { added, removed, toggled: added };
}

/* ---------------- Missed overlay state ---------------- */
const missedOverlay = document.getElementById('missedOverlay');
const missedListEl = document.getElementById('missedList');
document.getElementById('missedClose').addEventListener('click', ()=> closeMissed());
document.getElementById('missedClear').addEventListener('click', ()=> { missedItems.length=0; renderMissedOverlay(); });

let missedItems = []; // { itemId, rowTitle, phrase, suggestKey?, suggestLabel? }
function addMissed(itemId, rowTitle, phrase, suggestKey, suggestLabel){
  const key = `${itemId}||${phrase.toLowerCase()}`;
  if (missedItems.some(x => `${x.itemId}||${x.phrase.toLowerCase()}`===key)) return;
  missedItems.push({ itemId, rowTitle, phrase, suggestKey, suggestLabel });
}
function removeMissed(itemId, phrase){
  missedItems = missedItems.filter(x => !(x.itemId===itemId && x.phrase.toLowerCase()===phrase.toLowerCase()));
}
function openMissed(){ missedOverlay.classList.add('open'); missedOverlay.setAttribute('aria-hidden','false'); }
function closeMissed(){ missedOverlay.classList.remove('open'); missedOverlay.setAttribute('aria-hidden','true'); }

function renderMissedOverlay(){
  missedListEl.innerHTML = '';
  if (!missedItems.length){ closeMissed(); return; }

  for (const m of missedItems){
    const row = document.createElement('div'); row.className='missed-item';
    const meta = document.createElement('div'); meta.className='missed-meta';
    meta.innerHTML = `
      <div class="missed-phrase">${m.phrase}</div>
      <div class="missed-row">Row: ${m.rowTitle}</div>
      ${m.suggestLabel ? `<div class="hint">Did you mean <b>${m.suggestLabel}</b>?</div>` : ''}
    `;
    const actions = document.createElement('div'); actions.className='missed-actions';
    const mic = document.createElement('button'); mic.className='btn small'; mic.innerHTML='üé§ Say again';
    mic.addEventListener('click', ()=> startFixListening(m.itemId, m.phrase, m.suggestKey||null));
    actions.appendChild(mic);

    if (m.suggestKey){
      const quick = document.createElement('button'); quick.className='btn small primary';
      quick.textContent = `‚úì Apply ${m.suggestLabel}`;
      quick.addEventListener('click', ()=>{
        const it = items.find(x=>x.id===m.itemId); if (!it) return;
        it.flags[m.suggestKey] = true;
        syncRow(it);
        removeMissed(m.itemId, m.phrase);
        renderMissedOverlay();
      });
      actions.appendChild(quick);
    }

    const dismiss = document.createElement('button'); dismiss.className='btn small';
    dismiss.textContent='Dismiss';
    dismiss.addEventListener('click', ()=>{ removeMissed(m.itemId, m.phrase); renderMissedOverlay(); });
    actions.appendChild(dismiss);

    row.append(meta, actions);
    missedListEl.appendChild(row);
  }
  openMissed();
}

/* ---------------- Master unassigned log (localStorage) ---------------- */
const LOG_KEY = 'speech_unassigned_log_v1';
function readLog(){ try{ return JSON.parse(localStorage.getItem(LOG_KEY)||'[]'); }catch{return[];} }
function writeLog(arr){ localStorage.setItem(LOG_KEY, JSON.stringify(arr)); }
function logUnassigned(phrase){
  const p = phrase.toLowerCase();
  const arr = readLog();
  const idx = arr.findIndex(x=>x.phrase===p);
  if (idx>=0){ arr[idx].count += 1; arr[idx].last = Date.now(); }
  else { arr.push({ phrase:p, count:1, last:Date.now() }); }
  writeLog(arr);
}
function clearLog(){ writeLog([]); }
function renderLog(){
  const listEl = document.getElementById('logList');
  listEl.innerHTML='';
  const arr = readLog().sort((a,b)=>b.count-a.count);
  if (!arr.length){
    const empty = document.createElement('div'); empty.className='hint'; empty.textContent='No data yet.';
    listEl.appendChild(empty); return;
  }
  arr.forEach(x=>{
    const row = document.createElement('div'); row.className='log-item';
    const left = document.createElement('div'); left.innerHTML = `<strong>${x.phrase}</strong>`;
    const right = document.createElement('div'); right.innerHTML = `<span class="count">${x.count}</span>`;
    row.append(left, right); listEl.appendChild(row);
  });
}
const logOverlay = document.getElementById('logOverlay');
document.getElementById('viewLogBtn').addEventListener('click', ()=>{ renderLog(); logOverlay.classList.add('open'); });
document.getElementById('logClose').addEventListener('click', ()=> logOverlay.classList.remove('open'));
document.getElementById('logClear').addEventListener('click', ()=>{ clearLog(); renderLog(); });

/* ---------------- Clear all ---------------- */
document.getElementById('clearBtn').addEventListener('click',()=>{
  items.forEach(it=>{ it.flags={}; it.score=0; syncRow(it); });
  missedItems.length=0; renderMissedOverlay();
  setStatus('cleared');
});
</script>
</body>
</html>
