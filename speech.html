<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voice Flag Tester</title>
<style>
  :root{
    --accent:#0b74ff; --bg:#f6f7fb; --card:#fff; --muted:#667085; --border:#e4e7ec;
    --danger:#ef4444; --ok:#16a34a;
  }
  * { box-sizing: border-box; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:#101828;}
  header{padding:20px 24px 8px;}
  h1{margin:0 0 6px;font-size:28px;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:14px}
  .wrap{padding:0 24px 24px;max-width:1100px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 1px 2px rgba(16,24,40,.04)}
  .items{display:flex;flex-direction:column;gap:14px}
  .row{display:grid;grid-template-columns:minmax(160px,260px) 1fr auto;gap:14px;align-items:center;padding:12px;border:1px solid var(--border);border-radius:14px;background:#fafafa}
  .kind{font-size:12px;font-weight:800;color:#344054}
  .title{font-size:16px;font-weight:800}
  /* FLAGS AREA ‚Üí responsive columns */
  .chips{
    display:grid; gap:8px;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    align-items:start;
  }
  .chip{border:1px solid #d0d5dd;background:#fff;border-radius:999px;padding:6px 10px;font-size:13px;user-select:none;display:block}
  .chip.on{background:#eef4ff;border-color:#c7d7fe}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  
  .row.listening .mic{border-color:#ffb4b4;box-shadow:0 0 0 4px rgba(255,59,48,.12)}
  .row.listening .mic .dot{background:#ff3b30;animation:pulse 1s infinite alternate}
  @keyframes pulse{from{transform:scale(.9)}to{transform:scale(1.2)}}
  input[type=range]{width:220px}
  .score{font-weight:800;min-width:44px;text-align:right;font-variant-numeric:tabular-nums}
  .bar{display:flex;gap:10px;align-items:center;padding:0 24px 12px;flex-wrap:wrap}
  .status{color:var(--muted);font-weight:700}
  .btn{appearance:none;border:1px solid var(--border);background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  .btn.ghost{background:#fff}
  .btn.small{padding:6px 8px;border-radius:8px;font-size:12px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:12px}
  .pill.ok{border-color:#c7f1d9;background:#ecfdf5;color:#065f46}
  .pill.bad{border-color:#ffd5d5;background:#fff1f1;color:#7f1d1d}
/* Hide the old grid; voice still toggles in the background */
.chips{ display:none; }

/* Red circle ‚Äúflag‚Äù button ‚Äî bigger default + explicit BIG variant */
.flagBtn{
  width:64px; height:64px; border-radius:999px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#FFFFFF; border:none; cursor:pointer;
  box-shadow:0 14px 28px rgba(239,68,68,.35);
  touch-action:none; /* enables swipe tracking on mobile */
  font-size:26px; font-weight:900;
}
.flagBtn.big{
  width:76px; height:76px;
  font-size:32px;
  box-shadow:0 18px 38px rgba(239,68,68,.35);
}
.flagBtn:active{ transform:translateY(1px); }


/* Peek overlay: big, easy-to-read list */

.peek-head{font-weight:800; font-size:14px; color:#475467; margin-bottom:8px}
.peek-list{display:flex; flex-direction:column; gap:12px; margin:10px 0 6px}
.peek-flag{font-size:22px; font-weight:800; padding:8px 12px; border-radius:12px;
  background:#f8fafc; border:1px solid #e5e7eb}

/* Pull-to-clear zone at bottom of the card */
.pull-zone{position:relative; height:64px; border-radius:12px; overflow:hidden;
  background:#fafafa; border:1px dashed #e5e7eb; margin-top:8px}
.pull-bar{position:absolute; left:0; top:0; width:100%; height:0;
  background:rgba(239,68,68,.25); transition:height .1s linear}
.pull-zone.ready .pull-bar{ background:rgba(239,68,68,.45); }
.pull-zone.cleared{ background:#fee2e2; border-color:#fecaca; }
.pull-label{position:relative; z-index:1; line-height:64px; font-weight:800; color:#7f1d1d}


  /* Overlay (missed phrases) */
  
  .overlay.open{display:flex;}
  
  .sheet-head{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--border)}
  .sheet-body{padding:12px 16px;display:flex;flex-direction:column;gap:10px}
  .missed-item{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:12px}
  .missed-meta{display:flex;flex-direction:column;gap:4px}
  .missed-phrase{font-weight:800}
  .missed-row{color:#475467;font-size:12px}
  .missed-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sheet-foot{padding:12px 16px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end}
  .hint{color:#475467;font-size:12px}

  /* Overlay (master log) */
  .log-list{display:flex;flex-direction:column;gap:8px}
  .log-item{display:flex;justify-content:space-between;align-items:center;border:1px solid #ececec;background:#fafafa;padding:10px;border-radius:10px}
  .count{font-variant-numeric:tabular-nums;font-weight:800}
  
  /* Kill native long-press callout + text selection where we hold */
.flagBtn,
#peekOverlay,
#peekOverlay *,
.mic,
.row {
  -webkit-touch-callout: none; /* iOS copy/paste bubble */
  -webkit-user-select: none;
  user-select: none;
}

.flagBtn,
.peek { touch-action: none; } /* prevent native gestures during hold */

/* --- Large, swipeable stage showing 1 Mark + 1 Blind --- */
.items { display:none; }            /* hide old list view on this test page */
.stage {
  display: grid;
  gap: 14px;
}
.pane {
  background:#fff;
  border:1px solid var(--border);
  border-radius:16px;
  box-shadow:0 1px 2px rgba(16,24,40,.04);
  padding:16px;
  min-height: 36vh;                 /* nice big touch target area */
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  touch-action: pan-y;              /* allow vertical scrolling; we handle horizontal */
}
/* Bigger Mark/Blind label */
.pane-head .kind { font-size:22px; font-weight:900; color:#475467; }
/* tiny spacing tweak so the bigger label breathes */
.pane-head .title{ font-size:24px; font-weight:900; margin-top:4px; }


.pane-controls{ display:flex; align-items:center; gap:12px; flex-wrap:wrap }

.score.big { font-size:24px; font-weight:900; min-width:56px; text-align:right; }

.navBtn{
  appearance:none; border:1px solid var(--border); background:#fff;
  width:46px; height:46px; border-radius:12px; cursor:pointer; font-size:20px; font-weight:800;
}
.navBtn:active{ transform:translateY(1px); }

.pager{ margin-left:auto; display:flex; gap:6px; align-items:center }
.dot{ width:8px; height:8px; border-radius:50%; background:#d0d5dd }
.dot.on{ background:#0b74ff }

/* Stretch the range to breathe on mobile */
.pane input[type=range]{
  flex:1 1 240px; min-width:180px;
}
/* --- Swipe slide animation --- */
.stage { position: relative; }                /* anchor absolute panes */
.pane-slot{
  position: relative;                         /* local stacking for each slot */
  min-height: 36vh;                           /* match pane's min-height */
}
.pane{
  position: absolute; inset: 0;               /* let old/new overlap to animate */
  transition: transform .28s ease, opacity .28s ease;
  transform: translateX(0); opacity: 1;
}
.pane.enter-from-right { transform: translateX(100%); opacity: 0; }
.pane.enter-from-left  { transform: translateX(-100%); opacity: 0; }
.pane.exit-to-left     { transform: translateX(-100%); opacity: 0; }
.pane.exit-to-right    { transform: translateX(100%);  opacity: 0; }


.mic{
  display:inline-flex;align-items:center;gap:10px;
  padding:12px 14px;border-radius:999px;background:#fff;border:1px solid #d0d5dd;
  cursor:pointer;font-weight:800;font-size:16px;min-height:44px
}
.mic .dot{width:12px;height:12px;border-radius:50%;background:#94a3b8}
.mic.big{ font-size:22px; padding:16px 18px; min-height:56px }
.mic.big .dot{ width:16px; height:16px }

#peekOverlay { touch-action: none; }

/* Overlay container */
.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center;
  z-index:9999;

  /* keep content inside the viewport even with outer padding */
  padding:16px;
  /* notch-safe padding on iOS */
  padding-left: max(16px, env(safe-area-inset-left));
  padding-right:max(16px, env(safe-area-inset-right));
  padding-top:  max(16px, env(safe-area-inset-top));
  padding-bottom:max(16px, env(safe-area-inset-bottom));
}

/* Flags peek card */
.peek{
  /* width that *always* fits inside overlay padding */
  width: min(420px, calc(100dvw - 32px));
  /* prevent vertical overflow off-screen */
  max-height: calc(100dvh - 32px);
  overflow:auto;

  background:#fff; border:1px solid var(--border);
  border-radius:16px; padding:16px; text-align:center;
  box-shadow:0 20px 50px rgba(0,0,0,.25);
}

/* Missed/log sheet */
.sheet{
  width: min(720px, calc(100dvw - 32px));
  max-height: calc(100dvh - 32px);
  overflow:auto;

  background:#fff; border:1px solid var(--border);
  border-radius:16px; box-shadow:0 20px 50px rgba(0,0,0,.25);
}

/* Keep peek draggable; keep sheets scrollable */
#peekOverlay { touch-action: none; }
#missedOverlay, #logOverlay { touch-action: pan-y; }


html.overlay-open, body.overlay-open { overflow: hidden; }

/* Keep slide animations from ever expanding layout width */
.stage,
.pane-slot { overflow: hidden; }

/* Belt-and-suspenders: never allow horizontal page growth */
html, body { max-width: 100%; overflow-x: hidden; overscroll-behavior-x: none; }

/* Controls can wrap, but children must be allowed to shrink */
.pane-controls > * { min-width: 0; }

/* Pager shouldn't force the row wider than the screen */
.pager { min-width: 0; flex: 0 1 auto; overflow: hidden; }

/* ‚Äî‚Äî‚Äî Home screen refresh (mobile-first, high-contrast) ‚Äî‚Äî‚Äî */

/* Tweak base card padding and shadow for depth */
.wrap { padding: 12px 16px 24px; }
.card { border-radius: 18px; box-shadow: 0 10px 30px rgba(16,24,40,.08); }

/* Dog card: subtle gradient with large name */
#dogCard {
  background: linear-gradient(180deg, #ffffff 0%, #f6f8ff 100%);
  border: 1px solid #e7ecff;
  box-shadow: 0 8px 26px rgba(11,116,255,.10);
}
#dogCard .pane-head .kind { font-size: 18px; letter-spacing:.3px; color:#0b74ff; }
#dogCard .pane-head .title { font-size: 28px; font-weight:900; margin-top:6px; }

/* Stage panes ‚Äî cleaner surface */
.pane {
  border: 1px solid #e7ecff;
  border-radius: 18px;
  background: #ffffff;
  box-shadow: 0 10px 30px rgba(16,24,40,.06);
  padding: 16px 14px 18px;
}

/* Pane header: bigger label + title */
.pane-head .kind   { font-size: 18px; font-weight:900; color:#0b74ff; }
.pane-head .title  { font-size: 22px; font-weight:900; color:#0f172a; margin-top:4px; }

/* Control row: space things nicely on small screens */
.pane-controls { gap: 12px; flex-wrap: wrap; align-items: center; }

/* Giant mic button (pill) */
.mic.big{
  border: 0;
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%);
  box-shadow: 0 10px 24px rgba(11,116,255,.20);
  padding: 14px 18px;
  border-radius: 999px;
  font-size: 20px;
}
.mic.big .dot{ width:14px; height:14px; background:#0b74ff; }

/* Giant red flag button */
.flagBtn.big{
  width: 84px; height: 84px; font-size: 34px;
  border: 0;
  box-shadow: 0 20px 44px rgba(239,68,68,.40);
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 65%, #ffecec 100%);
}

/* Score cluster (new): big ¬± buttons + badge */
.scoreWrap{
  display:flex; align-items:center; gap:10px;
  margin-left:auto; /* push toward the right by default */
}
.scoreBtn{
  width:58px; height:58px; border-radius:14px;
  border:1px solid #dbe3ff; background:#fff; font-size:28px; font-weight:900;
  box-shadow: 0 10px 22px rgba(16,24,40,.10);
}
.scoreBadge{
  min-width:94px; padding:6px 10px; text-align:center;
  border-radius:14px; border:1px solid #dbe3ff;
  background: #f5f8ff; font-size:36px; font-weight:900;
  font-variant-numeric: tabular-nums;
}

/* Keep the old slider + score around but invisible so existing code still works */
.pane input[type=range].visually-hidden { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
.pane .score { display:none; }

/* Pager dots: cleaner + slightly larger for visibility */
.pager { margin-left:0; gap:8px; }
.pager .dot{ width:10px; height:10px; background:#e2e8f0; }
.pager .dot.on{ background:#0b74ff; }

/* Anti-width-creep: never let swipes or long controls expand the page */
.stage, .pane-slot { overflow:hidden; }
html, body { max-width:100%; overflow-x:hidden; overscroll-behavior-x:none; }
.pane-controls > * { min-width:0; }
.pager { min-width:0; flex:0 1 auto; overflow:hidden; }





/* ‚Äî‚Äî‚Äî Rhombus buttons with rounded corners ‚Äî‚Äî‚Äî */
/* Works for the big red flag and big mic. No markup changes needed. */

.flagBtn.big,
.mic.big{
  position: relative;
  isolation: isolate;       /* keeps the shadow/overlay tidy */
  background: transparent;  /* the shape comes from ::before */
  border: 0;
}

/* Shared ‚Äúdiamond‚Äù skin */
.flagBtn.big::before,
.mic.big::before{
  content: "";
  position: absolute;
  left: 50%; top: 50%;
  width: 100%; height: 100%;
  transform: translate(-50%,-50%) rotate(45deg) scale(var(--rhombus-scale, .86));
  border-radius: 18px;        /* rounded rhombus corners */
  pointer-events: none;       /* clicks go to the button */
}

/* Size & typography (accessible) */
.flagBtn.big{
  width: 92px; height: 92px;             /* large touch target */
  font-size: 34px; font-weight: 900;
  --rhombus-scale: .86;
}
.mic.big{
  /* responsive long rhombus */
  width: min(88vw, 280px);
  height: 92px;
  padding: 0 10px;                        /* space for label */
  font-size: 22px; font-weight: 900; line-height: 1;
  display: inline-flex; align-items: center; justify-content: center;
  gap: 10px;
  color: #0b74ff;
  --rhombus-scale: .90;
}

/* Inner dot stays normal (not rotated) */
.mic.big .dot{ width:16px; height:16px; background:#0b74ff; }

/* Colorways + depth */
.flagBtn.big::before{
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%);
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset;
}
.mic.big::before{
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%);
  box-shadow: 0 18px 40px rgba(11,116,255,.25), 0 0 0 1px #e7ecff inset;
}

/* Press + focus states */
.flagBtn.big:active::before,
.mic.big:active::before{
  transform: translate(-50%,-50%) rotate(45deg) scale(calc(var(--rhombus-scale, .86) * .97));
}
.flagBtn.big:focus-visible::before,
.mic.big:focus-visible::before{
  box-shadow:
    0 0 0 4px rgba(11,116,255,.25),
    0 18px 40px rgba(11,116,255,.25),
    0 0 0 1px #e7ecff inset;
  outline: none;
}

/* Keep layout from ‚Äúgrowing‚Äù during transforms */
.flagBtn.big, .mic.big { overflow: visible; }

/* --- Fix diamond overflow on big buttons --- */

/* Keep the ::before square the size of the button's height */
.flagBtn.big { --btn-h: 92px; width: var(--btn-h); height: var(--btn-h); } /* stays square */
.mic.big     { --btn-h: 92px; height: var(--btn-h); }                      /* already 92px tall */

.mic.big::before{
  /* was width:100%; height:100%; ‚Äî that caused the diagonal blade */
  width: var(--btn-h);
  height: var(--btn-h);
}

/* Ensure the diamond sits behind the content, not above neighbors */
.flagBtn.big::before,
.mic.big::before{
  z-index: -1;              /* behind the emoji/text */
}

/* Safety: confine any remaining overflow to the button box */
.flagBtn.big, .mic.big {
  overflow: clip;
}
@supports not (overflow: clip){
  .flagBtn.big, .mic.big { overflow: hidden; } /* Safari fallback */
}


/* --- Clean up legacy shapes & set final button geometry --- */

/* 1) FLAG: keep the diamond, remove the old circular button behind it */
.flagBtn.big{
  background: transparent !important;   /* no white circle */
  border: 0 !important;
  border-radius: 0 !important;          /* removes circular silhouette */
  box-shadow: none !important;          /* shadow comes from ::before */
  width: 92px; height: 92px;            /* square hit area */
  position: relative; isolation: isolate;
  overflow: clip;
}
@supports not (overflow: clip){ .flagBtn.big{ overflow: hidden; } }

/* Ensure the diamond stays the only visual */
.flagBtn.big::before{
  content:"";
  position:absolute; inset:0;
  margin:auto;
  width: 92px; height: 92px;            /* square, then rotate */
  transform: rotate(45deg);
  border-radius: 18px;
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%);
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset;
  z-index:-1;
}

/* 2) MIC: straight rounded rectangle, no diamond */
.mic.big{
  /* override the old pill */
  border-radius: 18px !important;
  background: linear-gradient(180deg, #eef4ff 0%, #ffffff 100%) !important;
  border: 1px solid #dbe3ff !important;
  box-shadow: 0 10px 24px rgba(11,116,255,.18);
  color:#0b74ff; font-weight:900; font-size:20px;

  height: 92px;
  min-width: clamp(220px, 80vw, 340px); /* room for dot + ‚ÄúListen‚Äù */
  padding: 0 18px;
  display:inline-flex; align-items:center; justify-content:center; gap:12px;

  background-clip: padding-box;
}
.mic.big::before{ content:none !important; }   /* kill the rhombus layer */
.mic.big .dot{ width:16px; height:16px; background:#0b74ff; border-radius:50%; }

/* Press/focus states */
.mic.big:active{ transform: translateY(1px); }
.mic.big:focus-visible{
  outline: none;
  box-shadow:
    0 0 0 4px rgba(11,116,255,.25),
    0 10px 24px rgba(11,116,255,.18);
}


/* 3) Optional: if you truly want the mic to be a 1:1 square,
   add class="mic big square" in the HTML. */
.mic.big.square{
  width: 92px; min-width: 92px; padding:0; gap:0;
  justify-content:center;
  text-indent: -9999px;                 /* hide "Listen" text visually */
}
.mic.big.square::after{
  content: "üé§";
  text-indent: 0; font-size: 32px; line-height: 1;
}
.mic.big.square .dot{ display:none; }

/* --- FIX: keep the flag rhombus from being cut off --- */
.flagBtn.big{
  /* Make the rotated square fit entirely inside the 92√ó92 button */
  --rhombus-scale: .70;                  /* ~1/‚àö2 ‚âà .707; .70 gives a little breathing room */
  background: transparent !important;    /* no legacy circle */
  border: 0 !important;
  box-shadow: none !important;           /* depth comes from ::before */
  overflow: visible;                      /* safe: shape now fits; shadow can breathe */
}

/* Ensure we use the centered + scaled transform (override any earlier/later rule) */
.flagBtn.big::before{
  width: 100% !important;
  height: 100% !important;
  left: 50% !important;
  top: 50% !important;
  transform: translate(-50%, -50%) rotate(45deg) scale(var(--rhombus-scale)) !important;
  border-radius: 18px !important;
  background: radial-gradient(circle at 35% 30%, #fff 0%, #fff 60%, #ffe5e5 100%) !important;
  box-shadow: 0 22px 48px rgba(239,68,68,.45), 0 0 0 1px #ffd3d3 inset !important;
  z-index: -1;
}

/* Keep the mic as a plain rounded rectangle (no diamond layer) */
.mic.big::before{ content: none !important; }


/* Keep your diamond exactly as-is via ::before.
   Center the flag glyph visually via ::after. */
.flagBtn.big{
  display: inline-grid;              /* easy centering */
  place-items: center;
  font-size: 0;                      /* hide the raw emoji text node */
  --icon-x: 6px;                     /* tweak these if needed */
  --icon-y: -35px;
}

.flagBtn.big::after{
  content: "üö©";
  font-size: 36px;                   /* size of the glyph */
  line-height: 1;
  transform: translate(var(--icon-x), var(--icon-y));
  pointer-events: none;
  z-index: 0;                        /* above ::before (which is z:-1) */
}

  
</style>
</head>
<body>
  

  <div class="wrap">
    <div class="card">
	<div class="card" id="dogCard" style="margin-bottom:12px;">
  <div class="pane-head">
    <div class="kind">Dog</div>
    <div class="title" id="dogName">‚Äî</div>
  </div>
  <div class="pane-controls">
    <button class="mic big" id="dogMic" type="button" title="Say a dog‚Äôs name">
      <span class="dot"></span> üé§ Listen
    </button>
    <div class="hint" id="dogHint">Loading dog names‚Ä¶</div>
  </div>
</div>

      <div id="items" class="items"></div>
	  <div id="stage" class="stage" aria-live="polite"></div>

    </div>

    <div class="card" style="margin-top:12px">
      <strong>Say things like‚Ä¶</strong>
      <ul class="sub" style="margin:6px 0 0 18px">
        <li>‚Äúflag big hunt and overran, rating seven point five‚Äù</li>
        <li>‚Äúremove didn‚Äôt mark and poor initial, increase by point five‚Äù</li>
        <li>‚Äúclear flags, score 6‚Äù</li>
        <li>‚Äú7.5‚Äù (just a number sets the score)</li>
      </ul>
    </div>
  </div>

  <!-- Missed phrases overlay -->
  <div id="missedOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases</strong></div>
        <div class="hint">These didn‚Äôt map to flags. Tap üé§ to retry or apply a suggestion.</div>
      </div>
      <div id="missedList" class="sheet-body"></div>
      <div class="sheet-foot">
        <button class="btn" id="missedClose">Close</button>
        <button class="btn ghost" id="missedClear">Dismiss all</button>
      </div>
    </div>
  </div>
  

  <!-- Master log overlay -->
  <div id="logOverlay" class="overlay" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-head">
        <div><strong>Unassigned phrases ‚Äì log</strong></div>
        <div class="hint">Kept in localStorage to spot trends. Clear anytime.</div>
      </div>
      <div id="logList" class="sheet-body log-list"></div>
      <div class="sheet-foot">
        <button class="btn" id="logClose">Close</button>
        <button class="btn danger" style="border-color:#fca5a5;color:#7f1d1d" id="logClear">Clear log</button>
      </div>
    </div>
  </div>
  
<!-- Active-flags peek (hold the red circle, swipe down to clear) -->
<div id="peekOverlay" class="overlay" aria-hidden="true">
  <div class="peek">
    <div class="peek-head">Active flags for this item</div>
    <div id="peekList" class="peek-list"></div>

    <div id="pullZone" class="pull-zone">
      <div id="pullBar" class="pull-bar"></div>
      <div id="pullLabel" class="pull-label">Swipe down to clear</div>
    </div>
  </div>
</div>



  <div class="bar">
    <button id="clearBtn" class="btn">Clear all</button>
    <button id="viewLogBtn" class="btn ghost">Unassigned Log</button>
    <div id="status" class="status">Status: idle</div>
  </div>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>


  // reuse trailer.html config
  const firebaseConfig = {
    apiKey: "AIzaSyAqPT52Us-vWv4GNRYPgGCQ2I1SdsLsXyI",
    authDomain: "task-tracker-73b77.firebaseapp.com",
    projectId: "task-tracker-73b77",
    storageBucket: "task-tracker-73b77.firebasestorage.app",
    messagingSenderId: "795274673000",
    appId: "1:795274673000:web:0ea07130e45c72384134dd",
    measurementId: "G-VLW5KLY4FF"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  
  // ---------- Run context (trainer/day/setup) ----------
let currentTrainer = 'Scott';                   // default
let currentDateKey = null;
let currentSetupId = null;
let currentSetupOrder = 1;

// Build a reference to the score "run" doc for a dog
function runDocRef(dogName){
  if (!dogName || !currentSetupId || !currentTrainer || !currentDateKey) return null;
  return db.collection('setups').doc(currentTrainer)
           .collection('days').doc(currentDateKey)
           .collection('setups').doc(currentSetupId)
           .collection('scores').doc(dogName)
           .collection('runs').doc('current'); // one doc per day/setup/dog
}

// Tiny debounce helper + per-item debouncers
function debounce(fn, ms=350){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
const saveDebouncers = {};
function debouncedSaver(itemId){
  if (!saveDebouncers[itemId]){
    saveDebouncers[itemId] = debounce(async ()=>{
      const dogName = selectedDog;
      const ref = runDocRef(dogName);
      if (!ref) return;
      const it = items.find(x=>x.id===itemId);
      if (!it) return;

      // Persist score + flags for this one item
      const payload = { score: it.score || 0, flags: it.flags || {} };
      await ref.set({
        trainer: currentTrainer,
        dateKey: currentDateKey,
        setupId: currentSetupId,
        setupOrder: currentSetupOrder,
        // tip: if you need a numeric "handles" count later, add it alongside
        items: { [itemId]: payload },
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    }, 350);
  }
  return saveDebouncers[itemId];
}

// Load this dog's saved scores/flags into our in-memory `items` and re-render
async function loadDogRun(dogName){
  const ref = runDocRef(dogName);
  if (!ref) return;
  const snap = await ref.get();
  if (!snap.exists) return;

  const data = snap.data() || {};
  const saved = data.items || {};
  let changed = false;

  items.forEach(it => {
    const s = saved[it.id];
    if (s){
      if (typeof s.score === 'number') { it.score = quant05(s.score); changed = true; }
      if (s.flags && typeof s.flags === 'object') {
        it.flags = Object.assign({}, it.flags, s.flags);
        changed = true;
      }
    }
  });

  if (changed){ renderAll(); renderStage(); }
}




/* ---------------- Flag dictionary & variants (for positioning/fuzzy) ---------------- */
const FLAGS = [
  { key:'bigHunt',        label:'Big Hunt',         variants:['big hunt'] },
  { key:'marginalHunt',   label:'Marginal Hunt',    variants:['marginal hunt'] },

  // add split/inflected variants
  { key:'overran',        label:'Overran',          variants:['overran','over run','over-run','over ran','ran over'] },

  { key:'shortCheckDown', label:'Short Checkdown',  variants:[
      'short checkdown','short check down','short-check down','short check-down'
    ] },

  // allow articles + shorthand
  { key:'backSideOfGun',  label:'Backside of Gun',  variants:[
      'backside of gun','backside of the gun','back side of gun','back side of the gun',
      'back of gun','back of the gun'
    ] },

  { key:'handled',        label:'Handled',          variants:['handled'] },
  { key:'castRefusal',    label:'Cast Refusal',     variants:['cast refusal','cast refused','refused cast'] },

  // sit/sat + article
  { key:'sitOnWhistle',   label:'Sit on Whistle',   variants:[
      'sit on whistle','sit on the whistle','sat on whistle','sat on the whistle'
    ] },

  // didn‚Äôt vs did not
  { key:'didntMark',      label:"Didn't Mark",      variants:["didn't mark",'didnt mark','did not mark'] },

  { key:'poorInitial',    label:'Poor Initial',     variants:['poor initial'] },

  // head swing vs swung
  { key:'headswing',      label:'Headswing',        variants:['headswing','head swing','head swung'] },

  { key:'break',          label:'Broke',            variants:['broke','break'] },
  { key:'switched',       label:'Switched',         variants:['switched','switch','did a switch'] },
  { key:'noGo',           label:'No-Go',            variants:['no go','no-go'] },

  // pick-up hyphen + article
  { key:'pickedUpPoison', label:'Poison Pick Up',   variants:[
      'poison pick up','poison pick-up','picked up poison','picked up the poison'
    ] },
  { key:'noPickUp',       label:'No Pick Up',       variants:[
      'no pick up','no pick-up','no pickup'
    ] },

  { key:'stoodOut',       label:'Stood Out',        variants:['stood out','stood way out'] },
  { key:'popped',         label:'Popped',           variants:['popped','pop'] },
];
const FLAG_MAP = Object.fromEntries(FLAGS.map(f=>[f.key,f]));

/* Regex bundle for fast detection (multi-match) */
/* NOTE: these broaden matching but preserve existing behavior */
const FLAG_RX = {
  bigHunt:        [/big[\s-]*hunt/gi],
  marginalHunt:   [/marginal[\s-]*hunt/gi],

  // overran / over ran / over run / ran over
  overran:        [/\boverran\b/gi, /\bover[\s-]*(?:ran|run)\b/gi, /\bran\s+over\b/gi],

  // short checkdown / short check down / hyphenated
  shortCheckDown: [/short[\s-]*check[\s-]*down/gi, /short[\s-]*checkdown/gi],

  // backside of (the) gun | back of (the) gun
  backSideOfGun:  [
    /back\s*side\s*of\s*(?:the\s*)?gun/gi,
    /backside\s*of\s*(?:the\s*)?gun/gi,
    /back\s*of\s*(?:the\s*)?gun/gi
  ],

  handled:        [/\bhandled?\b/gi],

  // cast refusal + inflections
  castRefusal:    [/cast[\s-]*refusal/gi, /cast[\s-]*refused/gi, /refused[\s-]*cast/gi],

  // sit|sat on (the) whistle
  sitOnWhistle:   [/\b(?:sit|sat)\s*on\s*(?:the\s*)?whistle\b/gi],

  // didn't|did not mark
  didntMark:      [/(?:didn'?t|did\s+not)\s*mark/gi],

  poorInitial:    [/poor\s*initial/gi],

  // head swing / headswing / head swung
  headswing:      [/head\s*swing/gi, /\bheadswing\b/gi, /\bhead\s*swung\b/gi],

  break:          [/\bbroke?\b/gi, /\bbreak\b/gi],
  switched:       [/\bswitch(?:ed|)\b/gi, /did\s*(?:a\s*)?switch\b/gi],
  noGo:           [/\bno[-\s]?go\b/gi],

  // poison pick up (hyphen tolerant) | picked up (the) poison
  pickedUpPoison: [/poison\s*pick[-\s]*up/gi, /picked\s*up\s*(?:the\s*)?poison/gi],

  // no pick up | no pick-up | no pickup
  noPickUp:       [/\bno\s*pick[-\s]*up\b/gi, /\bno\s*pickup\b/gi],

  stoodOut:       [/stood\s*out/gi],
  popped:         [/\bpopped?\b/gi],
};

/* ---------------- Demo items ---------------- */
let items = [];
/* ---------------- UI ---------------- */
const itemsEl = document.getElementById('items');
const statusEl = document.getElementById('status');

// --- Stage (carousel) refs/state ---
const stageEl = document.getElementById('stage');
let idxMark  = +(localStorage.getItem('idxMark')  || 0);
let idxBlind = +(localStorage.getItem('idxBlind') || 0);

// ------- Helpers for today + formatting -------
function ymd(d){ const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`; }
function yards(n){ return (typeof n==='number' && isFinite(n)) ? Math.round(n) : 0; }

// Build our speech-page item objects from setups doc
function buildSpeechItemsFromSetupDoc(data){
  const out = [];
  const marks  = Array.isArray(data.items)  ? data.items  : [];
  const blinds = Array.isArray(data.blinds) ? data.blinds : [];

  marks.forEach((m, i) => {
    out.push({
      id: m.id || `m_${i+1}`,
      kind: 'Mark',
      title: `#${i+1} ‚Äî ${yards(m.dist)} yards`,
      score: 0,
      flags: {}
    });
  });

  blinds.forEach((b, i) => {
    out.push({
      id: b.id || `b_${i+1}`,
      kind: 'Blind',
      title: `#${i+1} ‚Äî ${yards(b.dist)} yards`,
      score: 0,
      flags: {}
    });
  });

  return out;
}

// Reset stage so new data doesn't inherit old panes
function resetStage(){
  idxMark = 0; idxBlind = 0;
  try {
    localStorage.setItem('idxMark', '0');
    localStorage.setItem('idxBlind', '0');
  } catch {}
  stageEl.innerHTML = '';   // remove previous .pane-slot(s)
  itemsEl.innerHTML = '';   // clear old rows list
}

// Load today's Setup N for a trainer (defaults: Scott / 1)
async function loadTodaysSetup({ trainer='Scott', setupOrder=1 } = {}){
const dateKey = ymd(new Date());
currentDateKey = dateKey;          

  setStatus(`Loading ${trainer} ‚Äì ${dateKey} (Setup ${setupOrder})‚Ä¶`);

  const dayColl = db.collection('setups').doc(trainer)
                    .collection('days').doc(dateKey)
                    .collection('setups');

  const snap = await dayColl.orderBy('order').get();
  if (snap.empty){
    setStatus('No setups found for today. Using empty list.');
    resetStage();
    items = [];
    renderAll();
    renderStage();
    return;
  }

  // choose requested order if present, else first doc
let chosen = snap.docs[0];
if (setupOrder > 1){
  const found = snap.docs.find(d => (d.data()?.order ?? 0) === setupOrder);
  if (found) chosen = found;
}
currentTrainer = trainer;                  // <‚Äî add
currentSetupId = chosen.id;                // <‚Äî add
currentSetupOrder = setupOrder || 1;       // <‚Äî add


  const data = chosen.data() || {};
  items = buildSpeechItemsFromSetupDoc(data);

  resetStage();
  renderAll();
  renderStage();
if (selectedDog) { loadDogRun(selectedDog).catch(console.error); }
  const m = items.filter(x=>x.kind==='Mark').length;
  const b = items.filter(x=>x.kind==='Blind').length;
  setStatus(`Loaded ${trainer} ‚Äì ${dateKey} ‚Ä¢ ${m} marks / ${b} blinds`);
}

// (optional) expose for console testing
window.loadTodaysSetup = loadTodaysSetup;


function clamp(i, len){ if(len<=0) return 0; return (i%len+len)%len; }
function saveIdx(){ localStorage.setItem('idxMark', idxMark); localStorage.setItem('idxBlind', idxBlind); }


function chip(key,on){
  const el=document.createElement('span');
  el.className='chip'+(on?' on':'');
  el.dataset.key=key;
  el.textContent=FLAG_MAP[key].label;
  return el;
}
function renderRow(it){
  const row=document.createElement('div'); row.className='row'; row.id='row-'+it.id;

  const left=document.createElement('div');
  left.innerHTML=`<div class="kind">${it.kind}</div><div class="title">${it.title}</div>`;

  const mid=document.createElement('div');
  const chips=document.createElement('div'); chips.className='chips';
  FLAGS.forEach(f=> chips.appendChild(chip(f.key, !!it.flags[f.key])));
  mid.appendChild(chips);
  
 const right=document.createElement('div'); right.className='controls';
const flagBtn = document.createElement('button');
flagBtn.type='button';
flagBtn.className='flagBtn big';
flagBtn.title='Hold to view flags ‚Ä¢ Swipe down to clear';
flagBtn.textContent='üö©';
setupFlagPeek(flagBtn, it.id);

const mic=document.createElement('button'); mic.type='button'; mic.className='mic big';
mic.innerHTML='<span class="dot"></span> üé§ Listen';

  mic.addEventListener('click',()=>startListeningFor(it.id));
  
  const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='10'; slider.step='0.5'; slider.value=it.score;
  slider.addEventListener('input',()=>{ it.score=+slider.value; score.textContent=it.score.toFixed(1);debouncedSaver(it.id)();});
  const score=document.createElement('div'); score.className='score'; score.textContent=it.score.toFixed(1);
 right.append(flagBtn, mic, slider, score);

  row.append(left,mid,right);
  itemsEl.appendChild(row);
}
function renderAll(){ itemsEl.innerHTML=''; items.forEach(renderRow); }

function ensureSlot(type){
  let slot = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if(!slot){
    slot = document.createElement('div');
    slot.className = 'pane-slot';
    slot.dataset.type = type;
    stageEl.appendChild(slot);
  }
  return slot;
}

function renderStage(){
  const marks  = items.filter(it=>it.kind==='Mark');
  const blinds = items.filter(it=>it.kind==='Blind');
  if (!stageEl) return;

  idxMark  = clamp(idxMark,  marks.length);
  idxBlind = clamp(idxBlind, blinds.length);

  // Ensure slots exist (one for each)
  const markSlot  = ensureSlot('mark');
  const blindSlot = ensureSlot('blind');

  // First time render: if slot empty, just place the pane (no animation)
  if(!markSlot.querySelector('.pane')){
    markSlot.appendChild(renderPane('Mark', marks[idxMark], marks.length, 'mark'));
  }
  if(!blindSlot.querySelector('.pane')){
    blindSlot.appendChild(renderPane('Blind', blinds[idxBlind], blinds.length, 'blind'));
  }
}

// direction: 'left' (next) or 'right' (prev)
function animateSwap(type, direction){
  const isMark = (type==='mark');
  const list   = items.filter(it=> it.kind === (isMark ? 'Mark' : 'Blind'));
  const total  = list.length;
  const idx    = isMark ? idxMark : idxBlind;
  const slot   = stageEl.querySelector(`.pane-slot[data-type="${type}"]`);
  if(!slot || !total) return;

  const current = slot.querySelector('.pane');
  const label   = isMark ? 'Mark' : 'Blind';
  const next    = renderPane(label, list[idx], total, type);

  // stage the new pane off-screen
  next.classList.add(direction==='left' ? 'enter-from-right' : 'enter-from-left');
  slot.appendChild(next);

  // lock both panes to the slot for animation
  next.style.position = current.style.position = 'absolute';
  next.style.inset    = current.style.inset    = '0';

  // kick the transition
  requestAnimationFrame(()=>{
    current.classList.add(direction==='left' ? 'exit-to-left' : 'exit-to-right');
    next.classList.remove('enter-from-right','enter-from-left');
  });

  const cleanup = () => {
    current?.remove();
    // let the survivor be normal flow for focus/scroll if you prefer (or stay absolute)
    next.style.position = 'absolute';  // keep absolute so future swaps overlay cleanly
    next.style.inset = '0';
  };
  next.addEventListener('transitionend', cleanup, { once:true });
}


function renderPane(label, it, total, type){
  const pane = document.createElement('div');
  pane.className = 'pane';
  pane.dataset.type = type;

  const head = document.createElement('div');
  head.className = 'pane-head';
  head.innerHTML = `
    <div class="kind">${label}</div>
    <div class="title">${it ? it.title : '‚Äî'}</div>
  `;

  const ctrls = document.createElement('div');
  ctrls.className = 'pane-controls';

  // Big red flag
  const flagBtn = document.createElement('button');
  flagBtn.type='button';
  flagBtn.className='flagBtn big';
  flagBtn.title='Hold to view flags ‚Ä¢ Swipe down to clear';
  flagBtn.textContent='üö©';

  // Big mic
  const mic = document.createElement('button');
  mic.type='button';
  mic.className='mic big';
  mic.innerHTML='<span class="dot"></span> üé§ Listen';

  // Hidden range kept for compatibility with existing code
  const range = document.createElement('input');
  range.type='range'; range.min='0'; range.max='10'; range.step='0.5';
  range.value = it ? it.score : 0;
  range.className = 'visually-hidden';

  // Hidden legacy score node (so syncStageForItem still finds something)
  const legacyScore = document.createElement('div');
  legacyScore.className='score big';
  legacyScore.textContent = (it ? it.score : 0).toFixed(1);

  // New score cluster: [-] [ 7.5 ] [+]
  const scoreWrap = document.createElement('div');
  scoreWrap.className = 'scoreWrap';

  const dec = document.createElement('button');
  dec.type='button';
  dec.className='scoreBtn';
  dec.setAttribute('aria-label','Decrease score');
  dec.textContent='‚Äì';

  const badge = document.createElement('div');
  badge.className='scoreBadge';
  badge.textContent = (it ? it.score : 0).toFixed(1);

  const inc = document.createElement('button');
  inc.type='button';
  inc.className='scoreBtn';
  inc.setAttribute('aria-label','Increase score');
  inc.textContent='+';

  scoreWrap.append(dec, badge, inc);

  // Pager dots
  const pager = document.createElement('div');
  pager.className = 'pager';
  if (total > 1){
    for(let i=0;i<total;i++){
      const d=document.createElement('div');
      d.className='dot' + (i === (type==='mark'?idxMark:idxBlind) ? ' on' : '');
      pager.appendChild(d);
    }
  }

  if (it){
    // speech + flags
    mic.addEventListener('click', ()=> startListeningFor(it.id));
    setupFlagPeek(flagBtn, it.id);

    // slider (hidden) still reflects changes
    range.addEventListener('input', ()=>{
      it.score = +range.value;
      const v = it.score = quant05(it.score);
      badge.textContent = v.toFixed(1);
      legacyScore.textContent = v.toFixed(1);
      debouncedSaver(it.id)();
    });
    range.addEventListener('pointerdown', (e)=> e.stopPropagation());

    // ¬± buttons (0.5 step)
    const nudge = (dir)=> {
      const raw = (it.score ?? 0) + (dir * 0.5);
      const v = it.score = Math.max(0, Math.min(10, quant05(raw)));
      range.value = v;
      badge.textContent = v.toFixed(1);
      legacyScore.textContent = v.toFixed(1);
      // keep row UI in sync (even though the list is hidden on this page)
      syncRow(it);
      debouncedSaver(it.id)();
    };
    dec.addEventListener('click', ()=> nudge(-1));
    inc.addEventListener('click', ()=> nudge(+1));

    // Swipe left/right to navigate
    attachSwipeX(pane, 60,
      () => { // left ‚Üí next
        if (type==='mark'){ idxMark = clamp(idxMark+1, total); }
        else { idxBlind = clamp(idxBlind+1, total); }
        saveIdx(); animateSwap(type, 'left');
      },
      () => { // right ‚Üí prev
        if (type==='mark'){ idxMark = clamp(idxMark-1, total); }
        else { idxBlind = clamp(idxBlind-1, total); }
        saveIdx(); animateSwap(type, 'right');
      }
    );
  }

  // Order: flag / mic / score cluster / pager (range+legacy hidden)
  ctrls.append(flagBtn, mic, scoreWrap, pager, range, legacyScore);
  pane.append(head, ctrls);
  return pane;
}


function attachSwipeX(el, threshold, onLeft, onRight){
  let pid=null, sx=0, dx=0, ignore=false;

  el.addEventListener('pointerdown', (e)=>{
  const t = e.target;
  // bail out if the gesture started on any interactive control
  const isInteractive = t && typeof t.closest === 'function' &&
    (t.closest('input[type="range"]') || t.closest('.mic') || t.closest('.flagBtn'));
  if (isInteractive) {
    ignore = true; pid=null; sx=0; dx=0;
    return; // let mic/flag/slider handle it; do NOT capture
  }

  ignore = false;
  pid = e.pointerId; sx = e.clientX; dx = 0;
  el.setPointerCapture?.(pid);
});


  el.addEventListener('pointermove', (e)=>{
    if (ignore || e.pointerId!==pid) return;
    dx = e.clientX - sx;
  });

  const end = (e)=>{
    if (ignore) { ignore=false; return; }
    if (e.pointerId!==pid) return;
    if (dx <= -threshold) onLeft?.();
    else if (dx >= threshold) onRight?.();
    pid=null; dx=0;
  };
  el.addEventListener('pointerup', end);
  el.addEventListener('pointercancel', end);
}



renderAll();          // safe no-op while empty
renderStage();
loadTodaysSetup({ trainer: 'Scott', setupOrder: 1 }).catch(err=>{
  console.error(err);
  setStatus('Failed to load today‚Äôs setup.');
});


// --- Peek overlay state/refs ---
const peekOverlay = document.getElementById('peekOverlay');
const peekListEl  = document.getElementById('peekList');
const pullZone    = document.getElementById('pullZone');
const pullBar     = document.getElementById('pullBar');
const pullLabel   = document.getElementById('pullLabel');

// Close when tapping the dim backdrop or pressing Escape
peekOverlay.addEventListener('click', (e)=>{
  if (e.target === peekOverlay) closePeek();
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') closePeek();
});

peekOverlay.addEventListener('pointermove', (e)=>{
  if (peekHold.itemId == null) return;
  if (peekHold.pid != null && e.pointerId !== peekHold.pid) return; // ignore other fingers
  const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
  updatePull(y - peekHold.startY);
}, { passive: true });

document.addEventListener('dog:selected', (e)=>{
  // when the user picks a dog, pull their saved scores/flags for the current setup
  loadDogRun(e.detail.name).catch(console.error);
});


// Global safety net: if the button loses the pointerup, still close
const closeFromDoc = (e)=>{
  if (peekHold.itemId == null) return;
  const y  = e?.clientY ?? (e?.touches?.[0]?.clientY ?? peekHold.startY);
  const dy = y - peekHold.startY;
  if (dy >= peekHold.threshold) clearAllFlags(peekHold.itemId);
  closePeek();
};
document.addEventListener('pointerup', closeFromDoc, { capture:true });
document.addEventListener('pointercancel', closeFromDoc, { capture:true });


// Suppress long-press context menu and text selection on the flag + overlay
['contextmenu', 'selectstart'].forEach(evt => {
  document.addEventListener(evt, (e) => {
    const t = e.target;
    if (t && typeof t.closest === 'function' &&
        (t.closest('.flagBtn') || t.closest('#peekOverlay'))) {
      e.preventDefault();
    }
  }, { passive:false });
});


let peekHold = { itemId:null, startY:0, threshold:90, pid:null };


function openPeek(itemId){
  document.documentElement.classList.add('overlay-open');
  peekHold.itemId = itemId;
  fillPeek(itemId);
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
  pullLabel.textContent = 'Swipe down to clear';
  peekOverlay.classList.add('open');
  peekOverlay.setAttribute('aria-hidden','false');
}
function closePeek(){
  peekOverlay.classList.remove('open');
  peekOverlay.setAttribute('aria-hidden','true');
  peekHold.itemId = null;
  peekHold.pid = null;                 // <‚Äî add this
  pullZone.classList.remove('ready','cleared');
  pullBar.style.height = '0px';
 if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
}


function fillPeek(itemId){
  const it = items.find(x=>x.id===itemId);
  const labels = FLAGS.filter(f => !!(it?.flags?.[f.key])).map(f=>f.label);
  peekListEl.innerHTML = labels.length
    ? labels.map(l=>`<div class="peek-flag">${l}</div>`).join('')
    : `<div class="hint">No flags set</div>`;
}

function updatePull(dy){
  const h = Math.max(0, Math.min(140, dy));
  pullBar.style.height = h + 'px';
  const ready = dy >= peekHold.threshold;
  pullZone.classList.toggle('ready', ready);
  pullLabel.textContent = ready ? 'Release to clear' : 'Swipe down to clear';
}

function clearAllFlags(itemId){
  const it = items.find(x=>x.id===itemId);
  if(!it) return;
  it.flags = {};
  syncRow(it);
  renderStage();
debouncedSaver(itemId)();                     // <‚Äî persist this item

  fillPeek(itemId);
  pullZone.classList.add('cleared');
  pullLabel.textContent = 'Cleared';
}

// Attach pointer interactions to a given red circle button
function setupFlagPeek(btn, itemId){
  let pid = null, holding = false;

  // prevent native long-press callout / selection on this control
  btn.addEventListener('contextmenu', e => e.preventDefault(), { passive:false });
  btn.addEventListener('selectstart', e => e.preventDefault(), { passive:false });
  btn.addEventListener('touchstart',  e => e.preventDefault(), { passive:false });

  btn.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  holding = true;
  pid = e.pointerId;
  peekHold.pid = e.pointerId;          // <‚Äî add this
  btn.setPointerCapture?.(pid);
  peekHold.startY = e.clientY ?? (e.touches?.[0]?.clientY || 0);
  openPeek(itemId);
});


  btn.addEventListener('pointermove', (e)=>{
    if(!holding || e.pointerId !== pid) return;
    const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
    updatePull(y - peekHold.startY);
  });

  const end = (e)=>{
  if(!holding || e.pointerId !== pid) return;
  const y = e.clientY ?? (e.touches?.[0]?.clientY || peekHold.startY);
  const dy = y - peekHold.startY;
  if (dy >= peekHold.threshold) clearAllFlags(itemId);
  holding = false;
  try { btn.releasePointerCapture?.(pid); } catch {}
  pid = null;
  peekHold.pid = null;                 // <‚Äî add this
  closePeek();
};

btn.addEventListener('pointerup', end);
btn.addEventListener('pointercancel', end);

}


/* ---------------- Speech engine ---------------- */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let rec=null, activeId=null, activeFix=null; // activeFix = { itemId, phrase, suggestKey }
if (SR){
  rec=new SR(); rec.lang='en-US'; rec.interimResults=false; rec.continuous=false;
  rec.onstart=()=>setStatus('listening‚Ä¶');
  rec.onerror=e=>{ setStatus('error: '+(e.error||'unknown')); endListen(); };
  rec.onend=()=>{ setStatus('idle'); endListen(); };
  rec.onresult = (e) => {
    // Build a ‚Äúbest guess‚Äù for apply, but also capture the last result‚Äôs alternatives.
    const tx = [...e.results].map(r => r[0].transcript).join(' ').trim();

    // Log alternatives (browser-dependent confidence support)
    const last = e.results[e.results.length - 1];
    const alts = last ? Array.from(last).map(a => ({
      transcript: (a.transcript || '').trim(),
      confidence: (typeof a.confidence === 'number') ? +a.confidence.toFixed(3) : null
    })) : [];

    const best = alts[0]?.transcript || tx;
	
	// ---- inside rec.onresult, right after you set `const best = ...` ----
if (dogListenActive){
  const name = matchDogName(best);
  if (name){
    setSelectedDog(name);
    setStatus('Dog: ' + name);
  }else{
    setStatus('Heard: "'+best+'", didn‚Äôt match a dog');
  }
  dogListenActive = false;
  dogMicBtn?.classList.remove('listening');
  return; // don‚Äôt run the row/flags logic for this utterance
}


    console.groupCollapsed(
      `%cSpeech(final) ‚Üí %c${best}`,
      'color:#888', 'color:#111;font-weight:700'
    );
    console.log('activeId:', activeId, 'activeFix:', activeFix);
    if (alts.length) console.table(alts);
    console.groupEnd();

    if (activeFix){
      // targeted retry: apply to its row, then remove if matched suggestion or any flag detected
      const before = snapshotFlags(items.find(x=>x.id===activeFix.itemId));
      applyTranscript(activeFix.itemId, best);
      const after = snapshotFlags(items.find(x=>x.id===activeFix.itemId));
      const changed = diffFlags(before, after);
      const matchedSuggestion = changed.added.includes(activeFix.suggestKey) || changed.toggled.includes(activeFix.suggestKey);
      if (matchedSuggestion || (changed.added.length + changed.toggled.length) > 0) {
        removeMissed(activeFix.itemId, activeFix.phrase);
        renderMissedOverlay();
      }
      activeFix = null;
    } else if (activeId) {
      applyTranscript(activeId, best);
    }
  };

}else{
  setStatus('Speech API not supported in this browser.');
}
function setStatus(s){ statusEl.textContent='Status: '+s; }
function startListeningFor(id){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeFix=null;
  activeId=id;
  document.querySelectorAll('.row')
    .forEach(r=> r.classList.toggle('listening', r.id==='row-'+id));
  rec.start();
}
function startFixListening(itemId, phrase, suggestKey){
  if(!rec){ alert('Speech API not supported'); return; }
  try{ rec.abort(); }catch{}
  activeId=null;
  activeFix={ itemId, phrase, suggestKey };
  document.querySelectorAll('.row').forEach(r=>r.classList.remove('listening'));
  document.getElementById('row-'+itemId)?.classList.add('listening');
  rec.start();
}
function endListen(){
  activeId=null;
  document.querySelectorAll('.row').forEach(r=> r.classList.remove('listening'));
}

/* ---------------- NLP core ---------------- */
function normalize(s){
  return String(s||'')
    .toLowerCase()
    .replace(/[‚Äô‚Äò']/g,"'")
    .replace(/[^a-z0-9.\s-]/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}
const NUM_WORDS = {
  zero:0, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9, ten:10,
  eleven:11, twelve:12, thirteen:13, fourteen:14, fifteen:15, sixteen:16, seventeen:17, eighteen:18, nineteen:19,
  twenty:20, half:0.5
};
function wordsToNumber(s){
  s=normalize(s);
  if(/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);
  const tok=s.split(/\s+/);
  const i=tok.indexOf('point');
  if(i>-1){
    const A=tok.slice(0,i).join(' ');
    const B=tok.slice(i+1).join(' ');
    const ia=NUM_WORDS[A]; const ib=NUM_WORDS[B];
    if(Number.isFinite(ia) && Number.isFinite(ib)) return +(ia + '.' + Math.round(ib*10));
  }
  if(s in NUM_WORDS) return NUM_WORDS[s];
  return NaN;
}

function quant05(n){ return Math.max(0, Math.min(10, Math.round(n*2)/2)); }

// treat digits or number-words as numeric (e.g., "nine", "seven point five")
function isNumberish(s){
  const t = normalize(s);
  if(!t) return false;
  if(/^\d+(\.\d+)?$/.test(t)) return true;
  return Number.isFinite(wordsToNumber(t));
}


function detectFlagsMulti(tx){
  const found=new Set();
  const hits=[]; // {key,start,end}
  for (const f of FLAGS){
    for (const rx of (FLAG_RX[f.key] || [])){
      rx.lastIndex = 0;
      let m;
      while ((m = rx.exec(tx)) !== null){
        found.add(f.key);
      }
    }
    // position by variants (first occurrence)
    let best=null;
    for (const v of f.variants){
      const ix = tx.indexOf(v);
      if (ix>=0 && (best==null || ix<best.start)){
        best = {start:ix, end:ix+v.length};
      }
    }
    if (best) hits.push({ key:f.key, start:best.start, end:best.end });
  }
  hits.sort((a,b)=>a.start-b.start);
  return { keys:[...found], hits };
}

/* Parse utterance ‚Üí intents + missed phrases (between hits) */
function parseUtterance(raw){
  const tx = normalize(raw);
  const intents={ add:new Set(), remove:new Set(), toggle:new Set(), clearAll:false, score:null, adjust:0 };
  if(/\bclear\s+flags?\b/.test(tx)) intents.clearAll=true;

  // score explicit
  let m=tx.match(/\b(?:rating|score|set|make)\b(?:\s*(?:it|to|at))?\s+([a-z0-9.\s-]+)(?!.*\b(?:by)\b)/);
  if(m){ const n=wordsToNumber(m[1].trim()); if(Number.isFinite(n)) intents.score=quant05(n); }
  else {
    // pure-number utterance ‚Üí score
    if(/^\d+(\.\d+)?$/.test(tx) || Number.isFinite(wordsToNumber(tx))){
      const n=wordsToNumber(tx); if(Number.isFinite(n)) intents.score=quant05(n);
    }
  }

  // adjustments
  const inc=tx.match(/\b(increase|raise|up|\+|plus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  const dec=tx.match(/\b(decrease|lower|down|-|minus)\b(?:.*?\bby\b)?\s*([a-z0-9.\s-]+)?/);
  if(inc && !dec){ const amt = inc[2] ? (Number.isFinite(wordsToNumber(inc[2])) ? wordsToNumber(inc[2]) : parseFloat(inc[2])) : 0.5; intents.adjust += Number.isFinite(amt) ? amt : 0.5; }
  if(dec && !inc){ const amt = dec[2] ? (Number.isFinite(wordsToNumber(dec[2])) ? wordsToNumber(dec[2]) : parseFloat(dec[2])) : 0.5; intents.adjust -= Number.isFinite(amt) ? amt : 0.5; }

  // flags + hit spans
  const { keys, hits } = detectFlagsMulti(tx);
  const isRemove=/\b(remove|clear|unset|delete)\b/.test(tx);
  const isAdd=/\b(add|flag|set)\b/.test(tx);
  for (const k of keys){
    if(isRemove) intents.remove.add(k);
    else if(isAdd) intents.add.add(k);
    else intents.toggle.add(k);
  }

  // infer missed phrases (now robust for head/tail too)
  let missed = [];
  if (hits.length >= 2) {
    missed = inferMissedSegments(tx, hits);
  } else {
    missed = inferMissedLoose(tx, hits);
  }

  // ---- DEBUG CONSOLE ----
  console.groupCollapsed('%cNLP', 'color:#0b74ff;font-weight:700');
  console.log('raw:', raw);
  console.log('normalized:', tx);
  console.log('flags(keys):', keys);
  console.log('hits:', hits);
  console.log('missed:', missed);
  console.log('score:', intents.score, 'adjust:', intents.adjust, 'clearAll:', intents.clearAll);
  console.log('add:', Array.from(intents.add));
  console.log('remove:', Array.from(intents.remove));
  console.log('toggle:', Array.from(intents.toggle));
  console.groupEnd();
  // -----------------------

  return { intents, missed, hits, keys };
}


/* Heuristic: segments between detected flags that still have meaningful tokens */
const STOPWORDS = /\b(?:and|then|uh|um|a|an|the|please|flag|set|add|remove|clear|by|to|at|on|in|into|onto|with|for|from|about|around|like|as|score|rating|make|plus|minus|up|down|of|this|that|there|here|it|him|her|them|they|their|his|hers|just)\b/gi;

function cleanSegment(seg){
  return seg.replace(/[^a-z0-9.\s-]/g,' ').replace(/\s+/g,' ').replace(STOPWORDS,' ').replace(/\s+/g,' ').trim();
}
function inferMissedSegments(tx, hits){
  const out = [];
  if (!hits.length) return out;

  const sorted = hits.slice().sort((a,b)=>a.start - b.start);

  // HEAD (before first hit)
  {
    const first = sorted[0];
    const head = cleanSegment(tx.slice(0, first.start));
    if (head && !isNumberish(head)) {
      const suggestion = bestSuggestion(head);
      out.push({
        raw: head,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: null,
        rightKey: first.key
      });
    }
  }

  // BETWEEN hits
  for (let i = 0; i < sorted.length - 1; i++){
    const a = sorted[i], b = sorted[i+1];
    if (b.start <= a.end) continue;
    const mid = cleanSegment(tx.slice(a.end, b.start));
    if (mid && !isNumberish(mid)) {
      const suggestion = bestSuggestion(mid);
      out.push({
        raw: mid,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: a.key,
        rightKey: b.key
      });
    }
  }

  // TAIL (after last hit)
  {
    const last = sorted[sorted.length - 1];
    const tail = cleanSegment(tx.slice(last.end));
    if (tail && !isNumberish(tail)) {
      const suggestion = bestSuggestion(tail);
      out.push({
        raw: tail,
        suggestKey: suggestion?.key || null,
        suggestLabel: suggestion?.label || null,
        leftKey: last.key,
        rightKey: null
      });
    }
  }

  return dedupeMissed(out);
}

function dedupeMissed(arr){
  const seen=new Set(); const out=[];
  for (const x of arr){
    const k=x.raw.toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k); out.push(x);
  }
  return out;
}

// treat the whole utterance (0 hits) or edge segments (1 hit) as candidates
function inferMissedLoose(tx, hits){
  const out = [];
  const addCand = (raw, leftKey=null, rightKey=null) => {
    const cleaned = cleanSegment(raw);
    if (!cleaned) return;
    // ignore numbers-only like "7" or "7.5"
    if (isNumberish(cleaned)) return;

    const suggestion = bestSuggestion(cleaned);
    out.push({
      raw: cleaned,
      suggestKey: suggestion?.key || null,
      suggestLabel: suggestion?.label || null,
      leftKey, rightKey
    });
  };

  if (hits.length === 0) {
    // no flags detected -> whole utterance is a candidate
    addCand(tx);
    return dedupeMissed(out);
  }

  if (hits.length === 1) {
    const h = hits[0];
    const pre  = tx.slice(0, h.start);
    const post = tx.slice(h.end);
    addCand(pre, null, h.key);
    addCand(post, h.key, null);
    return dedupeMissed(out);
  }

  return out; // fallback ‚Äì shouldn't happen here
}


/* Fuzzy suggestion (Levenshtein) to nearest canonical phrase */
function lev(a,b){
  const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}
function bestSuggestion(seg){
  let best=null; const s=seg.toLowerCase();
  for (const f of FLAGS){
    for (const v of f.variants){
      const d = lev(s, v);
      const sim = 1 - d / Math.max(s.length, v.length);
      if (!best || sim > best.sim) best = { key:f.key, label:f.label, sim };
    }
  }
  return (best && best.sim >= 0.55) ? best : null; // threshold
}

let DOG_NAMES = [];
let selectedDog = localStorage.getItem('selectedDog') || null;
const dogNameEl = document.getElementById('dogName');
const dogHintEl = document.getElementById('dogHint');
const dogMicBtn = document.getElementById('dogMic');

// show persisted selection on load
if (selectedDog) dogNameEl.textContent = selectedDog;

// pull all names from every `layouts/*` doc you‚Äôre already writing in trailer.html
async function fetchDogNames(){
  const snap = await db.collection('layouts').get();
  const bucket = [];
  snap.forEach(doc => {
    const d = doc.data() || {};
    if (Array.isArray(d.masterNames)) bucket.push(...d.masterNames);
    if (Array.isArray(d.dockNames))   bucket.push(...d.dockNames);
    if (d.slotData && typeof d.slotData === 'object') {
      bucket.push(...Object.values(d.slotData).filter(Boolean));
    }
  });
  // unique + cleaned + sorted
  DOG_NAMES = [...new Set(bucket.map(n => String(n).trim()).filter(Boolean))]
               .sort((a,b)=>a.localeCompare(b));
  dogHintEl.textContent = DOG_NAMES.length
    ? `Say a name (${DOG_NAMES.length} loaded)`
    : `No names found in Firestore layouts`;
}
fetchDogNames().catch(err=>{
  console.error(err);
  dogHintEl.textContent = 'Failed to load names';
});

// similarity helper using your existing lev()
function sim(a,b){
  const A = normalize(a), B = normalize(b);
  if (!A || !B) return 0;
  const d = lev(A,B);
  return 1 - d / Math.max(A.length, B.length);
}

// find the best dog name for a transcript
function matchDogName(heard){
  const q = normalize(heard);
  if (!q) return null;

  // 1) exact token contain check (fast path)
  let exact = DOG_NAMES.find(n => q.includes(normalize(n)));
  if (exact) return exact;

  // 2) highest similarity
  let best = null;
  for (const n of DOG_NAMES){
    const s = sim(q, n);
    if (!best || s > best.s) best = { n, s };
  }
  // require a reasonably strong match
  return (best && best.s >= 0.72) ? best.n : null;
}

function setSelectedDog(name){
  selectedDog = name;
  dogNameEl.textContent = name;
  localStorage.setItem('selectedDog', name);
  // broadcast so other parts can react if needed
  document.dispatchEvent(new CustomEvent('dog:selected', { detail: { name } }));
}

// We‚Äôll reuse your existing SpeechRecognition instance `rec`
let dogListenActive = false;

// attach the button
if (dogMicBtn){
  dogMicBtn.addEventListener('click', ()=>{
    if (!rec){ alert('Speech API not supported'); return; }
    try{ rec.abort(); }catch{}
    dogListenActive = true;
    // optional little UI cue
    dogMicBtn.classList.add('listening');
    setStatus('listening‚Ä¶ (dog name)');
    rec.start();
  });
}

/* ---------------- Apply to row, then surface missed overlay + logging ---------------- */
function quantClamp(n){ return Math.max(0, Math.min(10, n)); }

// Update the on-screen pane (Mark or Blind) without re-rendering the whole stage
function syncStageForItem(it){
  const type = it.kind === 'Mark' ? 'mark' : 'blind';
  const pane = stageEl.querySelector(`.pane-slot[data-type="${type}"] .pane`);
  if (!pane) return; // not currently visible

  const rangeEl = pane.querySelector('input[type="range"]');
  const scoreEl = pane.querySelector('.score');

  if (rangeEl) rangeEl.value = it.score;
  if (scoreEl) scoreEl.textContent = it.score.toFixed(1);
}


function applyTranscript(itemId, raw){
  const it=items.find(x=>x.id===itemId); if(!it) return;
  const { intents, missed } = parseUtterance(raw);
  if (missed.length && (!intents.add.size && !intents.remove.size && !intents.toggle.size)) {
    setStatus('No flags matched; queued ' + missed.length + ' missed phrase(s).');
  }

  if(intents.clearAll) it.flags = {};

  intents.add.forEach(k => it.flags[k]=true);
  intents.remove.forEach(k => it.flags[k]=false);
  intents.toggle.forEach(k => it.flags[k]=!it.flags[k]);

  if(Number.isFinite(intents.score)) it.score=intents.score;
  if(intents.adjust!==0) it.score=quant05(it.score + intents.adjust);
  it.score = quantClamp(it.score);

   syncRow(it);
  syncStageForItem(it); // <-- instantly reflect score on the visible pane


  if (missed.length){
    // build per-row missed items and log phrases
    for (const m of missed){
      addMissed(itemId, it.title, m.raw, m.suggestKey, m.suggestLabel);
      logUnassigned(m.raw);
    }
    renderMissedOverlay();
  }
  
  debouncedSaver(itemId)();                     // <‚Äî persist this item

}
function syncRow(it){
  const row=document.getElementById('row-'+it.id);
  if(!row) return;
  row.querySelector('input[type=range]').value=it.score;
  row.querySelector('.score').textContent=it.score.toFixed(1);
  row.querySelectorAll('.chip').forEach(ch=>{
    const k=ch.dataset.key;
    ch.classList.toggle('on', !!it.flags[k]);
  });
}
function snapshotFlags(it){
  const on = Object.entries(it.flags||{}).filter(([k,v])=>!!v).map(([k])=>k);
  return { on: new Set(on) };
}
function diffFlags(before, after){
  const b=[...before.on], a=[...after.on];
  const added = a.filter(k=>!before.on.has(k));
  const removed = b.filter(k=>!new Set(a).has(k));
  // treat simple toggles as added for our purposes:
  return { added, removed, toggled: added };
}

/* ---------------- Missed overlay state ---------------- */
const missedOverlay = document.getElementById('missedOverlay');
const missedListEl = document.getElementById('missedList');
document.getElementById('missedClose').addEventListener('click', ()=> closeMissed());
document.getElementById('missedClear').addEventListener('click', ()=> { missedItems.length=0; renderMissedOverlay(); });

let missedItems = []; // { itemId, rowTitle, phrase, suggestKey?, suggestLabel? }
function addMissed(itemId, rowTitle, phrase, suggestKey, suggestLabel){
  const key = `${itemId}||${phrase.toLowerCase()}`;
  if (missedItems.some(x => `${x.itemId}||${x.phrase.toLowerCase()}`===key)) return;
  missedItems.push({ itemId, rowTitle, phrase, suggestKey, suggestLabel });
}
function removeMissed(itemId, phrase){
  missedItems = missedItems.filter(x => !(x.itemId===itemId && x.phrase.toLowerCase()===phrase.toLowerCase()));
}
function openMissed(){ 
  document.documentElement.classList.add('overlay-open');
  missedOverlay.classList.add('open'); 
  missedOverlay.setAttribute('aria-hidden','false'); 
}
function closeMissed(){ 
  missedOverlay.classList.remove('open'); 
  missedOverlay.setAttribute('aria-hidden','true'); 
  if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
}

function renderMissedOverlay(){
  missedListEl.innerHTML = '';
  if (!missedItems.length){ closeMissed(); return; }

  for (const m of missedItems){
    const row = document.createElement('div'); row.className='missed-item';
    const meta = document.createElement('div'); meta.className='missed-meta';
    meta.innerHTML = `
      <div class="missed-phrase">${m.phrase}</div>
      <div class="missed-row">Row: ${m.rowTitle}</div>
      ${m.suggestLabel ? `<div class="hint">Did you mean <b>${m.suggestLabel}</b>?</div>` : ''}
    `;
    const actions = document.createElement('div'); actions.className='missed-actions';
    const mic = document.createElement('button'); mic.className='btn small'; mic.innerHTML='üé§ Say again';
    mic.addEventListener('click', ()=> startFixListening(m.itemId, m.phrase, m.suggestKey||null));
    actions.appendChild(mic);

    if (m.suggestKey){
      const quick = document.createElement('button'); quick.className='btn small primary';
      quick.textContent = `‚úì Apply ${m.suggestLabel}`;
      quick.addEventListener('click', ()=>{
        const it = items.find(x=>x.id===m.itemId); if (!it) return;
        it.flags[m.suggestKey] = true;
		debouncedSaver(it.id)();                      // <‚Äî persist change

        syncRow(it);
        removeMissed(m.itemId, m.phrase);
        renderMissedOverlay();
      });
      actions.appendChild(quick);
    }

    const dismiss = document.createElement('button'); dismiss.className='btn small';
    dismiss.textContent='Dismiss';
    dismiss.addEventListener('click', ()=>{ removeMissed(m.itemId, m.phrase); renderMissedOverlay(); });
    actions.appendChild(dismiss);

    row.append(meta, actions);
    missedListEl.appendChild(row);
  }
  openMissed();
}

/* ---------------- Master unassigned log (localStorage) ---------------- */
const LOG_KEY = 'speech_unassigned_log_v1';
function readLog(){ try{ return JSON.parse(localStorage.getItem(LOG_KEY)||'[]'); }catch{return[];} }
function writeLog(arr){ localStorage.setItem(LOG_KEY, JSON.stringify(arr)); }
function logUnassigned(phrase){
  const p = phrase.toLowerCase();
  const arr = readLog();
  const idx = arr.findIndex(x=>x.phrase===p);
  if (idx>=0){ arr[idx].count += 1; arr[idx].last = Date.now(); }
  else { arr.push({ phrase:p, count:1, last:Date.now() }); }
  writeLog(arr);
}
function clearLog(){ writeLog([]); }
function renderLog(){
  const listEl = document.getElementById('logList');
  listEl.innerHTML='';
  const arr = readLog().sort((a,b)=>b.count-a.count);
  if (!arr.length){
    const empty = document.createElement('div'); empty.className='hint'; empty.textContent='No data yet.';
    listEl.appendChild(empty); return;
  }
  arr.forEach(x=>{
    const row = document.createElement('div'); row.className='log-item';
    const left = document.createElement('div'); left.innerHTML = `<strong>${x.phrase}</strong>`;
    const right = document.createElement('div'); right.innerHTML = `<span class="count">${x.count}</span>`;
    row.append(left, right); listEl.appendChild(row);
  });
}

document.getElementById('viewLogBtn').addEventListener('click', ()=>{
  renderLog();
  document.documentElement.classList.add('overlay-open');
  logOverlay.classList.add('open');
});
document.getElementById('logClose').addEventListener('click', ()=>{
  logOverlay.classList.remove('open');
  if (!document.querySelector('.overlay.open')) document.documentElement.classList.remove('overlay-open');
});

const logOverlay = document.getElementById('logOverlay');

/* ---------------- Clear all ---------------- */
document.getElementById('clearBtn').addEventListener('click',()=>{
  items.forEach(it=>{
    it.flags = {};
    it.score = 0;
    syncRow(it);
    debouncedSaver(it.id)();          // persist resets per item
  });
  missedItems.length = 0;
  renderMissedOverlay();
  renderStage();
  setStatus('cleared');
});

</script>
</body>
</html>
